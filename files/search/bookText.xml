<?xml version="1.0" encoding="utf-8"?><Search><pages Count="281"><page Index="1"><![CDATA[AIOT  筆記



























































                                                        Joker Wu
                                                          V 1.0]]></page><page Index="2"><![CDATA[目錄
         CH 1 Arduino 介紹 ...............................................................................................................................................1
              1.1 Arduino  硬體-UNO ...............................................................................................................................2
              1.2 Arduino 安裝與開發環境 ......................................................................................................................5
                   1.2.1 Arduino  開發  IDE  安裝 ............................................................................................................5
                   1.2.2 Arduino  開發環境介紹 ..............................................................................................................8
                   1.2.3 Arduino Uno  第一支程式...........................................................................................................9
              1.3  基本電學..............................................................................................................................................13
                   1.3.1 電荷............................................................................................................................................13
                   1.3.2 電流............................................................................................................................................13
                   1.3.3 電壓............................................................................................................................................14
                   1.3.4 電阻............................................................................................................................................15
                   1.3.5 麵包板使用................................................................................................................................18
                   1.3.6 三用電表....................................................................................................................................21
                   1.3.7 電路............................................................................................................................................22
                   1.3.8 歐姆定律....................................................................................................................................22
                   1.3.9 克希荷夫定律:電流 ..................................................................................................................25
                   1.3.10 克希荷夫定律:電壓 ................................................................................................................26
         CH 2 Arduino 程式語法 .....................................................................................................................................27
              2.1 Arduino  程式主要架構 .......................................................................................................................27
                   2.1.1 程式結構....................................................................................................................................27
                   2.1.2 區塊式結構化程式語言............................................................................................................30
                   2.1.3 命名空間  (naming space) .........................................................................................................30
                   2.1.4 縮小變數的作用範圍................................................................................................................31
                   2.1.5 Arduino  語言支援的資料型態 ................................................................................................35
                   2.1.6 型態轉換....................................................................................................................................38
                   2.1.7 邏輯控制(控制流程) .................................................................................................................39
                   2.1.8 算術運算....................................................................................................................................49
                   2.1.9 比較運算....................................................................................................................................50
                   2.1.10 複合運算符號..........................................................................................................................53
              2.2 函式(Function) ......................................................................................................................................54
                   2.2.1 輸入輸出腳位設定....................................................................................................................54
                   2.2.2 進  階  I/O ..................................................................................................................................57
                   2.2.3 時間函式....................................................................................................................................65
                   2.2.4 數學函式....................................................................................................................................68
                   2.2.5 三角函式....................................................................................................................................71
                   2.2.6 亂數函式....................................................................................................................................72
                   2.2.7 通訊函式....................................................................................................................................73
                   2.2.8 格式字串(encoding) ..................................................................................................................75
                   2.2.9 系統函式....................................................................................................................................78
         CH 3  智慧農場專案 ..........................................................................................................................................92
              3.1 專案概述...............................................................................................................................................92
              3.2 系統架構...............................................................................................................................................93
              3.3  技術說明..............................................................................................................................................93


                                                              1]]></page><page Index="3"><![CDATA[3.4  硬體接線..............................................................................................................................................94
              3.5  元件介紹..............................................................................................................................................96
                   3.5.1 LCD 1602 顯示幕......................................................................................................................96
                   3.5.2 DC-5V Relay  單路繼電器 .......................................................................................................98
                   3.5.3 Funduino - Water Sensor  水位偵測器 ................................................................................... 100
                   3.5.4 DC3~5V 之水泵(抽水馬達) .................................................................................................. 101
                   3.5.5  按鈕開關................................................................................................................................ 101
                   3.5.6 DHT 11  溫、濕感測器.......................................................................................................... 102
                   3.5.7 ESP8266 12F - Wifi 模組 ....................................................................................................... 105
              3.6 軟體架構............................................................................................................................................ 122
              3.7 伺服器架設........................................................................................................................................ 122
              3.8 系統程式............................................................................................................................................ 125
                   3.8.1 Arduino ................................................................................................................................... 127
                   3.8.2 Web ......................................................................................................................................... 142
                   3.8.3 App .......................................................................................................................................... 154
                   3.8.4 MySQL ................................................................................................................................... 157
              3.8 成果.................................................................................................................................................... 160
         CH 4  居家智能系統 ....................................................................................................................................... 161
              4.1 專案概述............................................................................................................................................ 161
              4.2 系統架構............................................................................................................................................ 161
              4.3 技術說明............................................................................................................................................ 162
              4.4 硬體接線............................................................................................................................................ 162
              4.5 元件介紹............................................................................................................................................ 164
                   4.5.1 SG90 Micro Servo 伺服馬達（servo motor） ...................................................................... 164
                   4.5.2 4×4 矩陣薄膜鍵盤 ................................................................................................................. 166
                   4.5.3 RFID-RC522 ........................................................................................................................... 170
                   4.5.4  電源模組................................................................................................................................ 175
              4.6 軟體架構............................................................................................................................................ 176
              4.7 系統程式............................................................................................................................................ 176
                   4.7.1 Arduino ................................................................................................................................... 176
                   4.7.2 Web ......................................................................................................................................... 191
                   4.7.3 App .......................................................................................................................................... 195
                   4.7.4 MySQL ................................................................................................................................... 196
              4.8 成果.................................................................................................................................................... 196
         CH 5  智慧循跡/藍芽自走車 .......................................................................................................................... 197
              5.1 專案概述............................................................................................................................................ 197
              5.2 系統架構............................................................................................................................................ 197
              5.3 技術說明............................................................................................................................................ 197
              5.4 硬體接線............................................................................................................................................ 198
              5.5 元件介紹............................................................................................................................................ 200
                   5.5.1 HC-06  藍芽通訊模組 ............................................................................................................ 200
                   5.5.2 MH-Sensor-serins ................................................................................................................... 203
                   5.5.3 直流馬達................................................................................................................................. 205
                   5.5.4 電池座..................................................................................................................................... 205
                   5.5.5 L298N 雙 H 橋模組 ............................................................................................................... 206

                                                              2]]></page><page Index="4"><![CDATA[5.5.6 HC-SR04  超音波感測器 ....................................................................................................... 210
              5.6 軟體架構............................................................................................................................................ 214
              5.7 系統程式............................................................................................................................................ 215
                   5.7.1 Ardunio ................................................................................................................................... 215
                   5.7.2 App 程式 ................................................................................................................................. 228
              5.8 成果.................................................................................................................................................... 234
         CH 6  熱像儀 ................................................................................................................................................... 235
              6.1 專案概述............................................................................................................................................ 235
              6.2 系統架構............................................................................................................................................ 235
              6.3 技術說明............................................................................................................................................ 235
              6.4 硬體接線............................................................................................................................................ 236
              6.5 元件介紹............................................................................................................................................ 238
                   6.5.1 Adafruit AMG8833 IR Thermal 影像模組 ............................................................................. 238
              6.6 系統程式............................................................................................................................................ 242
                   6.6.1 Ardunio / VGA ........................................................................................................................ 246
                   6.6.2 ESP8266 .................................................................................................................................. 251
                   6.6.3 Web 程式 ................................................................................................................................ 263
              6.7  成果................................................................................................................................................... 269




















































                                                              3]]></page><page Index="5"><![CDATA[圖目錄
                   圖 1.1 Arduino  商標 ............................................................................................................................1
                   圖 1.2 Arduino UNO  開發板外觀 .......................................................................................................3
                   圖 1.3 Arduino  官方網站的下載頁面 ................................................................................................5
                   圖 1.4 Arduino  版本下載 .....................................................................................................................5
                   圖 1.5 Arduino IDE  安裝 ......................................................................................................................6
                   圖 1.6 Arduino IDE  安裝選項 .............................................................................................................6
                   圖 1.7 Arduino IDE  安裝路徑 .............................................................................................................6
                   圖 1.8 Arduino IDE  安裝 .....................................................................................................................7
                   圖 1.9 Arduino IDE  安裝完成 .............................................................................................................7
                   圖 1.10 Arduino IDE  開發環境 ...........................................................................................................8
                   圖 1.11 Arduino IDE  環境介紹 ...........................................................................................................8
                   圖 1.12 Arduino IDE  圖示 .................................................................................................................10
                   圖 1.13 選擇開發板............................................................................................................................10
                   圖 1.14 選擇  Port ...............................................................................................................................11
                   圖 1.15 開啟  Blink  範例 ...................................................................................................................11
                   圖 1.16 Blink  編輯確認 .....................................................................................................................12
                   圖 1.17 Blink  上傳完成 .....................................................................................................................12
                   圖 1.18 電荷同性相斥，異性相吸....................................................................................................13
                   圖 1.19 串聯電流................................................................................................................................14
                   圖 1.20 並聯電流................................................................................................................................14
                   圖 1.21 水與電....................................................................................................................................14
                   圖 1.22 電位差....................................................................................................................................15
                   圖 1.23 電阻色碼................................................................................................................................16
                   圖 1.24 電阻-電阻值判斷 ..................................................................................................................17
                   圖 1.25 麵包板....................................................................................................................................18
                   圖 1.26 麵包板結構............................................................................................................................19
                   圖 1.27 麵包板串聯電路....................................................................................................................20
                   圖 1.28 麵包板並聯電路....................................................................................................................20
                   圖 1.29 市售一般三用電表................................................................................................................21
                   圖 1.30 電路示意................................................................................................................................22
                   圖 1.31 歐姆定律示意........................................................................................................................23
                   圖 1.32 串聯電路................................................................................................................................24
                   圖 1.33 並聯電路................................................................................................................................24
                   圖 1.34 串並聯....................................................................................................................................25
                   圖 1.35 克希荷夫電流定律................................................................................................................25
                   圖 1.36 克希荷夫電壓定律................................................................................................................26
                   圖 1.37 克希荷夫定律........................................................................................................................26
                   圖 2.1 Arduino  官方網站的  Language Reference ...........................................................................27
                   圖 2.2 if-else........................................................................................................................................40
                   圖 2.3 switch-case ...............................................................................................................................42
                   圖 2.4 for 迴圈 ....................................................................................................................................44
                   圖 2.5 while 迴圈 ................................................................................................................................44
                   圖 2.6 do-while 迴圈 ..........................................................................................................................45


                                                              4]]></page><page Index="6"><![CDATA[圖 2.7 Tone  接腳 ................................................................................................................................62
                   圖 2.8 Arduino  喇叭接線 ...................................................................................................................63
                   圖 2.9  連接兩塊 UNO .......................................................................................................................88
                   圖 3.1 系統架構..................................................................................................................................93
                   圖 3.2 智慧農場硬體接線..................................................................................................................94
                   圖 3.3 BOM 表電子零件組裝完成 ...................................................................................................95
                   圖 3.4 Arduino UNO ...........................................................................................................................96
                   圖 3.5 LCD1602..................................................................................................................................96
                   圖 3.6 DC-5V Relay ...........................................................................................................................98
                   圖 3.7 Relay 接線 ...............................................................................................................................99
                   圖 3.8 Funduino - Water Sensor ....................................................................................................... 100
                   圖 3.9 DC3~5V 之水泵(抽水馬達) ................................................................................................ 101
                   圖 3.10 按鈕開關............................................................................................................................. 101
                   圖 3.11 DHT11 溫、濕度感測器 .................................................................................................... 102
                   圖 3.12 DHT11 接線 ....................................................................................................................... 103
                   圖 3.13 DHT11 匯入 ....................................................................................................................... 103
                   圖 3.14 DHT 程式庫管理 ............................................................................................................... 104
                   圖 3.15 ESP8266 12F ...................................................................................................................... 105
                   圖 3.16 ESP8266 燒錄接線 ............................................................................................................. 106
                   圖 3.17 ESP8266 使用+監聽 .......................................................................................................... 106
                   圖 3.18 ESP8266 使用 ..................................................................................................................... 107
                   圖 3.19 ESP8266  燒錄工具開啟 .................................................................................................... 107
                   圖 3.20 ESP8266  燒錄工具使用 .................................................................................................... 108
                   圖 3.21 ESP8266  設定韌體選項 .................................................................................................... 108
                   圖 3.22 Arduino  與  ESP8266  接線 .............................................................................................. 109
                   圖 3.23 AT Command 測試 ............................................................................................................. 109
                   圖 3.24 智慧農場軟體流程............................................................................................................. 122
                   圖 3.25 Wampserver64 下載 ........................................................................................................... 123
                   圖 3.26 Wampserver64  安裝 .......................................................................................................... 123
                   圖 3.27 Wampserver64  安裝 .......................................................................................................... 123
                   圖 3.28 Wampserver64  安裝路徑 .................................................................................................. 123
                   圖 3.29 Wampserver64  路徑選擇 .................................................................................................. 123
                   圖 3.30 Wampserver64  安裝 .......................................................................................................... 123
                   圖 3.31 Wampserver64  安裝 .......................................................................................................... 123
                   圖 3.32 Wampserver64  開啟 .......................................................................................................... 124
                   圖 3.33 Wampserver64  啟動 .......................................................................................................... 124
                   圖 3.34 Wampserver64  測試 .......................................................................................................... 124
                   圖 3.35 智慧農場開場動畫............................................................................................................. 153
                   圖 3.36 智慧農場首頁..................................................................................................................... 153
                   圖 3.37 智慧農場變化曲線............................................................................................................. 154
                   圖 3.38 Thunkable  開發工具 ......................................................................................................... 154
                   圖 3.39 Thunkable Web Viewer ....................................................................................................... 155
                   圖 3.40 Thunkable Web Viewer  設定 ............................................................................................. 155
                   圖 3.41 Thunkable  輸出 iOS、Android 安裝檔 ............................................................................ 156


                                                              5]]></page><page Index="7"><![CDATA[圖 3.42 智慧農場 App 開場動畫、首頁 ........................................................................................ 156
                   圖 3.43 智慧農場 App 曲線 ............................................................................................................ 157
                   圖 3.44 phpMyAdmin  登入 ............................................................................................................ 157
                   圖 3.45 修改密碼............................................................................................................................. 158
                   圖 3.46 密碼輸入............................................................................................................................. 158
                   圖 3.47 新增資料庫......................................................................................................................... 159
                   圖 3.48 建立資料表......................................................................................................................... 159
                   圖 3.49 資料欄位結構..................................................................................................................... 160
                   圖 3.50 智慧農場資料庫結構......................................................................................................... 160
                   圖 3.51 智慧農場成果..................................................................................................................... 160
                   圖 4.1 居家智能系統架構............................................................................................................... 161
                   圖 4.2 智能居家硬體接線............................................................................................................... 162
                   圖 4.3 BOM 表電子零件組裝完成 ................................................................................................ 163
                   圖 4.4 SG90 Micro Servo 伺服馬達（servo motor） .................................................................... 164
                   圖 4.5 SG90 Micro Servo 接線 ....................................................................................................... 164
                   圖 4.6 4×4 矩陣薄膜鍵盤 ............................................................................................................... 166
                   圖 4.7 安裝 Keypad 程式庫 ............................................................................................................ 167
                   圖 4.8 RFID-RC522 ......................................................................................................................... 170
                   圖 4.9 MFRC522 接線 .................................................................................................................... 171
                   圖 4.10 MFRC522 函式庫安裝 ...................................................................................................... 171
                   圖 4.11 麵包版專用電源模組 ......................................................................................................... 175
                   圖 4.12 居家智能系統軟體架構..................................................................................................... 176
                   圖 4.13 居家智能系統開門紀錄網頁............................................................................................. 191
                   圖 4.14 居家智能系統 App ............................................................................................................. 195
                   圖 4.15 居家智能系統資料庫結構................................................................................................. 196
                   圖 4.16 居家智能系統成果展示..................................................................................................... 196
                   圖 5.1 智慧藍芽循跡自走車系統架構........................................................................................... 197
                   圖 5.2 智慧藍芽循跡自走車硬體接線........................................................................................... 198
                   圖 5.3 BOM 表組裝智慧藍芽循跡自走車 .................................................................................... 199
                   圖 5.4 HC - 06 .................................................................................................................................. 200
                   圖 5.5 紅外線感測器....................................................................................................................... 203
                   圖 5.6 紅外線感測器接線............................................................................................................... 204
                   圖 5.7 直流馬達............................................................................................................................... 205
                   圖 5.8 電池座................................................................................................................................... 205
                   圖 5.9 L298N ................................................................................................................................... 206
                   圖 5.10 L298N 接線 ........................................................................................................................ 207
                   圖 5.11 HC-SR04 ............................................................................................................................. 210
                   圖 5.12 HC-SR04 接線 .................................................................................................................... 211
                   圖 5.13 智慧循跡自走車軟體架構................................................................................................. 214
                   圖 5.14 智慧藍芽自走車軟體架構................................................................................................. 214
                   圖 5.15 MIT App Inventor  開發環境 ............................................................................................. 229
                   圖 5.16 App  元件清單 .................................................................................................................... 229
                   圖 5.17 App 程式設計 ..................................................................................................................... 230
                   圖 5.18 App 程式方塊 ..................................................................................................................... 230


                                                              6]]></page><page Index="8"><![CDATA[圖 5.19 智慧藍芽循跡自走車 App ................................................................................................. 233
                   圖 5.20 智慧藍芽循跡自走車 App ................................................................................................. 233
                   圖 5.21 智慧藍芽循跡自走車成果展示......................................................................................... 234
                   圖 6.1 熱像儀系統架構................................................................................................................... 235
                   圖 6.2 熱像儀 VGA 硬體接線 ........................................................................................................ 236
                   圖 6.3 熱像儀  ESP8266  接線 ........................................................................................................ 237
                   圖 6.4 AMG8833 ............................................................................................................................. 238
                   圖 6.5 VGA 與 Arduino UNO 連接 ................................................................................................ 245
                   圖 6.6 ESP8266 開發板選擇 ........................................................................................................... 251
                   圖 6.7 Google APPS Script ID ......................................................................................................... 257
                   圖 6.8  熱像儀成果.......................................................................................................................... 270

































































                                                              7]]></page><page Index="9"><![CDATA[表目錄
                   表 1.1 Arduino Uno 腳位介紹..............................................................................................................4
                   表 1.2 Arduino IDE  快捷選單 .............................................................................................................9
                   表 1.3 不同物料的電阻值..................................................................................................................16
                   表 1.4 電阻色碼..................................................................................................................................17
                   表 2.1 資料型態..................................................................................................................................35
                   表 2.2 常用基本資料型態..................................................................................................................35
                   表 2.3 運算子......................................................................................................................................40
                   表 2.4 比較 if  用法 ............................................................................................................................41
                   表 2.5 比較  for / while / do…while ...................................................................................................46
                   表 2.6 break / continue ........................................................................................................................47
                   表 2.7 算術運算..................................................................................................................................49
                   表 2.8 關係運算子..............................................................................................................................51
                   表 2.9 邏輯運算..................................................................................................................................51
                   表 2.10 複合運算子............................................................................................................................53
                   表 2.11 運算子優先順序 ....................................................................................................................53
                   表 2.12 Tone  頻率 ..............................................................................................................................57
                   表 2.13 Tone  音階頻率對照 ..............................................................................................................60
                   表 2.14 常用單位轉換表 ...................................................................................................................67
                   表 2.15 ATMega328  微控器六種睡眠模式 ......................................................................................79
                   表 2.16 Arduino  開發板外部插斷接腳對照.....................................................................................81
                   表 2.17 I2C / TWI pins .........................................................................................................................83
                   表 3.1  智慧農場開發環境.................................................................................................................94
                   表 3.2 智慧農場 BOM .......................................................................................................................95
                   表 4.1 智能居家系統開發環境....................................................................................................... 162
                   表 4.2 居家智能 BOM .................................................................................................................... 163
                   表 5.1 智能居家系統開發環境....................................................................................................... 198
                   表 5.2 智慧藍芽循跡自走車 BOM ................................................................................................ 199
                   表 5.3 HC-06 AT Command ............................................................................................................ 201
                   表 5.4 L298N 馬達控制 .................................................................................................................. 207
                   表 5.5 L298N 自走車控制 .............................................................................................................. 207
                   表 5.6 L298N 與  Arduino 腳位對應 .............................................................................................. 208
                   表 5.7 HC-SR04  與  Arduino  腳位對應 ....................................................................................... 211
                   表 5.8  紅外線循跡與 L298N 馬達控制 ........................................................................................ 215
                   表 6.1 智能居家系統開發環境....................................................................................................... 236
                   表 6.2 熱像儀 BOM ........................................................................................................................ 237
                   表 6.3 ESP8266 WiFi  函式庫的函式列表 ..................................................................................... 251














                                                              8]]></page><page Index="10"><![CDATA[CH 1  Arduino 介紹



              Arduino 這個名字來自義大利伊夫雷亞(Ivrea)的一家酒吧，該專案的創始人馬西莫·班齊（Massimo
         Banzi）、大衛·奎提耶斯（David Cuartielles）、湯姆·伊果（Tom Igor）、贊布羅塔·馬提諾（Gianluca Martino）、
         大衛·梅利斯（David Mellis）和尼可拉斯·蘭比提（Nicholas Zambetti）過去常常會去這家酒吧。酒吧以
         伊夫雷亞的 Arduin（Arduin of Ivrea）命名，此名稱也是伊夫雷亞邊疆伯爵，也是 1002 年至 1014 年期
         間的義大利國王。Arduino 專案始於 2003 年，作為義大利伊夫雷亞地區伊夫雷亞互動設計研究所的學
         生專案，目的是為新手和專業人員提供一種低成本且簡單的方法，以建立使用感測器與環境相互作用
         的裝置執行器。適用於初學者愛好者的此類裝置的常見範例包括簡單機器人、恆溫器和運動檢測器。
         Arduino  設計的觀點，就是希望針對『不懂電腦語言的族群』，也能用  Arduino  做出很酷的東西，並且
         Arduino 允許任何人製造 Arduino 基板和軟體，此外 Arduino 板可以預裝的形式進行商業銷售，也可作
         為 DIY 套件販售與購買。


































                                                      圖 1.1 Arduino  商標

              目前 Arduino 已被註冊成了商標『Arduino®』，如圖 1.1 所示。若想用這個名字賣電路板，那須付
         一點商標費用給  『Arduino®』。而 Arduino 也是一家製作開源硬體和開源軟體的公司，同時兼有專案
         和使用者社群，該公司負責設計和製造單板微控制器和微控制器套件，用於構建數位裝置和互動式物
         件，以便在物理和數位世界中感知和控制物件。『Arduino®』，是一個開放原始碼的單晶片控制器，它
         使用了  Atmel AVR  單晶片  (Atmel_Corporation, 2013)，採用了基於開放原始碼的軟硬體平台，構建於
         開放原始碼  Simple I/O  介面版，並且具有使用類似  Java，C  語言的開發環境。

              在 Arduino 上執行的程式可以使用任何能夠被編譯成 Arduino 機器碼的程式語言編寫。而 Atmel 也
         提供了數個可以開發 Atmel 微處理機程式的整合開發環境，AVR Studio 和更新的 Atmel Studio。目前微
         軟在其 Visual Studio  也有提供 Arduino  的  SDK，在編譯執行上更方便。而 Arduino 計劃也提供了
         Arduino Software IDE，一套以 Java 編寫的跨平台應用軟體。Arduino Software IDE 源自於 Processing 程
         式語言以及 Wiring 計劃的整合開發環境。它是被設計於介紹程式編寫給藝術家和不熟悉程式設計的人

                                                              1]]></page><page Index="11"><![CDATA[們，且包含了一個擁有語法突顯、括號匹配、自動縮排和一鍵編譯並將執行檔燒寫入 Arduino 硬體中的
         編輯器。

              Arduino Software IDE 使用與 C 語言和 C++相仿的程式語言，並且提供了包含常見的輸入/輸出函
         式的 Wiring 軟體函式庫。在使用 GNU toolchain 編譯和連結後，Arduino Software IDE 提供了一個程式
         「avrdude」用來轉換可執行檔成為能夠燒寫入 Arduino 硬體的韌體。此外，使用 Arduino Software IDE
         編寫的程式被稱為「sketch」。 Arduino  有許多版本，如快閃記憶體空間較大的  Mega/Mega2560  或是能
         夠連網的  Yún 以及本書所選擇較適合初學者入門的  Uno/Uno R3，故本書將以  Uno  為範例，做詳細的
         硬體介紹。

         1.1 Arduino  硬體-UNO


              Appsduino UNO  控制板，如圖 1.2 所示，是台灣艾思迪諾股份有限公司發展出來的產品，主要是
         為了簡化  Arduino UNO  與其它常用的周邊、感測器發展出來的產品，本身完全相容於  Arduino UNO
         開發版。UNO  的處理器核心是  ATmega328P，使用  ATMega 8U2  來當作  USB-對序列通訊，並多了一
         組 ICSP  給 MEGA8U2  使用：未來使用者可以自行撰寫內部的程式~  也因為捨棄  FTDI USB  晶片~
         Arduino  開發板需要多一顆穩壓 IC  來提供  3.3V  的電源。

              Arduino UNO  是  Arduino USB  介面系列的最新版本，作為  Arduino  平臺的參考標準範本：同時
         具有 14  個數位輸入/輸出接腳（其中  6  個可用作  PWM  輸出），6  個類比輸入、16 MHz  石英晶體、
         USB 連接埠、電源插孔、ICSP  接頭和重置按鈕，可參照圖 1 所示之相關位置。Arduino Uno  板可通過
         USB  連接或外部電源供電。外部（非  USB）電源可以使用電源供應器、9V  電池，通過將  2.1mm  插
         頭插入電路板的電源插孔供電。注意如果供電電壓低於  7V， 則   5V  輸出腳位可能電壓不足，電路板可
         能會變得不穩定。如果使用  12V  以上，電壓調節器可能會過熱並損壞電路板。

         系統規格
                       ⚫  控制器核心：ATmega328

                       ⚫  控制電壓：5V
                       ⚫  建議輸入電(recommended)：7-12 V
                       ⚫  最大輸入電壓  (limits)：6-20 V
                       ⚫  數  位  I/O Pins：14 (of which 6 provide PWM output)
                       ⚫  類比輸入  Pins：6  組
                       ⚫  DC Current per I/O Pin：40 mA
                       ⚫  DC Current for 3.3V Pin：50 mA
                       ⚫  Flash Memory：32 KB (of which 0.5 KB used by bootloader)

                       ⚫  SRAM：2 KB
                       ⚫  EEPROM：1 KB
                       ⚫  Clock Speed：16 MHz














                                                              2]]></page><page Index="12"><![CDATA[圖 1.2 Arduino UNO  開發板外觀

         電源腳位
              開發板上有個標示為  ON  的  LED，用來指示電源供應狀況，如果已提供電源的情況下，發現標示
         為  ON  的  LED  閃爍、黯淡或熄滅，應儘快拔除電源，檢查電源供應是否正常，以避免損壞控制板。
         Arduino Uno  上與電源有關的接腳列於表 1.1。

         類比輸入腳位
              A0  至  A5（A  代表  Analog）可用來接受類比電壓輸入，但不能輸出類比電壓。每隻腳預設會將
         0V  到  5V  轉換為  0  至  1023  的數值。對於輸出電壓為其他範圍的電路模組，可以透過  AREF  腳與函
         式  analogReference()，來提供參考電壓。A0 至  A5  也可作為數位輸出、輸入腳位使用，此時  A0  至  A5
         分別可視為  D14  至  D19。

         數位輸出、輸入腳位
              D0  到  D13（D  代表  Digital）可輸出高電位  5V  與低電位  0V  的數位訊號，也可接受數位訊號。

         其他腳位功能
              除了數位  I/O  與類比輸入，Arduino Uno  還有提供其他功能，詳細描述於表 1.1。












                                                              3]]></page><page Index="13"><![CDATA[表 1.1 Arduino Uno 腳位介紹
                      腳位名稱         功能                        介紹
                      VIN          外部電源輸入                    電路板在使用外部電源時的輸入電壓，可
                                                             以通過此腳位提供電壓。
                      5V           電源輸出                      從電路板上的穩壓器輸出  5V  穩壓電壓。
                      3V3          電源輸出                      由穩壓器產生的  3.3V  電源。最大電流消
                                                             耗為  50 mA。
                      GND          接地                        接地。
                      IOREF        輸出入埠電壓參考                  讓其他設備知道  Arduino  控制板的運作
                                                             電壓。
                      D0(RX)       Serial    通訊              用來接收(RX)與傳輸(TX) TTL  訊號的
                      D1(TX)                                 序列資料，連接到  USB  序列埠，因此如果

                                                             電腦使用  USB  與控制板傳輸數據（控制板
                                                             上標示為  RX、TX  的  LED  閃爍），則應避
                                                             免使用此腳位。
                      D2、D3        外部中斷                       這兩支腳可以利用外部事件觸發中斷。
                                                              詳細內容請參考  attachInterrupt()函式。
                      D3           PWM                       可看見這些腳位旁有波浪符號（~）。透過
                      D4                                     analogWrite()函式用數位訊號來模擬類比
                      D5                                     訊 號 輸 出 ， 提 供           8-bit    的       PWM
                      D6                                     （  PulseWidth Modulation）。
                      D9
                      D10
                      D 11
                      D10 (SS)     SPI                       這四支腳搭配  SPI  Library  可提供  SPI
                      D11(MOSI)                              序列通訊。
                      D12(MISO)
                      D13 (SCK)
                      D13          LED                       若是原廠控制板，預設會燒錄一個令  D13
                                                             定時切換高低電位的  Blink  程式，因此，
                                                             首次接上電源時，會看到開發板上標示為
                                                             L 的  LED  不斷閃爍，這是初步檢視控制
                                                             板是否功能正常的方式。
                      A4 (SDA)     I2C                       透過  Wire library  可以提供  I2C  通訊。
                      A5 (SCL)
                      AREF         AREF                      類 比 輸 入 的 參 考 電 壓 ， 搭 配
                                                             analogReference()函式一起使用。
                      Reset        Reset                     按下重置鈕會使開發板重新執行使用者
                                                             寫入之程式。當  Reset    腳位    LOW  時 ，
                                                             功能如同按下重置鈕。









                                                              4]]></page><page Index="14"><![CDATA[1.2 Arduino 安裝與開發環境



              Arduino 開發環境是使用 C 和 C ++的函數編寫的跨平台應用程序。它用於編寫程序並將其上載到
         Arduino 兼容的開發板，而且還可以藉助第三方內核和其他供應商開發板。IDE 的源代碼是在 GNU 通
         用公共許可第 2 版下發布的。Arduino IDE 使用特殊的代碼結構規則支持 C 和 C ++語言。

         1.2.1 Arduino  開發  IDE  安裝


              Arduino IDE  放在  Arduino  的官方網站（http://arduino.cc/），連上該網站後可以在網站上方看到一
         排 選 單 ， 點 選   SOFTWARE  -  >  DOWNLOAD  即 可 進 入   Arduino  的                                     下   載  頁
         （http://arduino.cc/en/Main/Software）。如圖 2 所示，目前  Arduino  版本為  1.8.13，Arduino  版本會隨時
         間而更新，目前只要安裝  1.8.x  版本以上即可。Arduino IDE  提供了不同版本讓不同作業系統開發者都
         可使用，請根據自己的作業系統點選不同選項。

                        Step1.  進入到  Arduino  官方網站的下載頁面，如圖 1.3 所示。
                        (http://arduino.cc/en/Main/Software)
























                                               圖 1.3 Arduino  官方網站的下載頁面


                        Step2. Arduino  的開發環境，有  Windows、Mac OS X、Linux  版本，如圖1.4
                   所示。本範例以   Windows  版本作為範例，請點選頁面右方「Windows」                                      下  載
                   Windows  對應版本的開發環境。



















                                            圖1.4 Arduino  版本下載

                                                              5]]></page><page Index="15"><![CDATA[Step3.  下載完的檔名為「arduino-1.8.13-windows.exe」，將檔案點擊兩下執行，
                   出現如圖1.5所示畫面。

















                                             圖1.5 Arduino IDE  安裝

                        Step4.  點選「I Agree」後出現如圖 1.6 所示畫面。






















                                                圖 1.6 Arduino IDE  安裝選項


                        Step5.  點選「Next>」後出現如圖 1.7 所示畫面。
























                                                圖 1.7 Arduino IDE  安裝路徑




                                                              6]]></page><page Index="16"><![CDATA[Step6.  選擇檔案儲存位置後，點選「Install」進行安裝，出現如圖1.8所示畫面。





















                                                  圖 1.8 Arduino IDE  安裝


                        Step7.  安裝完成後，出現如圖 1.9 所示畫面，點選「Close」。





















                                                圖 1.9 Arduino IDE  安裝完成

                        備註:  安裝到一半時，若出現詢問是否要安裝  Arduino USB Driver (Arduino LLC)  的畫
                   面，請點選「安裝(I)」。  安裝系統就會安裝  Arduino USB  驅動程式。





                        Step8.  桌布上會出現                     的圖示 ， 您可以點選該圖示執行  Arduino Sketch程式。



















                                                              7]]></page><page Index="17"><![CDATA[圖 1.10 Arduino IDE  開發環境

                           Step9.  您會進入到如圖 1.10 所示，Arduino  的軟體開發環境介面。



         1.2.2 Arduino  開發環境介紹


              Arduino IDE  所用的程式語言語法類似於  C/C++，具備文字編輯介面、常用工具欄、圖形化控制介
         面及一鍵編譯並將程式燒寫入  Arduino    硬體中。而使用 Arduino IDE  編寫的程式被稱為  Sketch，一
         個典型的  Arduino C/C++ sketch  程式會包含兩個函式：setup()及  loop()，如圖  1.11 所示，它們會在編
         譯後合成為  main()函式。

























                                               圖 1.11 Arduino IDE  環境介紹

         setup()：在程式執行開始時會執行一次，用於初始化設定。
         loop()：直到  Arduino  硬體關閉前會重複執行的程式碼。


                                                              8]]></page><page Index="18"><![CDATA[函式庫所提供功能。在  TOOL  下則有硬體開發板及序列埠的設定，至於  FILE  下，則可以找到不
         少範例程式，易於讓初學者了解  Arduino IDE  與硬體間的關係，並快速上手。

              快捷選單由左而右有五個按鈕，提供開發者快速操件，分別代表  VERIFY/ COMPILE (程式編繹及
         驗證)、UPLOAD I/O BOARD (上傳程式到硬體開發板)、NEW (新增檔案)、OPEN (開啟舊檔)、以及
         SAVE (儲存專案)，最右邊還有一個按鈕，是  SERIAL MONITOR (監視串列埠)，開發著可用來監看專
         案程式運行過程，詳細說明列於表 1.2.1。而程式編輯區塊供使用者輸入欲執行程式，系統消息區則簡
         單回報目前程式狀況，完整的執行狀況紀錄於編輯狀態顯示區，更可藉由此介面監視  Arduino I/O  數
         值。

                                                表 1.2 Arduino IDE  快捷選單
                                                  英文                   中文                  功能
                           Icon圖示
                                                                                    檢查參數設定或
                                                                進行編譯，驗證程
                                           verify/compile       式是否正常運作。            引入程式是否產
                                                                                    生錯誤。
                                                                                    程式進行編譯，將
                                                                進行上傳，從電腦            程式碼透過  USB
                                           Upload               把 程 式 上 傳 到         介 面 燒 錄 至
                                                                Arduino  板子裡。
                                                                                    Arduino  控制板。

                                           New                  新增檔案                產生新的  Sketch

                                                                開啟檔案，可開啟            開啟腳本，顯示在

                                           Open                 內建的程式檔或             同一頁面上。
                                                                其他檔案。

                                           Save                 儲存檔案                Sketch  儲存。


                                                                                    開啟監視器頁面，
                                           Serial monitor       序列埠監控視窗             監視  Arduino  I/O

                                                                                    介面。

         1.2.3 Arduino Uno  第一支程式


              本節目的為熟悉  Arduino  IDE  的操作，以範例程式  blink  示範如何操控  Arduino  Uno  板上的
         LED  燈閃爍，大多數  Arduinos  都有一個可以控制的板載  LED。  在 UNO、MEGA  和  ZERO  上連接
         到  D13  腳位，MKR1000  則是  D6  腳位。Arduino  內部的常數（constants）LED_BUILTIN  為正確的
         LED  引腳，與使用的板無關。
              本節會詳細的說明程式的開啟、驗證與上傳，操作完本實驗將學會如何利用  Arduino IDE  寫入程
         式至  Arduino Uno，並且對於  Arduino IDE  各項功能更為了解。將  Arduino Uno    開發板透過  USB    傳
         輸線連接個人電腦，Type B USB    連接 Arduino Uno  開發板，而另一頭是  Type A USB  連接個人電腦，
         這可以提供  5V、500mA  的電源給控制板，電腦也可以透過  USB  傳送程式給  Arduino。






                                                              9]]></page><page Index="19"><![CDATA[範例程式  - blink
              Step 1 在個人電腦中，如圖 1.12 所示，打開  Arduino IDE。















                                                 圖 1.12 Arduino IDE  圖示

              Step 2 選擇開發板。在  Arduino IDE  點選工具（TOOL）->開發板（BOARD）->ARDUINO/GENUINO
         UNO，如圖  1.13  所示。


































                                                     圖 1.13 選擇開發板

              Step 3 選擇  Port。在  Arduino IDE  點選工具（TOOL）->序列埠（PORT）->COMX(ARDUINO/
         GENUINO UNO)，請務必確認此步驟選擇後是否有打勾，如圖  1.14。


















                                                              10]]></page><page Index="20"><![CDATA[圖 1.14 選擇  Port

              Step 4 開啟檔案。在    Arduino    系統選單上，點選檔案（FILE）->  範例（EXAMPLES）-> BASICS-
         > BLINK（延伸檔名*.INO），即開啟範例程式  blink，如圖  1.15。






































                                                  圖 1.15 開啟  Blink  範例


                                                              11]]></page><page Index="21"><![CDATA[Step 5 驗證/編譯。程式碼出現後，點選左上驗證（VERIFY），查驗程式碼是否正確。若無錯誤，
         下方會顯示編輯完成，如圖  1.16  所示。

































                                                   圖 1.16 Blink  編輯確認

              Step 6 寫入。編譯無誤即可將程式編譯碼燒錄至  Uno  開發板，點選左上上傳（UPLOAD），如圖
         1.17  所示，CONSOLE  寫上傳完畢，表示上傳成功。






























                                                   圖 1.17 Blink  上傳完成

              Step 5  及  Step 6  若失敗請先檢查圖  1.13  及圖  1.14  中確認板子型號與通訊埠選擇是否無誤，若
         無誤則檢查  USB  傳輸線是否異常，以上檢查都無誤的話，請換一塊板子再試一次。


                                                              12]]></page><page Index="22"><![CDATA[1.3  基本電學


              基本電學（Basic Electricity），是電學（電力學、電子學、電路學等）的基礎學科。在開始正式使
         用 Arduino 前，本章節將介紹基本的電子學、電路學原理等相關知識。

         1.3.1 電荷

              電是一顆一顆的，分為正電與負電，帶電的粒子稱為電荷，在國際單位制裡單位為庫倫( C )，符號
         為 Q，電池上的毫安小時(mAH)為顯示電荷容量。在電磁學裡，電荷（英語：electric charge）是物質的
         一種物理性質。稱帶有電荷的物質為「帶電物質」。兩個帶電物質之間會互相施加作用力於對方，也會
         感受到對方施加的作用力，所涉及的作用力遵守庫侖定律。電荷分為兩種，「正電荷」與「負電荷」。帶
         有正電荷的物質稱為「帶正電」；帶有負電荷的物質稱為「帶負電」。假若兩個物質都帶有正電或都帶有
         負電，則稱這兩個物質「同電性」，否則稱這兩個物質「異電性」。兩個同電性物質會相互感受到對方施
         加的排斥力；兩個異電性物質會相互感受到對方施加的吸引力，如圖 1.18 所示。














                                             圖 1.18 電荷同性相斥，異性相吸

              電荷是許多次原子粒子所擁有的一種基本守恆性質。稱帶有電荷的粒子為「帶電粒子」。電荷決定
         了帶電粒子在電磁方面的物理行為。靜止的帶電粒子會產生電場，移動中的帶電粒子會產生電磁場，
         帶電粒子也會被電磁場所影響。一個帶電粒子與電磁場之間的交互作用稱為電磁力或電磁交互作用。
         這是四種基本交互作用中的一種。

         1.3.2 電流

              電流的定義：代表正電荷在導線中的流動，由高電位流向低電位，亦即由電池的正極經外電路再流
         回電池的負極。
              電子流：在導體中負電荷的流動，事實上在導線中流動的是【電子流】即負電荷，而【電流】是電
         子流的反方向。故電流就是  1  秒通過幾 C 的電荷，單位是  A (安培)，符號為  I。電流的大小與導線的
         電阻及電路中的電位差有關，電流與電阻成反比，與電位差成正比，三者的關係式為：

                              
                       
         電流  :     =      =   (V 為電壓、R 為電阻)
                              

              綜上述公式可知，當 2 秒鐘移動 10C 的電荷，電流將會是 I= Q/t = 10 / 2 A = 5 A。又如圖 1.19 所
         示 ， 當電流通過電器時，消耗的只是「電位能」，電量不會減少。因此當燈泡進行串聯時，電流為 I1=I2=I3。











                                                              13]]></page><page Index="23"><![CDATA[圖 1.19 串聯電流

              當電器以並聯方式連接於電路中時，則線路中各並聯電器的電壓是相等的，而電路中各分支電流
         的和等於總電流，如圖 1.20 所示，電流為 I3=I1+I2=I4。

















                                                      圖 1.20 並聯電流

              並聯電器可以降低電路中的總電阻，所以並聯的電器愈多，則總電流會愈大，而電路所能承受的電
         流有一最大值，若電流過大時有可能會使電路因發熱而燒毀（俗稱：電線走火）。

         1.3.3 電壓

              電壓，也稱作電位、電位差、電動勢、電勢差、  端電壓、電壓降，是衡量單位電荷在靜電場中由
         於電位不同所產生的能量差的物理量，此概念與水位高低所造成的「水壓」相似，如圖 1.21 所示。需
         要指出的是，「電動勢」和「電位差」一詞一般只用於電路當中，「電壓」則普遍應用於一切電現象當中。
         電壓的國際單位是伏特(volt，V)，符號為  V。依電壓對時間的變化，可分直流電壓及交流電壓:
         直流電壓，電壓值及極性不隨時間而改變，如電池。
         交流電壓，電壓值及極性會隨時間而改變，如家用 110V 電源。













                                                       圖 1.21 水與電

              電壓是推動電荷定向移動形成電流的原因。電流之所以能夠在導線中流動，也是因為在電流中有
         著高電勢和低電勢之間的差別。這種差別叫電勢差，也叫電壓，如圖 1.22 所示在電路中，任意兩點之
         間的電位差稱為這兩點的電壓。


                                                              14]]></page><page Index="24"><![CDATA[圖 1.22 電位差

         1.3.4 電阻

              電能、電功率、電流及電壓等，皆是最重要的電之數量，除此之外，電阻也  不可忽視。一個電路
         或一套裝備，其本身的特性，諸如尺寸、形狀與材質等，會  影響其電流量。某些會阻礙電流的效應，
         可稱之為電阻（resistance）。   在物質中，電荷流動可能會遭遇到類似機械的摩擦力般的阻力。這種阻力
         是  起因於電子與晶格原子或雜質原子之間的碰撞，這種情況會使電能轉換成熱能。  任何電路或裝置，
         常因發熱而消耗電功率。電阻發熱而消耗電功率，並非一無是處，需視其是否有用而定。有些電路就是
         利用電阻的特性來作功的，例如我們可利用電熱器取得熱能。電阻可用來限制電流量，也可用來調整
         電壓。還有其他的一些功能，專門製造用來作這些工作的器具稱為電阻器（resistor）。

         電阻的定義
              一電路欲阻止電流通過，同時使電能轉換為熱能之性質，謂之電阻。單位為歐姆（ohm)或簡稱歐，
         以希臘字母  Ω（omega），符號為  R 表示。其公式為:

                
            =   ，即 1  歐姆  = 1 伏特  / 1 安培
                




                                                              15]]></page><page Index="25"><![CDATA[導體內部有大量的自由電子，當電壓施於導體的兩端時，會導致電流的產生，但此一電流不可能無
         限制的增加，此乃因為當電荷流經某一材料時，必承受其電阻，此種阻力被消耗轉變成為熱能了。電
         阻：通過導線上任意截面的電流為 1 安培時，導線兩端所須施加的電壓即為該導線的電阻。金屬中以
         銀的電阻最小，銅的電阻次之如表所示。電阻的大小會受到溫度的影響，一般而言，溫度愈高則電阻愈
         大，此外電子在不同材料中流動會遇到不同的阻力。電阻最大功用為限制電路之中電流之流量，電阻
         並無正負極之分。電子電路中用的最多的為碳質電阻，因為其表面積太小，無法直接列印電阻值，而以
         色碼表示之，如圖 1.23 所示，故又稱色碼電阻，其阻值可參照表 1.3 與表 1.4，另外尚有可變電阻，可
         以輕鬆調整電阻值。

                                                    表 1.3 不同物料的電阻值




























































                                                      圖 1.23 電阻色碼
                                             資料來源  : https://reurl.cc/ldNQyd


                                                              16]]></page><page Index="26"><![CDATA[表 1.4 電阻色碼
           顏色                第一環                第二環               第三環                第四環

           涵義                十位數                個位數               乘冪                 誤差

                                                                     0
           黑                 0                  0                 10
                                                                     1
           棕                 1                  1                 10                 1%
                                                                     2
           紅                 2                  2                 10                 2%

                                                                     3
           橙                 3                  3                 10

                                                                     4
           黃                 4                  4                 10

                                                                     5
           綠                 5                  5                 10

                                                                     6
           藍                 6                  6                 10

                                                                     7
           紫                 7                  7                 10

                                                                     8
           灰                 8                  8                 10

                                                                     9
           白                 9                  9                 10

                                                                     -1
           金                                                      10                 5%

                                                                     -2
           銀                                                      10                 10%
































                                                  圖 1.24 電阻-電阻值判斷

              如圖 1.24 所示，第一環為紅色，對應色碼表為十位數 2。第二環為紅色，對應色碼表為個位數 2。
                                                 1
         第三環為棕色，對應色碼表為乘冪 10 。第四環為金色，對應色碼表為誤差 5%。因此，電阻紅紅棕金
         為 220Ω  5%。(電阻色碼計算器:  https://www.digikey.tw/zh/resources/conversion-calculators/conversion-
         calculator-resistor-color-code)


                                                              17]]></page><page Index="27"><![CDATA[電功與能量守恆
              詹姆斯·普雷斯科特·焦耳，FPS，ForMemRS，HonFRS（英語：James Prescott Joule，1818 年 12 月
         24 日－1889 年 10 月 12 日），英國物理學家。在研究熱的本質時，發現了熱和功之間的轉換關係，並
         由此得到了能量守恆定律，並在最終推導出熱力學第一定律。而國際單位制導出單位中，能量的單位
         之一焦耳，就是以他的名字命名。他和開爾文合作發展了溫度的絕對尺度。他還觀測過磁致伸縮效應，
         借而發現了導體電阻、通過導體電流及其產生熱能之間的關係，也就是常稱的焦耳定律。
              焦耳定律是他的第一篇重要的論文於  1840  年被送到英國皇家學會，當中指出電導體所發出的熱
         量與電流強度、導體電阻和通電時間的關係，此即焦耳定律。1849  年焦耳提出能量守恆與轉化定律：
         能量既不會憑空消失，也不會憑空產生，它只能從一種形式轉化成另一種形式，或者從一個物體轉移
         到另一個物體，而能的總量保持不變，奠定了熱力學第一定律(能量不滅原理)之基礎。
         因此透過焦耳定律可以導出電功之定義為：當電流通過電器時會對電器作功，電器則將電能以其他形
         式的能量輸出；例如轉換為熱能，而電能 E 所作的功，其關係式為：

         E＝Q×V（Q 為電量、V 為電壓）

         功率的單位為瓦特(W)，符號為 P，功率是指作功的比率。
         電學定義為:單位時間內所消耗的電能。

         電功率：電能作功的速率，亦即單位時間內電能所作的功。若以符號表示；P 代表電功率，E 代表電能，
         t 代表電能作功經歷的時間。則關係式為:







         (1)瓦特＝焦耳／秒；  1w＝1 J／s
         (2)千瓦(kw)：1  千瓦＝1000  瓦  (1kw＝1000w)
         (3)生活中很多電器用品都會標示功率的大小。  例如一盞標示  60  瓦特的燈泡，正常使用時，每秒鐘會
         消耗電能  60  焦耳
         (4)電學上的仟瓦小時(1  度)相當於  1000  瓦特  x3600  秒＝3.6x106 焦耳

         1.3.5 麵包板使用

              當學習怎樣去建立一個電路時，如圖 1.25 所示，麵包板是最基本、最簡單的元件之一。由於板子
         上，如圖 1.26 所示有很多小插孔，各種電子元器件可根據需要任意插入或拔出，免去了焊接的工序，
         節省了電路的組裝時間，且元件可以重複使用，非常適合電子電路的組裝、調試和訓練。














                                                       圖 1.25 麵包板





                                                              18]]></page><page Index="28"><![CDATA[圖 1.26 麵包板結構

         使用及注意事項
         1.  安裝分立元件時，應便於看到其極性和標誌，將元件引腳理直後，在需要的地方折彎。為了防止裸
         露的引線短路，必須使用帶套管的導線，一般不剪斷元件引腳，以便於重複使用。一般不要插入引腳直
         徑大於 0.8mm 的元器件，以免破壞插座內部接觸片的彈性。

         2.  對多次使用過的集成電路的引腳，必須修理整齊，引腳不能彎曲，所有的引腳應稍向外偏，這樣能
         使引角與插孔可靠接觸。要根據電路圖確定元器件在麵包板上的排列方式，目的是走線方便。為了能
         夠正確布線並便於查線，所有集成電路的插入方向要保持一致，不能為了臨時走線方便或縮短導線長
         度而把集成電路倒插。

         3.  根據信號流程的順序，採用邊安裝邊調試的方法。元器件安裝之後，先連接電源線和地線。為了查
         線方便，連線儘量採用不同顏色。例如：正電源一般採用紅色絕緣皮導線麵包板的使用負電源用藍色，
         地線用黑線，信號線用黃色，也可根據條件選用其它顏色。

         4.  麵包板宜使用直徑為 0.6mm 左右的單股導線。根據導線的距離以及插孔的長度剪斷導線，要求線頭
         剪成 45º斜口，線頭剝離長度約為 6mm 左右，要求全部插入底板以保證接觸良好。裸線不宜露在外面，
         防止與其它導線斷路。

         5.  連線要求緊貼在麵包板上，以免碰撞彈出麵包板，造成接觸不良。必須使連線在集成電路周圍通過，
         不允許跨接在集成電路上，也不得使導線互相重疊在一起，儘量做到橫平豎直，這樣有利於查線，更換
         元器件及連線。

         6、最好在各電源的輸入端和地之間並聯一個容量為幾十微法的電容，這樣可以減少瞬變過程中電流的
         影響。為了更好地抑制電源中的高頻分量，應該在該電容兩端再並聯一個高頻去耦電容，一般取 0.01 ~
         0.047μf 的獨石電容。

         7.  在布線過程中，要求把各元器件放置在麵包板上的相應位置以及所用的引腳號標在電路圖上，保證
         調試和查找故障的順利進行。



                                                              19]]></page><page Index="29"><![CDATA[8.  所有的地線必須連接在一起，形成一個公共參考點。

         布線原則
         1.  儘量減少連接點。增加一個連接點，相當於人為地增加了故障機率。

         2.  儘量避免立交橋。所謂的「立交橋」就是元器件或者導線騎跨在別的元器件或者導線上。初學者最
         容易犯這樣的錯誤。這樣做，一方面給後期更換元器件帶來麻煩，另一方面，在出現故障時，零亂的導
         線很容易使人失去信心。

         3.  儘量牢靠。有兩種現象需要注意：第一、集成電路很容易鬆動，因此，對於運放等集成電路，需要
         用力下壓，一旦不牢靠，需要更換位置。第二、有些元器件管腳太細，要注意輕輕撥動一下，如果發現
         不牢靠，需要更換位置。

         4.  方便測試。5 孔孤島一般不要占滿，至少留出一個孔，用於測試。

         5.  布局儘量緊湊，信號流向儘量合理。

         6.  布局儘量與原理圖近似。這樣有助於同學們在查找故障時，儘快找到元器件位置。

         7.  電源區使用儘量清晰。在搭接電路之前，首先將電源區劃分成正電源、地、負電源 3 個區域，並用
         導線完成連接。

         保護
         1、儘量避免進水、碎屑以及粉狀物進入插孔。
         2、避免集成電路的粗暴插拔，以免管腳折在插孔內；不要將金屬線折斷在插孔內。
         3、不要將太粗的導線、探針、管腳插入孔內。

                         麵包板使用-串聯電路                                           麵包板使用-並聯電路

































                        圖 1.27 麵包板串聯電路                                       圖 1.28 麵包板並聯電路

                                                              20]]></page><page Index="30"><![CDATA[1.3.6 三用電表

              只要是從事電子領域工作的人，都不能缺少三用電表這項工具，如圖 1.29 所示。三用電表能測量
         電壓、電流、電阻、溫度和更多數值  (視實際購買的電表而定)。這種工具多功能合一，能實現故障排
         除、電路建構以及測試用途。

























                                                 圖 1.29 市售一般三用電表

         直流電壓測試  DCV
             •  1  直流電壓測試  DCV 1  將紅色測試棒插入“V/Ω＂插座，黑色測試棒插入“COM＂插座。
             •  2  旋轉開關轉至  DCV  區域。（若不知道待測電壓的約略值，則轉至最高檔，再依實際測量值
                 轉至最佳解析度  為止，最大電壓勿超過  DC 1000V。）
             •  3  將測試棒與待測線路並聯。
             •  4  從液晶顯示器讀取待測電壓值。
         交流電壓測試  ACV
             •  1  將紅色測試棒插入“V/Ω＂插座，黑色測試棒插入“COM＂插座。
             •  2  旋轉開關轉至  ACV  區域。（最大電壓勿超過  AC 750Vrms。）
             •  3  將測試棒與待測線路並聯。
             •  4  從液晶顯示器讀取待測電壓值。
         直流電流測試  DCA
             •  1  將紅色測試棒插入“mA＂插座（大於  200mA  則插入  10A  插座），黑色測試棒插入“COM
                 ＂插座。
             •  2  旋轉開關轉至  DCA  區域。（若不知道待測電流的約略值，則轉至最高檔，再依實際測量值
                 轉至最佳解析度  為止）
             •  3  將測試棒與待測線路串連。
             •  4  從液晶顯示器讀取待測電流值。
         電阻測試  OHM
             •  1  將紅色測試棒插入“V/Ω＂插座，黑色測試棒插入“COM＂插座。
             •  2  旋轉開關轉至  OHM（Ω）區域。（若不知道待測電組的約略值，則轉至最高檔，再依實際測
                 量值轉至最佳  解析度為止）
             •  3  將測試棒接到待測電阻上。
             •  4  從液晶顯示器讀取待測電阻值。



                                                              21]]></page><page Index="31"><![CDATA[1.3.7 電路

              電子迴路（英語：Electrical network），是由電氣裝置和元件，按一定方式連接起來，為電荷流通提
         供了路徑的總體，也叫電子線路或稱電氣迴路，簡稱電路、網路或迴路。由電源、負載和中間環節三個
         基本部分組成，如圖 1.30 所示，電源是產生電能的裝置；負載是取用電能轉化為機械能、光能、熱能
         等的裝置；變壓器和輸電線是連接電源和負載的中間環節，起傳輸和分配電能的作用。如電源、電阻、
         電容、電感、二極體、電晶體、積體電路和電鍵等，構成的網路、硬體。負電荷可以在其中運動。透過
         幾個電子元件通過導線互相連接，形成「電路」，也可以稱為「網路」。更特定地，電路是可以形成閉合
         迴路的網路。「支路」是電路的一部分，每一個元件都有它獨屬的支路。任意兩條或多條支路的相交點，
         稱為「節點」。
         簡單的說電路就是:讓電荷不斷循環的路徑。




































                                                      圖 1.30 電路示意

         1.3.8 歐姆定律

              德國物理學家格奧爾格·歐姆（G. Ohm）於 1827 年指出同一導體中，如圖 1.31 所示，通過導體的
         電流 I 與導體兩端的電壓 V 成正比與導體的電阻 R 成反比，也就是  V=IR。其電壓越大，通過的電流
         越大，若電阻越大，則電流越難通過。







         綜上述可整理出:
             1.  電流  I (A)  與  電壓  V (V)  成正比，與  電阻  R (Ω)  成反比
             2.  電壓  V (V)  與電流  I (A)  及  電阻  R (Ω)  成正比
             3.  電阻  R (Ω)  與  電壓  V (V)  成正比，與電流  I (A)  成反比



                                                              22]]></page><page Index="32"><![CDATA[其公式為:
                                     
                  
                =       V=IR         =
                                     


















                                                   圖 1.31 歐姆定律示意

         以下分別介紹歐姆定律公式與計算:
         I = V/R
         10 Ω 的電阻加上 100V 的電壓，通過的電流為:

         I = V/R = 100/10 A = 10 A

         電流  I (A)  與  電壓  V (V)  成正比，與電阻 R (Ω)成反比，因此 2 Ω 的電阻加上 10kV 的電壓，通過的
         電流是多少?
                            3
                                          3
         I = V / R = 10 x 10  / 2 A = 5 x 10  A    = 5kA
         I = V / R = 10k / 2 A = 5kA

         若 2 kΩ 的電阻加上 10V 的電壓，則通過的電流是多少?
                               3
                                           - 3
         I = V / R = 10 / 2 x 10  A = 5 x 10   A    = 5mA
         I = V / R = 10 / 2k A = 5mA

         2A 的電流通過 10 Ω 的電阻，要加上多少電壓?
         V = I R = 2 x 10 V = 20V
         在一定的電阻中，加上 10V 的電壓，會通過 2A 的電流，求電阻值
         R = V / I = 10 / 2 Ω = 5 Ω























                                                              23]]></page><page Index="33"><![CDATA[電阻-串聯
              串聯電路是指電路中的所有元件，以首尾相接的方法串聯在一起，如圖 1.32 所示，且電路中僅有
         一電流通過所有元件，這種單一路徑的電路，稱為串聯電路。串聯電路的特性為:
         E=V1+V2+V3+.....
         RT=R1+R2+R3+.....+Rn






























                                                      圖 1.32 串聯電路

         由上述可知串聯是  R = R 1 + R 2  故圖 1.32 所示之串聯電阻為:
         R = R 1 + R 2 = 3 Ω + 6 Ω = 9 Ω

         電阻-並聯
              並聯電路是指在電路中所有元件，輸入端和輸出端分別被連接在一起，如圖 1.33 所示，電路中每
         一元件兩端的電壓相同，流過每一元件的電流都是獨立，不會受其他元件影響，這種多路徑的電路，稱
         為並聯電路。並聯電路的特性:
         I = I1 + I2 + I3 + ......+ In
         V1 = V2 .... =Vn = E




















                                                      圖 1.33 並聯電路



                                                              24]]></page><page Index="34"><![CDATA[綜上可知，並聯是和分之積，其公式為:

                    
                1 2
            =
                 +   2
                1

         故如圖 1.33 所示，   =             1    2    =   3  6   Ω = 2 Ω
                                     1 +   2  3+6

         電阻-串並聯





















                                                       圖 1.34 串並聯

         如圖 1.34 所示，AB 之間的電阻為:
         3 x 6 Ω / 3 + 6 Ω = 2 Ω
         4 Ω + 2 Ω = 6 Ω

         1.3.9 克希荷夫定律:電流
              克希荷夫電路定律（Kirchhoff Circuit Laws）簡稱為克希荷夫定律，指的是兩條電路學定律，克希
         荷夫電流定律與克希荷夫電壓定律。它們涉及了電荷的守恆及電位的保守性。1845 年，古斯塔夫·克希
         荷夫首先提出克希荷夫電路定律。現在，這定律被廣泛地應用於電機工程學。

























                                                 圖 1.35 克希荷夫電流定律


                                                              25]]></page><page Index="35"><![CDATA[如圖 1.35 所示，其流入任一節點的電流與流出該節點的電流需相等， 故 流入電流的總和  =  流出電流的
         總和  ( I1 = I2 + I3 )。

         1.3.10 克希荷夫定律:電壓


























                                                 圖 1.36 克希荷夫電壓定律

         如圖 1.36 所示，其任一封閉迴路的電源電壓需等於各元件的電位差總和(VS = V1 + V2)。

         克希荷夫定律:計算方法

























                                                   圖 1.37 克希荷夫定律

         依據圖 1.37 所示，計算如下:
         封閉迴路  A = V1 – V2 = 1 V    [此處原型為  V1 +(- V2)]
         封閉迴路  B = V2 + V3 = 7 V
         I1 + I2 = I3 (流出的電流總和)
         A = I1 + I2 = 1 + 1 = 2 A






                                                              26]]></page><page Index="36"><![CDATA[CH 2  Arduino 程式語法




              在 Arduino  官方網站的  Language Reference (http://arduino.cc/en/Reference/HomePage)  函式網頁，
         可參閱到相關的基礎函示，如圖 2.1。










































                                          圖 2.1 Arduino  官方網站的  Language Reference
                                      資料來源：Language Reference (http://arduino.cc/en/Reference/HomePage)


         2.1 Arduino  程式主要架構


              Arduino  程式與  C  語言程式很相似，但語法更簡單而且易學易用，完全將微控制器中複雜的暫存
         器設定寫成函數，使用者只需輸入參數即可。  Arduino  程式主要由結構  ( structure )、數值  ( values )  及
         函式  ( functions )  等三個部分組成。Arduino  的程式結構包含  setup( )  及  loop( )  兩個函式。  setup( )
         函式用來初始化變數、設定接腳模式為輸入  ( INPUT )  或輸出  ( OUTPUT )  等。  在每次通電或重置
         Arduino  電路板時，setup( )  函式只會被執行一次。  loop( )  函式用來設計程式控制  Arduino  電路板所
         需的功能，並且重複執行。

         2.1.1 程式結構
         一個  Arduino  程式碼(Sketch)由兩部分組成
           void setup() {
               // put your setup code here, to run once:


                                                              27]]></page><page Index="37"><![CDATA[// //初始化變數、設定接腳模式等。
           }

           void loop() {
               // put your main code here, to run repeatedly:
               // //控制程式。
           }


         前置命令
              前置命令類似組合語言中的虛擬指令，是針對編譯器所下的指令，Arduino  語言在編譯之前會將程
         式中含有  ＂  #  ＂  記號的敘述先行處理，這個動作稱為前置處理，是由前置命令處理器  ( preprocessor )
         負責。  前置命令可以放在程式的任何地方，但是通常都放在程式的最前面。

         #define  前置命令
              使用  #define  前置命令可以定義一個巨集名稱來代表一個字串，這個字串可以是一個常數、運算
         式或是含有引數的運算式。  當程式中有使用到這個巨集名稱時，前置處理器就會將這些巨集名稱以及
         其所代表的字串來替換，使用越多次的相同巨集名稱時，就會佔用更多的記憶體空間，但是函式只會
         佔用定義一次函數所需的記憶體空間。  雖然巨集較佔用記憶體空間，但是執行速度較函式快。

           #difine  巨集名稱  字串

         程式範例：

           #define PI 3.14159                      //定義巨集  PI=3.14159
           #define AREA(x) PI*x*x              //定義巨集  AREA(x)=PI*x*x
           void setup() {
           }
           void loop() {
                     float resault=AREA(2);    //計算圓形面積
           }


           #include  前置命令
              使用  #include  前置命令可以將一個標頭檔案載入至一個原始檔案中，標頭檔必須以  h  為附加檔
         名 。   在  #include  後面的標頭檔有兩種敘述方式，一是使用雙引號  ＂  “，一是使用角括弧  ＂  < >  “ 。

         如果是以雙引號將標頭檔包圍，則前置命令處理器會先從原始檔案所在目錄開始尋找標頭檔，找不到
         時再到其他目錄中尋找。若是以角括號將標頭檔包圍，則前置命令處理器會先從標頭檔目錄中尋找，
         在  Arduino  語言中 定義了一些實用的 周邊標頭檔，以簡 化程式設計，如   EEPROM  記憶體
         (  EEPROM.h  )、伺服馬達  (  Servo.h  )、步進馬達  (  Stepper.h  )、SD  卡  (  SD.h  )、LCD  顯                     示  器
         ( LiquidCrystal.h )、TFT  顯示器  ( TFT.h )、乙太網路  ( Ethernet.h )、WiFi ( WiFi.h )、SPI  介面  ( SPI.h )、
         I2C  介面  ( Wire.h )、聲音介面  ( Audio.h )、USB  介面  ( USBHost.h )  等。

         指令格式：
           #include <標頭檔>
           #include "標頭檔"


                                                              28]]></page><page Index="38"><![CDATA[程式範例：
           #include <Servo.h>                                  //載入  Servo.h  標頭檔案
           Servo myservo;                                          //定義  Servo  物件
           int pos=0;                                                  //伺服馬達轉動角度
           void setup() {
                     myservo.attach(9);                        //servo  連接至數位接腳  9
           }
           void loop() {
                     for(pos=0;pos<180;pos+=1)          //由  0⁰ ~ 180⁰  每次轉動  1⁰
                     {
                             myservo.write(pos);              //伺服馬達轉動至指定的角度
                             delay(15);                                //延遲  15ms
                     }
                     for(pos=180;pos>=1;pos-=1)        //由  180⁰ ~ 0⁰  每次轉動  1⁰
                     {
                             myservo.write(pos);              //伺服馬達轉動至指定的角度
                             delay(15);                                //延遲  15ms
                     }
           }


         2.1.1.1 void setup()  程式初始化

              在這個函式範圍內放置初始化  Arduino  開發板的程式  -  在重複執行的程式 loop()之前執行，主要
         功能是將所有  Arduino  開發板的  Pin  腳設定，元件設定，  需要初始化的部分設定等等。


           在  void setup()  前為變數型態宣告區  ; //  這裡定義變數或  IO  腳位名稱

           void setup() {
               // put your setup code here, to run once:

           僅在  Power On  或  Reset  後執行一次，setup()函數內放置初始化  Arduino  控制板的程式，即主程式
           開始執行前需事先設定好的變數  or  腳位定義等例如  : PinMode(ledPin,OUTPUT);

           }


         2.1.1.2 void loop()  迴圈重複執行

              在此放置你的  Arduino  程式碼。這部份的程式會一直重複的被執行，直到
         Arduino  開發板被關閉。


          void loop() {
              // put your main code here, to run repeatedly:
          在  setup()函數之後，即初始化之後，系統則在  loop()程式迴圈內重複執行。直
          到  Arduino  控制板被關閉。


                                                              29]]></page><page Index="39"><![CDATA[;    每行程式敘述(statement)後需以分號(“;＂)結束

          }
          { }(大括號)函數前後需用大括號括起來，也可用此將程式碼分成較易讀的區塊


         2.1.2 區塊式結構化程式語言


              C  語言是區塊式結構的程式語言，  所謂的區塊是一對大括號：『{}』所界定的範圍，  每一對大括
         號及其涵括的所有敘述構成  C  語法中所謂的複合敘述(Compound Statement)，  這樣子的複合敘述不但
         對於編譯器而言，構成一個有意義的文法單位，  對於程式設計者而言，一個區塊也應該要代表一個完
         整的程式邏輯單元，  內含的敘述應該具有相當的資料耦合性  (一個敘述處理過的資料會被後面的敘述
         拿來使用)，  及控制耦合性  (CPU  處理完一個敘述後會接續處理另一個敘述指定的動作)，  當看到程
         式中一個區塊時，  應該要可以假設其內所包含的敘述都是屬於某些相關功能的，  當然其內部所使用
         的資料應該都是完成該種功能所必需的，  這些資料應該是專屬於這個區塊內的敘述，  是這個區塊之
         外的敘述不需要的。

         2.1.3 命名空間  (naming space)


              C  語言中區塊定義了一塊所謂的命名空間  (naming space)，  在每一個命名空間內，程式設計者可
         以對其內定義的變數任意取名字，  稱為區域變數  (local var- iable)，  這些變數只有在該命名空間  (區
         塊)  內部可以進行存取，  到了該區塊之外程式就不能在藉由該名稱來存取了，  如下例中  int  型態的變
         數  z。  由於區塊是階層式的，  大區塊可以內含小區塊，  大區塊內的變數也可以在內含區塊內使用，
         例如：

          {
            int x, r; x=10; r=20;
            {
            int y, z;
            float r;
            y = x;
            x = 1;
            r = 10.5;
            }
          z = x; //  錯誤，不可使用變數  z
          }


              上面這個例子裡有兩個區塊，  也就有兩個命名空間，  有任一個命名空間中不可有兩個變數使用
         相同的名字，  不同的命名空間則可以取相同的名字，  例如變數  r，  因此針對某一個變數來說，  可以
         使用到這個變數的程式範圍就稱為這個變數的作用範圍  (scope)。變數  (variable)  是利用宣告的方式，
         將記憶體中的某個區塊配置給此變數，不管變數的值如何改變，它會一直佔用相同的記憶體空間。
         例：int i=3;
         float f=15.7; char ch='y';



                                                              30]]></page><page Index="40"><![CDATA[常數  (constant)  的值是固定的，如整數常數、字元常數等。例：const int max=65536;

         變數的生命期  (Lifetime)

              變數的生命始於定義之敘述而一直延續到定義該變數之區塊結束為止，  變數的作用範圍：意指程
         式在何處可以存取該變數，  有時變數是存在的，但是程式卻無法藉由其名稱來存取它，  例如，  上例
         中內層區塊內無法存取外層區塊所定義的變數  r，  因為在內層區塊中  r  這個名稱賦予另一個  float  型
         態的變數了。

         2.1.4 縮小變數的作用範圍

         利用  C  語言的區塊命名空間的設計，  程式設計者可以儘量把變數的作用範圍縮小，  如下例：

          {
            int tmp;
            for (tmp=0; tmp<1000; tmp++)
            doSomeThing();
          }

          {
            float tmp;
            tmp = y;
            y = x;
            x = y;
          }

              上面這個範例中前後兩個區塊中的  tmp  很明顯地沒有任何關係，  看這個程式的人不必擔心程式
         中有藉  tmp  變數傳遞資訊的任何意圖。

         特殊符號
         ; (semicolon)
         {} (curly braces)
         // (single line comment)
         /* */ (multi-line comment)

         Arduino  語言用了一些符號描繪程式碼，例如註解和程式區塊。

         ; //(分號)
              Arduino  語言每一行程序都是以分號為結尾。這樣的語法讓你可以自由地安排代碼，你可以將兩個
         指令放置在同一行，只要中間用分號隔開（但這樣做可能降低程式的可讀性）。
         範例：
          delay(100);

         {}(大括號)
              大括號用來將程式代碼分成一個又一個的區塊，如以下範例所示，在  loop()
         函式的前、後，必須用大括號括起來。範例：
          void loop(){
          Serial.pritln("Hello !! Welcome to Arduino world");
          }


                                                              31]]></page><page Index="41"><![CDATA[註解

              程式的註解就是對代碼的解釋和說明，攥寫註解有助於程式設計師(或其他人)  了解代碼的功能。
         Arduino  處理器在對程式碼進行編譯時會忽略註解的部份。Arduino  語言中的攥寫註解有兩種方式

          //單行註解：這整行的文字會被處理器忽略

          /*多行註解：
          在這個範圍內你可以寫許多備註說明
          */

         變數
              在  Arduino  程式中常使用變數  ( variables )  與常數  ( constants )  來取代記憶體的實際位址，好處
         是程式設計者不需要知道那些位址是可以使用的，而且程式將會更容易閱讀與維護。  一個變數或常數
         的宣告是為了保留記憶體空間給某個資料來儲存，至於是安排哪一個位址，則是由編譯器統一來分配。
         程式中的變數與數學使用的變數相似，都是用某些符號或單字代替某些數值，  從而得以方便計算過程。
         程式語言中的變數屬於識別字  (identifier)  ，  C  語言對於識別字有一定的命名規則，例如只能用英文
         大小寫字母、數字以及底線符號。其中，數字不能用作識別字的開頭，單一識別字裡不允許有空格，而
         如  int  、char  為  C    語言的關鍵字    (keyword)    之一，屬於程式語言的語法保留字，因此也不能用為
         自行定義的名稱。通常編譯器至少能讀取名稱的前  31  個字元，但外部名稱可能只能保證前六個字元
         有效。
              變數使用前要先進行宣告  (declaration)  ，宣告的主要目的是告訴編譯器這個變數屬於哪一種資料
         型態，好讓編譯器預先替該變數保留足夠的記憶體空間。宣告的方式很簡單，就是型態名稱後面接空
         格，然後是變數的識別名稱。Arduino  的變數命名規則與  C  語言相似，必須是由英文字母、數字或底
         線符號  ＂  _  ＂  之後，再緊接著字母或數字，並且第一個字元不可以是數字。  因此,在命名變數名稱
         時，應該以容易閱讀為原則。

              宣告一個變數，必須指定變數的名稱及資料形態，當變數的資料形態指定後，編譯器將會配置適當
         的記憶體空間來儲存這個變數。  宣告範例如下:
           int ledPin=10;                    //宣告整數變數  ledPin,初始值為  10。
           char myChar='A';                //宣告字元變數  myChar,初始值為  'A'。
           float sensorVal=12.34;    //宣告浮點數變數  sensorVal,初始值為  12.34。
              如果一個以上的變數具有相同的資料形態，也可以只用一個資料形態來宣告，被宣告的變數之間
         以逗號分開。  如果變數有初始值時，也可以在宣告變數的同時一起設定。  宣告範例如下:
           int year=2017,moon=7,day=15;        //宣告整數變數  year、moon、day  及其初始值。

         變數的生命週期
              所謂變數的生命週期是指變數保存某個數值，佔用記憶體空間的時間長短，可以區分為區域變數
         ( local variables )  及全域變數  ( global variables )  兩種。

              全域變數被宣告在任何函式之外，當執行  Arduino  程式時，全域變數即被產生並且配置記憶體空
         間給這些全域變數，在程式執行期間，都能保存其數值，直到程式結束執行時，才會釋放這些佔用的記
         憶體空間。  全域變數並不會禁止與其他無關的函式作存取動作，因此在使用上要特別小心，避免變數
         數值可能被不經意的更改。  因此，除非有特別需求，否則還是盡量使用區域變數。



                                                              32]]></page><page Index="42"><![CDATA[區域變數又稱為自動變數，被宣告在函式的大括弧  ＂  {}  ＂  之內，當函式被呼叫使用時，這些區
         域變數就會自動產生，系統會配置記憶體空間給這些區域變數，當函式結束時，這些區域變數又自動
         的消失並且釋放所佔用的記憶體空間。
           int total;                                        //全域變數  total  在所有函式內皆有效。
           void setup()
           {
                     // .....
           }
           void loop()
           {
                   int i;                                        //區域變數  i  只有在  loop()  函式內才有效。
                   for(int j=0;j<100;j++)        //區域變數  j  只有在  for  迴圈內才有效。
                   {
                             // .....
                   }
           }

         常數
              HIGH | LOW
              INPUT | OUTPUT
              true | false
              Integer Constants
              在  Arduino  語言中事先定義了一些具特殊用途的保留字。HIGH    和  LOW  用來表示你開啟或是
         關閉了一個  Arduino  的腳位(Pin)。INPUT  和  OUTPUT  用來指示這個  Arduino  的腳位(Pin)是屬於輸
         入或是輸出用途。true  和  false  用來指示一個條件或表示式為真或是假。

              變數用來指定  Arduino  記憶體中的一個位置，變數可以用來儲存資料，程式人員可以透過程式碼
         去不限次數的操作變數的值。
         因為  Arduino  是一個非常簡易的微處理器，但你要宣告一個變數時必須先定義他的資料型態，好讓微
         處理器知道準備多大的空間以儲存這個變數值。

         陣列  ( array )

              所謂陣列  ( array )  是指存放在連續記憶體中的一群相同資料形態的集合，陣列也如同變數一樣需
         要先宣告，編譯器才會知道陣列的資料形態及大小。  陣列的宣告陣列包含四個項目：

         1.資料形態：在陣列中每個元素的資料形態皆相同。
         2.陣列名稱：命令規則與變數宣告方法相同。
         3.陣列大小：陣列可以是多維的，但必須指定其大小，編譯器才能為陣列配置記憶體空間。
         4.陣列初值：與變數相同，可以事先指定初值或不指定。

         一維陣列
           資料形態  陣列名稱[陣列大小 n]={初值 0,初值 1,初值 2,初值 3,...,初值 n-1};

         程式範例：
           void setup() {
           }
           void loop() {
                                                              33]]></page><page Index="43"><![CDATA[int a[5]={1,2,3,4,5};    //宣告一維整數陣列
           }


         二維陣列
           資料形態  陣列名稱[m][n]=
                             {  初值 0,  初值 1,  初值 2, ... ,  初值 n-1 },      //第  0  列
                                 初值 0,  初值 1,  初值 2, ... ,  初值 n-1 },      //第  1  列
                                                                         :
                                 初值 0,  初值 1,  初值 2, ... ,  初值 n-1 } }; //第  m-1  列


         程式範例：
           void setup() {
           }
           void loop() {
                     int a[2][3]=                //宣告二維整數陣列
                             { {0,1,2},            //第  0  列
                                 {3,4,5} };        //第  1  列
           }


         以陣列傳引數
              將變數作為引數傳入函式中，是將變數的數值傳至函式，同時在函式中會在配置一個記憶體空間
         給這個變數，此種方法稱為傳值呼叫。  如果要將陣列資料傳入函式中，則必須傳給函式兩個引數：一
         為資料位址的，一為陣列的大小，此種方法稱為傳址呼叫。  當傳遞陣列給函式時，並不會將此陣列複
         製一份給函式，只是傳遞陣列位址給函式，函式再利用這個位址與註標去存取原來在主函式中的陣列。

         程式範例：

           void setup() {
           Serial.begin(9600);
           }
           void loop() {
                     int result;                                    //宣告整數變數  result
                     int a[5]={1,2,3,4,5};                //宣告整數陣列  a[5]
                     int size=5;                                    //宣告整數變數  size
                     result=sum(a,size);                    //傳址呼叫函式  sum
                     Serial.println(result);
           }
           int sum(int a[],int size) {              //函式  sum
                   int i;                                                //宣告整數變數  i
                   int result=0;                                  //宣告整數變數  result
                   for(i=0;i<size;i++)
                           result=result+a[i];              //計算陣列中所有元素的總和
                   return result;                                //傳回計算結果
           }

                                                              34]]></page><page Index="44"><![CDATA[2.1.5 Arduino  語言支援的資料型態

              由於每一種資料形態( Data types )  在記憶體中所佔用的空間不同，因此在宣告變數的同時，也必
         須指定變數的資料形態，如此編譯器才能配置適當的記憶體空間給這些變數來存放。  在 Arduino  語言
         中所使用的資料形態大致可分為布林、整數及浮點數等三種，其中整數資料形態有  char (  字元  )、int
         (  整數  )、long (  長整數  )  等三種，配合  signed (  有號數  )、unsigned (  無號數  )  等前置修飾字組合，
         可以改變資料的範圍。  浮點數資料形態有  float、double  兩種，常應用於需要更高解析的類比輸入值。
         另外，布林資料形態  boolean  定義範圍為  true  及  false，是用來提高程式的可讀性。

                                                        表 2.1 資料型態

                                   資料形態         位元數 範圍

                                   boolean           8 ture (  定義為非  0 ),false (  定義為  0 )
                                   char              8 -128 ~ +127
                                   unsigned char     8 0 ~ 255
                                   byte              8 0 ~ 255
                                   int              16 -32,768 ~ +32,767
                                   unsigned int     16 0 ~ 65,535
                                   word             16 0 ~ 65,535
                                   long             32 -2,147,483,648 ~ +2,147,483,647
                                   unsigned long    32 0 ~ 4,294,967,295
                                   short            16 -32,768 ~ +32,767
                                   float            32 -3.4028235E+38 ~ +3.4028235E+38
                                   double           32 -3.4028235E+38 ~ +3.4028235E+38

                                                  表 2.2 常用基本資料型態
                          資料型態          位元組             範圍                            備註


              char          字元             1           0~255         用來儲存英文字母及  ASCII  碼
                                                                     可在  int  之前加上修飾詞  (qualifier)，
               int          整數             2       -32768~32767
                                                                     unsigned、short、long


              float       浮點數              4      1.2e-38~3.4e38     可用小數點及指數型態表示。

             double    倍精度浮點數              8     2.2e-308~1.8e308  可用小數點及指數型態表示。


         布林  boolean
              布林變數的值只能為真(true)或是假(false)

         字元  char
              單一字元例如  A，和一般的電腦做法一樣  Arduino  將字元儲存成一個數字，  即使你看到的明明
         就是一個文字。用數字表示一個字元時，它的值有效範圍為  -128  到  127。PS：目前有兩種主流的電腦
         編碼系統  ASCII  和  UNICODE。ASCII  表示了  127  個字元，  用來在序列終端機和分時計算機之間傳
         輸文字。UNICODE  可表示的字量比較多，在現代電腦作業系統內它可以用來表示多國語言。在位元數

                                                              35]]></page><page Index="45"><![CDATA[需求較少的資訊傳輸時，例如義大利文或英文這類由拉丁文，阿拉伯數字和一般常見符號構成的語言，
         ASCII  仍是目前主要用來交換資訊的編碼法。

         位元組  byte
              儲存的數值範圍為  0  到  255。如同字元一樣位元組型態的變數只需要用一個位元組(8  位元)的記
         憶體空間儲存。

         整數  int
              整數資料型態用到  2  位元組的記憶體空間，可表示的整數範圍為  –32,768  到
         32,767;  整數變數是  Arduino  內最常用到的資料型態。

         整數  unsigned int

              無號整數同樣利用  2  位元組的記憶體空間，無號意謂著它不能儲存負的數值，  因此無號整數可
         表示的整數範圍為  0  到  65,535。

         長整數  long
              長整數利用到的記憶體大小是整數的兩倍，因此它可表示的整數範圍從  –2,147,483,648  到
         2,147,483,647  。

         長整數  unsigned long
              無號長整數可表示的整數範圍為  0  到  4,294,967,295。

         浮點數  float
              浮點數就是用來表達有小數點的數值，每個浮點數會用掉四位元組的  RAM，  注意晶片記憶體空
         間的限制，謹慎的使用浮點數。

         雙精準度  浮點數  double
              雙精度浮點數可表達最大值為  1.7976931348623157 x 10308。

         字串  char

              字串用來表達文字信息，它是由多個  ASCII  字元組成(你可以透過序串埠發送一個文字資訊或者
         將之顯示在液晶顯示器上)。字串中的每一個字元都用一個組元組空間儲存，並且在字串的最尾端加上
         一個空字元以提示  Ardunio  處理器字串的結束。下面兩種宣告方式是相同的。
          char word1 = "Arduino world"; // 7  字元  + 1  空字元
          char word2 = "Arduino is a good developed kit"; //  與上行相同

         陣列  array
              一串變數可以透過索引去直接取得。假如你想要儲存不同程度的  LED  亮度時，你可以宣告六個
         變數  light01，light02，light03，light04，light05，light06，但其實你有更好的選擇，例如宣告一個整數
         陣列變數如下：

          int light = {0, 20, 40, 65, 80, 100};

          //"array"  這個字為沒有直接用在變數宣告，而是[]和{}宣告陣列。

          char Str1[15];      //在  Str1  中  聲明一個沒有初始化的字元陣列

                                                              36]]></page><page Index="46"><![CDATA[char Str2[8] = {'a', 'r', 'd', 'u', 'i', 'n', 'o'};    //在  Str2  中聲明一個字元陣列(包括一
          個附加字元)，編譯器會自動添加所需的空字元

          char Str3[8] = {'a', 'r', 'd', 'u', 'i', 'n', 'o', '\0'};
          //在  Str3  中  明確加入空字元(, '\0')

          char Str4[ ] = "arduino";
          //在  Str4  中  用引號分隔初始化的字串常數，編譯器將調整陣列的大小，以適
          應字串常量和終止空字元
          char Str5[8] = "arduino";
          //在  Str5  中  初始化一個包括明確的尺寸和字串常量的陣列

          char Str6[15] = "arduino";
          //在  Str6  中  初始化陣列，預留額外的空間用於一個較大的字串


         空終止字元
              一般來說，字串的結尾有一個空終止字元（ASCII  代碼  0），  以此讓功能函數（例如  Serial.prinf()）
         知道一個字串的結束，  否則，他們將從記憶體繼續讀取後續位元組，而這些並不屬於所需字串的一部
         分。這表示你的字串比你想要的文字包含更多的個字元空間，  這就是為什麼  Str2  和  Str5  需要八個字
         元，        即使“Arduino＂只有七個字元  -  最後一個位置會自動填充空字元，  str4  將自動調整為八個
         字元，包括一個額外的  null，  在  Str3  的，我們自己已經明確地包含了空字元(寫入'\0')。

         使用符號：單引號?還是雙引號?
              定義字串時使用雙引號(例如“ABC＂)，
              定義一個單獨的字元時使用單引號(例如'A')
         範例

          字串測試範例(stringtest01)

          char* myStrings[]={
          "This is string 1", "This is string 2", "This is string 3", "This is string 4", "This is
          string 5","This is string 6"};

          void setup(){
             Serial.begin(9600);
          }

          void loop(){
             for (int i = 0; i < 6; i++){
             Serial.println(myStrings[i]);
             delay(500);
             }
          }

              char*  在字元資料類型  char  後跟了一個星號'*'表示這是一個“指標＂陣列，  所有的陣列名稱實

                                                              37]]></page><page Index="47"><![CDATA[際上是指標，所以這需要一個陣列的陣列。指標對於  C  語言初學者而言是非常深奧的部分之一，  但
         是目前我們沒有必要瞭解詳細指標，就可以有效地應用它。

         2.1.6 型態轉換

              在  Arduino  程式中，可以使用  char(x)、byte(x)、int(x)、word(x)、long(x)、float(x)  等資料形態轉
         換函式來改變變數的資料形態，引數  x  可以是任何形態的資料。

         char()
         語法：char(x)
         參數 x:  想要轉換資料的變數或內容回傳字元形態資料

         unsigned char()
              一個無符號資料類型佔用  1  個位元組的記憶體:與  byte  的資料類型相同，無符號的  char  資料類
         型能編碼  0  到  255  的數位，為了保持  Arduino  的程式設計風格的一致性，byte  資料類型是首選。
         語法：unsigned char(x)
         參數 x:  想要轉換資料的變數或內容回傳字元形態資料
          unsigned char myChar = 240;

         byte()
         語法：byte(x)
         參數 x:  想要轉換資料的變數或內容回傳位元資料形態的資料

         int(x)
         語法：int(x)
         參數 x:  想要轉換資料的變數或內容回傳整數資料形態的資料

         unsigned int(x)
              unsigned int(無符號整數)與整型資料同樣大小，佔據  2  位元組:  它只能用於存儲正數而不能存儲
         負數，範圍  0~65,535 (2^16) - 1)。
         語法：unsigned int(x)
         參數 x:  想要轉換資料的變數或內容回傳整數資料形態的資料
          unsigned int ledPin = 13;

         long()
         語法：int(x)
         參數 x:  想要轉換資料的變數或內容回傳長整數資料形態的資料

         unsigned long()
              無符號長整型變數擴充了變數容量以存儲更大的資料，  它能存儲  32  位元(4  位元組)資料:與標準
         長整型不同無符號長整型無法存儲負數，  其範圍從  0  到 4,294,967,295 ( 2^32-1 )  。
         語法：unsigned int(x)
         參數 x:  想要轉換資料的變數或內容回傳長整數資料形態的資料
          unsigned long time;

          void setup()
          {


                                                              38]]></page><page Index="48"><![CDATA[Serial.begin(9600);
          }

          void loop()
          {
             Serial.print("Time: "); time = millis();
          //程式開始後一直列印時間
             Serial.println(time);
          //等待一秒鐘，以免發送大量的資料 delay(1000);
          }


         float()
         指令用法
         語法：float(x)
         參數 x:  想要轉換資料的變數或內容回傳浮點數資料形態的資料

         2.1.7 邏輯控制(控制流程)


              所謂程式流程控制，是在控制程式執行的方向，Arduino  程式流程控制可分成三大類，即迴圈控制
         指令：for、while、do  …. while，條件控制指令：if、switch case  及無條件跳躍指令：goto、break、continue。
         Ardunio  利用一些關鍵字控制程式碼的邏輯。

         if  敘述
         if  敘述會先判斷條件式，若條件式為真時，則執行一次大括弧  { }  中的敘述，若條件式為假時，則不
         執行。

           if(條件式)
           {
                 //動作敘述
           }

         if  敘述內如果只有一行敘述時，可以不用加大括弧  ＂  { }  “，但如果有一行以上敘述時，一定要加上
         大括弧  ＂  { }  “，否則在  if  敘述內只會執行第一行敘述，其餘敘述則視為在  if  敘述之外。

           void setup() {
           }
           void loop() {
                     int a=2,b=3,c=0;    //宣告整數變數
                     if(a>b)                      // a>b  ？
                     {
                           c=a;                      //若  a>b，  c=a
                     }
           }

         if-else  敘述



                                                              39]]></page><page Index="49"><![CDATA[圖 2.2 if-else

         if-else  敘述會先判斷條件式，若條件為真時，則執行敘述  1，若條件為假時，則執行敘述  2。
           if(條件式)
           {
                 //動作敘述  1
           }
           else
           {
                 //動作敘述  2
           }

         在    if    敘述或  else  敘述內，如果只有一行敘述時，可以不用加大括弧  ＂  { }  “，但如果有一行以上
         敘述時，一定要加上大括弧  ＂  { }  “。

           void setup() {
           }
           void loop() {
                     int a=2,b=3,c=0;    //宣告整數變數
                     if(a>=b)                    // a>=b  ？
                     {
                           c=a;                      //若  a>=b，  c=a
                     }
                     else
                     {
                           c=b;                      //若  a<b，  c=b
                     }
           }

                                                        表 2.3 運算子

                                         運算子(?:)                               意義







                                                              40]]></page><page Index="50"><![CDATA[if(判斷條件)

                              條件判斷  ?  運算式  1 :  運算式  2                運算式  1;
                                                                  else
                                                                       運算式  2;

                                                            實例

                                                                  if (x > 100)
                                     a = (x > 100) ? b : c;           a = b;
                                                                  else
                                                                      a = c;
                                                                  if (a > 0)

                                     abs = (a > 0) ? a : -a;           abs = a;
                                                                  else
                                                                       abs = -a;

              if  必須緊接著一個問題表示式(expression)，若這個表示式為真，緊連著表示式後的代碼就會被執
         行。若這個表示式為假，則執行緊接著  else  之後的代碼.  只使用 if  不搭配  else  是被允許的。
         範例：
          #define LED 12
          void setup()
          {
             int val =1;
             if (val == 1) {
               digitalWrite(LED,HIGH);
             }
          }

          void loop()
          {
          }


                                                     表 2.4 比較 if  用法

                     if 敘述                  if…else                  巢狀  if            if…else if…else

             if (判斷條件)               if (判斷條件)                if (判斷條件  1)            if (判斷條件)
                  敘述;                     敘述  1;              {                       {
                                     else                         敘述主體  1;                 敘述主體 1;
                                          敘述  2;                                      }















                                                              41]]></page><page Index="51"><![CDATA[if (判斷條件)               if (判斷條件)                    if (判斷條件  2)        else if (判斷條件)
             {                       {                            {                   {
                  敘 述  1;                 敘述主體  1;                    敘述主體  2;             敘述主體 2;
                  …                  }                                                }
                  敘 述  n;            else                         }                   …
                                                                                      else
             }                       {
                                                                  …                   {
                                          敘述主體  2;
                                     }                        }                            敘述主體  n;
                                                                                      }

         switch-case  敘述
              switch-case  敘述與  if-else if  敘述類似，但  switch-case  敘述格式較清楚且有彈性。  if-else if  是二
         選一的程式控制流程指令，而  switch-case  則是多選一的程式控制流程指令。  switch  以條件式運算結
         果與  case  所指定的條件值比對，若某個  case  中的條件值相同，則執行該  case  所指定的敘述，若所
         有條件值都不符合，則執行  default  所指定的敘述，在  switch  內的條件式運算結果必須是整數或字元。

               如果要結束  case  中的動作，可以使用  break  敘述，但是一次只能跳出一層迴圈，如果要一次結
           束多個迴圈，可以使用  goto  指令，但程式的流程將變得淩亂，所以盡量少用或不用  goto  指令。



































                                                        圖 2.3 switch-case

           switch(條件式)
           {
                   case  條件值  1:                  //條件式等於條件  1  時，執行動作敘述  1
                             { //動作敘述 1; }
                             break;
                   case  條件值  2:                  //條件式等於條件  2  時，執行動作敘述  2
                             { //動作敘述 2; }
                             break;


                                                              42]]></page><page Index="52"><![CDATA[case  條件值  3:                  //條件式等於條件  3  時，執行動作敘述  3
                             { //動作敘述 3; }
                             break;
                   default:                            //所有條件式值都不等於條件式時，執行動作敘述  n
                             { //動作敘述 n; }
                             break;
           }

              if  敘述是程式裡的分叉選擇，switch case  是更多選項的分叉選擇。swith case  根據變數值讓程式有
         更多的選擇，比起一串冗長的  if  敘述，使用  swith case  可使程式代碼看起來比較簡潔。
         範例  :
          void setup()
          {
          int sensorValue;
          sensorValue = analogRead(1);

             switch (sensorValue) {
               case 10:
                  digitalWrite(13,HIGH); break;
               break;

               case 20:
                  digitalWrite(12,HIGH);
               break;
             default: //  以上條件都不符合時，預設執行的動作
             digitalWrite(12,LOW);
             digitalWrite(13,LOW);
             }
          }

          void loop()
          {
          }



         迴圈控制指令
         for  迴圈
              for  迴圈是由初值運算式、條件運算式與增量或減量運算式三部分組成，彼此之間以分號隔開。
         1.初值：設定初值，可由任何數值開始。
         2.條件：若條件為真，則執行括弧  ” { } ”  中的敘述，否則離開迴圈。
         3.增量  （  或減量  ）：每執行一次迴圈內的動作後，依增量  （  或減量  ）  遞增  （  或遞減  ）。
           for(初值;條件;增量或減量)
           {
                   //動作敘述
           }




                                                              43]]></page><page Index="53"><![CDATA[圖 2.4 for 迴圈

         用來明定一段區域代碼重覆指行的次數。範例：
          void setup()
          {
             for (int i = 1; i < 9; i++) {
             Serial.print("2 * ");
             Serial.print(i);
             Serial.print(" = ");
             Serial.print(2*i);
             }
          }

          void loop()
          {
          }


         while  迴圈
              while  為先判斷型迴圈，當條件為真時，則執行大括弧  ＂  { }  ＂  中的敘述，直到條件為假不成立
         時，才結束  while  迴圈。  在  while  條件式中沒有初值運算式及增量 （  或減量  ）  運算式，因此必須
         在敘述中設定。



















                                                      圖 2.5 while 迴圈

         當  while  之後的條件成立時，執行括號內的程式碼。
           while(條件式)
           {
                   //動作敘述
           }


                                                              44]]></page><page Index="54"><![CDATA[範例  :
          void setup()
          {
             int sensorValue;
             //  當  sensor  值小於  256，閃爍  LED 1  燈
             sensorValue = analogRead(1);
             while (sensorValue < 256) {
               digitalWrite(13,HIGH);
               delay(100);
               digitalWrite(13,HIGH);
               delay(100);
               sensorValue = analogRead(1);
             }
          }

          void loop()
          {
          }


         do-while  迴圈
              do-while  為後判斷型迴圈，會先執行大括弧  ＂  { }  ＂  中的敘述一次，然後再判斷條件式，當條
         件式為真時，則繼續執行大括弧  ＂  { }  ＂  中的動作，直到條件式為假時，才結束  do-while  迴圈。因
         此  do-while  迴圈至少執行一次。和  while  相似，不同的是  while  前的那段程式碼會先被執行一次，不
         管特定的條件式為真或為假。因此若有一段程式代碼至少需要被執行一次，就可以使用 do…while  架
         構                                                                                                       。














                                                    圖 2.6 do-while 迴圈


           do {                    //先執行一次敘述
                 //動作敘述
           }
           while(條件式)    //後判斷型迴圈

         範例  :
          void setup()
          {
             int sensorValue;
             do
             {
               digitalWrite(13,HIGH);

                                                              45]]></page><page Index="55"><![CDATA[delay(100);
               digitalWrite(13,HIGH);
               delay(100);
               sensorValue = analogRead(1);
             }
             while (sensorValue < 256);
          }

          void loop()
          {
          }

                                             表 2.5 比較  for / while / do…while

                         for 敘述                        while 敘述                      do…while 敘述

             for (初值;  判斷條件;  增減量)            設初值;                            設初值
             {                                while (判斷條件)                    do
                  敘 述  1;                     {                               {
                  敘 述  2;                         敘 述  1;                          敘 述  1;
                  …                               敘 述  2;                          敘 述  2;
                  敘 述  n;                         …                                …
             }                                    敘 述  n;                          敘 述  n;
                                                  設增減量;                            設增減量;
                                              }                               } while (判斷條件);




                                                          實例

             for (i=1,sum=0;i<=9;i+=2)        i=1;                            i=1;
             {                                sum=0;                          sum=0;
               sum += i; printf("i=%d\n", i);   while(i<=9)                   do
               printf("sum=%d\n",sum);        {                               {
               printf("\n");                   sum += i; printf("i=%d\n", i);   sum += i; printf("i=%d\n", i);
             }                                 printf("sum=%d\n",sum);          printf("sum=%d\n",sum);
                                               printf("\n");                    printf("\n");
                                               i += 2;                          i += 2;
                                              }                               } while (i<=9);


         break
              Break  讓程式碼跳離迴圈，並繼續執行這個迴圈之後的程式碼。此外，在  break 也用於分隔  switch
         case  不同的敘述。
         範例  :
          void setup()
          {
          }

          void loop()


                                                              46]]></page><page Index="56"><![CDATA[{
             int sensorValue;
             do {
               //  按下按鈕離開迴圈
               if (digitalRead(7) == HIGH)
               break;
               digitalWrite(13,HIGH);
               delay(100);
               digitalWrite(13,HIGH);
               delay(100);
               sensorValue = analogRead(1);
             }
             while (sensorValue < 512);
          }


         continue
              continue  用於迴圈之內，它可以強制跳離接下來的程式，並直接執行下一個迴圈。
         範例  :
          #define PWMPin 12
          #define SensorPin 8
          void setup()
          {
          }

          void loop()
          {
             int light;
             int x ;
             for (light = 0; light < 255; light++)
             {
               //  忽略數值介於  140  到  200  之間
               x = analogRead(SensorPin) ;
               if ((x > 140) && (x < 200))
               continue;
               analogWrite(PWMPin, light); delay(10);
             }
          }


                                                    表 2.6 break / continue
                                 break(跳出迴圈)                         continue(回到迴圈開始處)














                                                              47]]></page><page Index="57"><![CDATA[for (設初值;  判斷條件;  設增減量)                  for (設初值;  判斷條件;  設增減量)
                       {                                        {
                            敘 述  1;                                  敘 述  1;
                            敘 述  2;                                  敘 述  2;
                            …                                        …
                            break;                                   continue;
                            …                                        …
                            敘述  n;                                   敘述  n;
                       }                                        }
                       …                                        …
                       備註：在  while / do while  迴圈中的用法相同


         return
              函  式  的  結  尾  可  以  透  過    return  回 傳 一 個 數 值 。 例 如 ， 有 一 個 計 算 現 在 溫 度 的 函 式 叫
         computeTemperature()，你想要回傳現在的溫度給  temperature  變數，你可以這樣寫：

           #define PWMPin 12
           #define SensorPin 8

           void setup()
           {
           }
           void loop()
           {
           int light; int x ;
           for (light = 0; light < 255; light++)
           {
           //  忽略數值介於  140  到  200  之間
           x = computeTemperature() ; if ((x > 140) && (x < 200))
           continue;

           analogWrite(PWMPin, light); delay(10);
           }
           }
           int computeTemperature() {

           int temperature = 0;
           temperature = (analogRead(SensorPin) + 45) / 100; return temperature;
           }


         goto  敘述
              goto  敘述可以結束所有迴圈執行，但是為了程式的結構化，應盡量少用  goto  敘述，因為使用  goto
         敘述會造成程式流程的混亂，使得程式閱讀更加困難。  goto  敘述所指定的標記名稱必須與  goto  敘述
         在同一個函式內，不能跳到其它的函式內。  標記名稱與變數寫法相同，唯一的區別是標記名稱後面須
         再加上一個冒號。



                                                              48]]></page><page Index="58"><![CDATA[goto  標記名稱

         程式範例：
           void setup() {
           }

           void loop() {
                     int i,j,k;                                                    //  宣告整數變數  i，j，k
                     for(i=0;i<1000;i++)                                  // i  迴圈
                             for(j=0;j<1000;j++)                          // j  迴圈
                                     for(k=0;k<1000;k++)                  // k  迴圈
                                             if(analogRead(0)>500)      //  類比接腳  0  讀取值大於  500？
                                                   goto exit;                      //  類比接腳  0  讀取值大於  500  ，結束  i，j，k  迴圈
                     exit;
           }

         2.1.8 算術運算


              電腦除了能夠儲存資料外，還必須具備運算的能力，而在運算時所使用的符號，即稱為運算子
         ( operator )。  常用的運算子可分為算術運算子、關係運算子、邏輯運算子、位元運算子及指定運算子
         等。  當敘述中包含不同運算子時，Arduino  微控制器會先執行算術運算子，其次是關係運算子，最後
         才是邏輯運算子。  我們可以使用小括弧  ( )  來改變運算的順序。當算式中有一個以上的算術運算子時，
         將會先進行乘法、除法與餘數的運算，然後再計算加法與減法。  當算式中的算數運算子具有相同優先
         順序時，執行順序由左至右，先計算括弧中的運算式，再計算其他運算。

                                                      表 2.7 算術運算
            運算子        意義         int a=9,b=4     運算結果         簡潔運算式                      說明


              +        加法            a+b             13       a+=b            a  內含值與  b  內含值相加

              -        減法             a-b             5       a-=b            a  內含值與  b  內含值相減

              *        乘法            a*b             36       a*=b            a  內含值與  b  內含值相乘


              /        除法             a/b             2       a/=b            a  內含值除以  b  內含值的商數

              %       取餘數            a%b              1       a%=b            a  內含值除以  b  內含值的餘數


             ++        遞增            a++             10       a++             a  內含值加  1,即  a=a+1

              —        遞減             a–              8       a--             a  內含值減  1,即  a=a-1

              你可以透過特殊的語法用  Arduino    去做一些複雜的計算。  +    和  –就是一般數學上的加減法，
         乘法用*示，而除法用  /表示。
              另外餘數除法(%)，用於計算整數除法的餘數值:  一個整數除以另一個數，其餘數稱為模數，它有
         助於保持一個變數在一個特定的範圍(例如陣列的大小)。


                                                              49]]></page><page Index="59"><![CDATA[語法：
         result = dividend % divisor

         參數：
              dividend：一個被除的數字
              divisor：一個數字用於除以其他數

           void setup()
           {
           }
           void loop()
           {
                     int a=20,b=3;
                     int c,d,e,f;
                     c=a+b;                        //加法運算
                     d=a-b;                        //減法運算
                     e=a/b;                        //除法運算
                     f=a%b;                        //餘數運算
                     a++;                            //遞增
                     b--;                            //遞減
           }


         {}括號
              你可以透過多層次的括弧去指定算術之間的循序。和數學函式不一樣，中括號和大括號在此被保
         留在不同的用途(分別為陣列索引，和宣告區域程式碼)。
         範例  :
          #define PWMPin 12
          #define SensorPin 8

          void setup()
          {
             int sensorValue;
             int light;
             int remainder;

             sensorValue = analogRead(SensorPin) ;
             light = ((12 * sensorValue) - 5 ) / 2;
             remainder = 3 % 2;
          }
          void loop()
          {
          }


         2.1.9 比較運算

              比較運算(關係運算子)會比較兩個運算元的值，然後傳回布林值  ( boolean )。  比較運算子的優先
         順序全都相同，依照出現的順序由左而右依序執行。當你在指定  if,while, for  敘述句時，可以運用下面
                                                              50]]></page><page Index="60"><![CDATA[這個運算符號：

                                                        表 2.8 關係運算子

              運算子          意義        用法        範例        運算結果                           說明


                 >         大於        a>b       2>3         false                      a  大於  b
                                                                          若為真,結果為  ture,否則為  false。

                >=       大於等於        a>=b      2>=3        false                    a  大於等於  b
                                                                          若為真,結果為  ture,否則為  false。

                 <         小於        a<b       2<3          true                      a  小於  b
                                                                          若為真,結果為  ture,否則為  false。

                <=       小於等於        a<=b      2<=3         true                    a  小於等於  b
                                                                          若為真,結果為  ture,否則為  false。

                ==         等於        a==b      2==3        false                      a  等於  b
                                                                          若為真,結果為  ture,否則為  false。
                 !=       不等於        a!=b      2!=3         true                     a  不等於  b
                                                                          若為真,結果為  ture,否則為  false。

           const LEDPin=13;
           void setup()
           {
                   pinMode(LEDPin,OUTPUT);
           }
           void loop()
           {
                   int x=200;
                   if(x>100) // x  大於  100?
                         digitalWrite(LEDPin,HIGH);        //若  x  大於  100,則點亮  LED
                   else // x  小於或等於  100
                         digitalWrite(LEDPin,LOW);          //x  小於或等於  100,則關閉  LED
           }

         布林運算(邏輯運算子)
              在邏輯運算子中，凡是非  0  的數即為真  ( true )，若為  0  即為假  ( false )。  對及( AND)  運算而
         言，兩數皆為真時，結果才為真。  對或  (OR )  運算而言，有任一數為真時，其結果即為真。  對反  ( NOT )
         運算而言，若數值為真，經反運算後即為假。  反之,若數值為假，經反運算後即為真。

                                                      表 2.9 邏輯運算

                      邏輯運算子  動作  範例                說明
                      &&           AND  a&&b       a  與  b  兩變數執行邏輯  AND  運算。
                      ||           OR     a|| b    a  與  b  兩變數執行邏輯  OR  運算。
                      !            NOT  !a         a  變數執行邏輯  NOT  運算。



                                                              51]]></page><page Index="61"><![CDATA[當你想要結合多個條件式時，可以使用布林運算符號。
           void setup () {
           }
           void loop() {
                   boolean a=true,b=false,c,d,e;    //  宣告布林變數  a,b,c,d,e
                   c=a&&b;                                  // a,b  兩變數作邏輯  AND  運算
                   d=a|| b;                                    // a,b  兩變數作邏輯  OR  運算
                   e=!a;                                        // a  變數作邏輯  NOT  運算
           }

         例如你想要檢查從感測器傳回的數值是否於  5  到  10，你可以這樣寫：

           #define PWMPin 12
           #define SensorPin 8 void setup()
           {
           }
           void loop()
           {
           int light; int sensor ;
           for (light = 0; light < 255; light++)
           {
           //  忽略數值介於  140  到  200  之間
           sensor = analogRead(SensorPin) ;

           if ((sensor >= 5) && (sensor <=10)) continue;

           analogWrite(PWMPin, light); delay(10);
           }
           }



              這裡有三個運算符號:  交集(and)用  &&    表示;  聯集(or)用  ||  表示;
         反相(finally not)用  !表示。
         複合運算符號：有一般特殊的運算符號可以使程式碼比較簡潔，例如累加運算符號。例如將一個值加
         1，你可以這樣寫:

           int value = 10 ;
           value = value + 1 ;



         你也可以用一個復合運算符號累加(++)：

           Int value = 10 ;
           value ++;



                                                              52]]></page><page Index="62"><![CDATA[2.1.10 複合運算符號

         複合運算子是將運算子與等號結合以簡化運算式。

                                                     表 2.10 複合運算子
                      複合運算子  動作                  範例        說明
                      +=           加             a+=b      與  a=a+b  運算相同
                      -=           減             a-=b      與  a=a-b  運算相同
                      *=           乘             a*=b      與  a=a*b  運算相同
                      /=           除             a/=b      與  a=a/b  運算相同
                      %=           餘數            a%=b      與  a=a%b  運算相同
                      &=           位元  AND       a&=b      與  a=a&b  運算相同
                      |=           位元  OR        a|=b      與  a=a|b  運算相同
                      ^=           位元  XOR       a^=b      與  a=a^b  運算相同

         累加和遞減  (++    和  --)
              當你在累加  1  或遞減  1  到一個數值時。請小心  i++和++i  之間的不同。如果你用的是  i++，i  會
         被累加並且  i  的值等於  i+1；但當你使用++i  時，i  的值等於  i，直到這行指令被執行完時  i  再加  1。
         同理應用於––、+=、-=、*= and /=。當運算式中有超過一個以上的運算子時，就必須考慮到運算的優
         先順序，如果不能確定運算子的優先順序，建議最好使用小括弧  ( )  ，將必須優先運算的運算式先括起
         來，比較不會產生錯誤。

                                                  表 2.11 運算子優先順序

                   優先順序 運算子                                       說明

                           1 ( )                                  括弧
                           2 ~、!                                  補數、NOT  運算
                           3 ++、–                                 遞增、遞減
                           4 *、/、%                                乘、除、餘數
                           5 +、-                                  加、減
                           6 <<、>>                                移位
                           7 <>、<=、>=                             關係
                           8 ==、!=                                相等、不等
                           9 &                                    位元  AND  運算
                          10 ^                                    位元  XOR  運算
                          11 |                                    位元  OR  運算
                          12 &&                                   邏輯  AND  運算
                          13 ||                                   邏輯  OR  運算
                          14 *=、/=、%=、+=、-=、&=、^=、|=              複合運算

         這些運算符號可讓表示式更精簡，下面二個表示式是相同的：
          Int value = 10 ;
          value     = value +5 ;// (此兩者都是相同)
          value     += 5 ;// (此兩者都是相同)






                                                              53]]></page><page Index="63"><![CDATA[2.2 函式(Function)


              所謂函式  （  Function  ）  是指將一些常用的敘述集合起來，並且以一個名稱來代表，如同在組合
         語言中的副程式。  當主程式必須使用到這些敘述集合時，再去呼叫執行此函式，如此不但可以減少程
         式碼的重複，同時也增加了程式的可讀性。  在呼叫執行函式前必須先宣告該函式，傳至函式的引數資
         料形態及函式傳回值的資料形態，都必須與函式原型定義的相同。

         函式原型
              所謂函式原型就是指定傳至函式引數的資料形態與函式傳回值的資料形態，函式原型的宣告包含
         函式名稱、傳至函式的引數資料形態及函式傳回值的資料形態。  當被呼叫的函式必須傳回數值時，函
         式的最後一個敘述必須使用  return  敘述。  使用  retuen  敘述有兩個目的，一是將控制權轉回給呼叫函
         式，另一是將  return  敘述後面小括弧  ＂  ( )  ＂  中的數值傳回給呼叫函式。  return  敘述只能從函式傳
         回一個數值。
           傳回值形態  函數名稱(引數 1 形態  引數 1，  引數 2 形態  引數 2，  引數 3 形態  引數 3，  ....  ，  引
           數 n 形態  引數 n)

         宣告
           void func1(void);          //函式無引數，無傳回值
           void func2(char i);      //函式有  char  形態引數，無傳回值
           char func3(void);          //函式無引數，有  char  形態傳回值
           char func4(char i);      //函式有  char  形態的引數  i  及傳回值

         程式範例：
           void setup() {
           }
           void loop() {
                     int x=5,y=6,sum;          //宣告整數變數  x，y，sum
                     sum=area(x,y);              //呼叫  area（）  函式
           }
           int area(int x,int y) {      //計算面積函式  area（）
                   int s;
                   s=x*y;                                //執行  s=x*y  運算
                   return s;                          //傳回面積  s  值
           }


         2.2.1 輸入輸出腳位設定


         數位訊號輸出/輸入
              PinMode()
              digitalWrite()
              digitalRead()

         類比訊號輸出/輸入
              analogRead()
              analogWrite() - PWM

                                                              54]]></page><page Index="64"><![CDATA[Arduino  內含了一些處理輸出與輸入的切換功能，相信已經從書中程式範例略知一二。

         PinMode(Pin, mode)
              Arduino  的  pinMode()  函式功能是在設定數位輸入  /  輸出腳  ( in / out  ，  簡記  I/O )  的模式，函
         式有二個參數，第一個參數  pin  是定義數位接腳的編號，在  Arduino UNO  開發板上共有編號  0 ~ 13
         等   14  支   數  位    I/O  腳 ， 第 二 個 參 數   mode  是 設 定 接 腳 的 模 式 ， 有   INPUT 、 OUTPUT  及
         INPUT_PULLUP  等三種模式，其中  INPUT  設定接腳為高阻抗  ( high-impedance )  輸入模式，OUTPUT
         設定接腳為輸出模式，INPUT_PULLUP  設定接腳為內含上升電阻  ( internal pull-up resistors )  輸入模
         式。  必須注意的是 Arduino 的指令有大小寫區別，因此函式名稱或參數的大小寫要相同。
           語法
           pinMode( pin , mode )
           參數
           pin  ：  Arduino  開發板上的數位接腳編號。
           mode  ：  INPUT、OUTPUT  或  INPUT_PULLUP。
           回傳：無回傳值

         將數位腳位(digital Pin)指定為輸入或輸出。範例
           #define sensorPin 7

           void setup()
           {
           pinMode(2,INPUT);                            //設定數位接腳  2  為高阻抗輸入模式
           pinMode(3,INPUT_PULLUP);          //設定數位接腳  3  為內含上升電阻輸入模式
           pinMode(13,OUTPUT);                    //設定數位接腳  13  為輸出模式
           PinMode(sensorPin,INPUT);            //  將腳位  sensorPin (7)  定為輸入模式
           }
           void loop()
           {
           }


         digitalWrite(Pin, value)
              Arduino  的  digitalWrite()  函式功能是在設定數位接腳的狀態，函式的第一個參數  pin  是定義數位
         接腳編號，第二個參數  value  是設定數位接腳的狀態，有兩種狀態：一為高態  ( HIGH )，另一為低態
         ( LOW )。
           語法
           digitalWrite( pin, value )
           參數
           pin  ：  Arduino  開發板上的數位接腳編號。
           value  ：  HIGH  或  LOW。

           回傳：無回傳值
              如果所要設定的數位接腳已經由  pinMode()  函式設定為輸出模式，則高態電壓為  5V (  或  3.3V )，
         低態電壓為  0V。將數位腳位指定為開或關。腳位必須先透過  PinMode  明示為輸入或輸出模式
         digitalWrite  才能生效。

                                                              55]]></page><page Index="65"><![CDATA[範  例  :
           #define PWNPin 8

           void setup()
           {
           digitalWrite (PWNPin,OUTPUT); //  將腳位  PWNPin (8)  定為輸出模式
           pinMode(10,OUTPUT);          //設定數位接腳  10  為輸出模式
           digitalWrite(10,HIGH);    //設定數位接腳  10  輸出高態電壓
           }
           void loop()
           {}


         int digitalRead(Pin)
              Arduino  的  digitalRead()  函式功能是在讀取所指定數位接腳的狀態，函式只有一個參數  pin  是在
         定義數位接腳編號，有二種輸入狀態：一為高態  ( HIGH )，另一為低態  ( LOW )。簡單說就是將輸入
         腳位的值讀出，當感測到腳位處於高電位時時回傳  HIGH，否則回傳 LOW。
           語法
           digitalRead( pin )
           參數
           pin  ：  Arduino  開發板上的數位接腳編號。
           回傳：HIGH  或  LOW。

         範  例  :
           #define PWNPin 8
           #define sensorPin 7

           void setup()
           {
           PinMode(sensorPin,INPUT);      //  將腳位  sensorPin (7)  定為輸入模式
           int val = digitalRead(7);              //  讀出腳位  7    的值並指定給  val
           pinMode(13,INPUT);                //設定數位接腳  13  為輸入模式
           val=digitalRead(13);                //讀取數位接腳  13  的狀態，並且將狀態值存入變數  val  中
           }
           void loop()
           {
           }


         int analogRead(Pin)
              讀出類比腳位的電壓並回傳一個  0  到 1023  的數值表示相對應的 0  到 5  的電壓值。
         範  例  :
           #define PWNPin 8
           #define sensorPin 7 void setup()
           {
           PinMode(sensorPin,INPUT); //  將腳位  sensorPin (7)  定為輸入模式
           val = analogRead (7); //  讀出腳位  7    的值並指定給  val


                                                              56]]></page><page Index="66"><![CDATA[}
           void loop()
           {
           }


         analogWrite(Pin, value)
              改變  PWM  腳位的輸出電壓值，腳位通常會在  3、5、6、9、10  與  11。value 變數範圍  0-255，例
         如：輸出電壓  2.5  伏特（V），該值大約是  128。範  例  :
           #define PWNPin 8
           #define sensorPin 7 void setup()
           {
           analogWrite (PWNPin,OUTPUT); //  將腳位  PWNPin (8)  定為輸入模式
           }
           void loop()
           {   }


         2.2.2 進  階  I/O

              tone()
              noTone()
              shiftOut()
              pulseIn()

         tone(Pin)
              使用  Arduino  開發板，使用一個  Digital  Pin(數位接腳)連接喇叭，如本例子是接在數位接腳
         13(Digital Pin 13)，讀者也可將喇叭接在您想要的腳位，只要將下列程式作對應修改，可以產生想要的
         音調。
         範  例  :
           #include <Tone.h> Tone tone1;
           void setup()
           {
           tone1.begin(13); tone1.play(NOTE_A4);
           }

           void loop()
           {
           }



                                                       表2.12 Tone  頻率
                                       常態變數                    頻率(Frequency (Hz))

                                 NOTE_B2                       123
                                 NOTE_C3                       131

                                 NOTE_CS3                      139


                                                              57]]></page><page Index="67"><![CDATA[NOTE_D3                       147
                                 NOTE_DS3                      156

                                 NOTE_E3                       165
                                 NOTE_F3                       175

                                 NOTE_FS3                      185
                                 NOTE_G3                       196
                                 NOTE_GS3                      208

                                 NOTE_A3                       220
                                 NOTE_AS3                      233
                                 NOTE_B3                       247

































































                                                              58]]></page><page Index="68"><![CDATA[常態變數                    頻    率   (Frequency
                                                               (Hz))
                                 NOTE_C4                       262

                                 NOTE_CS4                      277
                                 NOTE_D4                       294

                                 NOTE_DS4                      311
                                 NOTE_E4                       330
                                 NOTE_F4                       349

                                 NOTE_FS4                      370
                                 NOTE_G4                       392

                                 NOTE_GS4                      415
                                 NOTE_A4                       440
                                 NOTE_AS4                      466

                                 NOTE_B4                       494
                                 NOTE_C5                       523
                                 NOTE_CS5                      554

                                 NOTE_D5                       587
                                 NOTE_DS5                      622
                                 NOTE_E5                       659

                                 NOTE_F5                       698
                                 NOTE_FS5                      740

                                 NOTE_G5                       784
                                 NOTE_GS5                      831
                                 NOTE_A5                       880

                                 NOTE_AS5                      932
                                     NOTE_B5                   988

                                     NOTE_C6                   1047
                                     NOTE_CS6                  1109
                                     NOTE_D6                   1175

                                     NOTE_DS6                  1245
                                     NOTE_E6                   1319
                                     NOTE_F6                   1397

                                     NOTE_FS6                  1480
                                     NOTE_G6                   1568
                                     NOTE_GS6                  1661

                                     NOTE_A6                   1760
                                     NOTE_AS6                  1865

                                                              59]]></page><page Index="69"><![CDATA[常態變數                    頻    率   (Frequency
                                                               (Hz))
                                     NOTE_B6                   1976

                                     NOTE_C7                   2093
                                     NOTE_CS7                  2217

                                     NOTE_D7                   2349
                                     NOTE_DS7                  2489
                                     NOTE_E7                   2637

                                     NOTE_F7                   2794
                                     NOTE_FS7                  2960

                                     NOTE_G7                   3136
                                     NOTE_GS7                  3322
                                     NOTE_A7                   3520

                                     NOTE_AS7                  3729
                                     NOTE_B7                   3951
                                     NOTE_C8                   4186

                                     NOTE_CS8                  4435
                                     NOTE_D8                   4699
                                     NOTE_DS8                  4978


         資料來源：
         https://code.google.com/p/rogue-code/wiki/ToneLibraryDocumentation#Ugly_Details

                                              表2.13 Tone  音階頻率對照
                             音階                     常態變數                   頻率(Frequency (Hz))
                             低音  Do            NOTE_C4                                26
                                                                                      2
                             低音  Re            NOTE_D4                                29
                                                                                      4
                             低音  Mi            NOTE_E4                                33
                                                                                      0
                             低音  Fa            NOTE_F4                                34
                                                                                      9
                             低音  So            NOTE_G4                                39
                                                                                      2
                             低音  La            NOTE_A4                                44
                                                                                      0
                             低音  Si            NOTE_B4                                49
                                                                                      4
                             中音  Do            NOTE_C5                                52
                                                                                      3

                                                              60]]></page><page Index="70"><![CDATA[中音  Re            NOTE_D5                                58
                                                                                      7
                             中音  Mi            NOTE_E5                                65
                                                                                      9
                             中音  Fa            NOTE_F5                                69
                                                                                      8












































































                                                              61]]></page><page Index="71"><![CDATA[音階                     常態變數                   頻率(Frequency (Hz))
                             中音  So            NOTE_G5                                78
                                                                                      4
                             中音  La            NOTE_A5                                88
                                                                                      0
                             中音  Si            NOTE_B5                                98
                                                                                      8
                             高音  Do            NOTE_C6                                10
                                                                                      47
                             高音  Re            NOTE_D6                                11
                                                                                      75
                             高音  Mi            NOTE_E6                                13
                                                                                      19
                             高音  Fa            NOTE_F6                                13
                                                                                      97
                             高音  So            NOTE_G6                                15
                                                                                      68
                             高音  La            NOTE_A6                                17
                                                                                      60
                             高音  Si            NOTE_B6                                19
                                                                                      76
                             高高音  Do           NOTE_C7                                20
                                                                                      93
                                                    資料來源：
                      https://code.google.com/p/rogue-code/wiki/ToneLibraryDocumentation#Ugly_Details






























                                                    圖2.7 Tone  接腳

                 資料來源：https://code.google.com/p/rogue-code/wiki/ToneLibraryDocumentation#Ugly_Details



                                                              62]]></page><page Index="72"><![CDATA[圖2.8 Arduino  喇叭接線


                   小星星  音樂範例  :
                    int speakerPin = 9;


                    int length = 15; // the number of notes
                    char notes[] = "ccggaagffeeddc "; // a space represents a rest
                    int beats[] = { 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 4 };
                    int tempo = 300;


                    void playTone(int tone, int duration) {
                        for (long i = 0; i < duration * 1000L; i += tone * 2) {
                            digitalWrite(speakerPin, HIGH);

                            delayMicroseconds(tone);
                            digitalWrite(speakerPin, LOW);
                            delayMicroseconds(tone);
                        }
                    }


                    void playNote(char note, int duration) {

                                                            63]]></page><page Index="73"><![CDATA[char names[] = { 'c', 'd', 'e', 'f', 'g', 'a', 'b', 'C' };

                        int tones[] = { 1915, 1700, 1519, 1432, 1275, 1136, 1014, 956 };

                        // play the tone corresponding to the note name
                        for (int i = 0; i < 8; i++) {

                            if (names[i] == note) {
                                playTone(tones[i], duration);
                            }
                        }

                    }

                    void setup() {
                        pinMode(speakerPin, OUTPUT);

                    }

                    void loop() {
                        for (int i = 0; i < length; i++) {

                            if (notes[i] == ' ') {
                                delay(beats[i] * tempo); // rest
                            } else {
                                playNote(notes[i], beats[i] * tempo);

                            }

                            // pause between notes
                            delay(tempo / 2);

                        }
                    }

                   shiftOut(dataPin, clockPin, bitOrder, value)

                        把資料傳給用來延伸數位輸出的暫存器，函式使用一個腳位表示資料、一個
                   腳位表示時脈。bitOrder  用來表示位元間移動的方式（LSBFIRST  最低有效位元
                   或是 MSBFIRST  最高有效位元），最後  value  會以 byte  形式輸出。此函式通常
                   使用在延伸數位的輸出。

                   範  例  :

                    #define dataPin 8
                    #define clockPin 7 void setup()

                    {

                                                            64]]></page><page Index="74"><![CDATA[shiftOut(dataPin, clockPin, LSBFIRST, 255);

                    }
                    void loop()
                    {    }




                   unsigned long pulseIn(Pin, value)

                        設定讀取腳位狀態的持續時間，例如使用紅外線、加速度感測器測得某一項
                   數值時，在時間單位內不會改變狀態。
                   範  例  :

                    #define dataPin 8

                    #define pulsein 7 void setup()
                    {
                    Int time ;

                    time  =  pulsein(pulsein,HIGH);  //  設  定  腳  位    7  的  狀  態  在  時  間  單  位  內  保  持  為
                    HIGH
                    }
                    void loop()
                    {    }





                   2.2.3 時間函式


                       millis()
                       micros()
                       delay()

                       delayMicroseconds()

                   控制與計算晶片執行期間的時間


                   unsigned long millis()
                   Arduino  的  millis()  函式功能是在測量  Arduino  開發板開始執行至目前為止所
                   經過的時間，這個函式沒有參數，但有一個傳回值，其資料形態為  unsigned long ，
                   可以測量的範圍為  0 ~ ( 232 -1 )，最大約  50  天  (  石英晶體頻率為  16 MHz )。

                   回傳  :  程序開始執行至當前所經過的時間。

                                                            65]]></page><page Index="75"><![CDATA[回傳晶片開始執行到目前的毫秒範例:

                    int  lastTime ,duration;
                    unsigned long time;      //定義資料形態為  unsigned long  的變數。
                    void setup()
                    {

                    lastTime = millis() ;
                    time = millis();            //傳回  Arduino  開發板開始執行至目前為止的時間。
                    }
                    void loop()

                    {
                    duration = -lastTime; //  表示自"lastTime"至當下的時間
                    }


                   micros()
                        Arduino  的  millis()  函式功能是在測量  Arduino  開發板開始執行至目前為
                   止所經過的時間，單位  μs，這個函式沒有參數，但有一個傳回值，其資料形態

                   為  unsigned long  ，可以測量的範圍為  0 ~ ( 232 -1 )，最大約  70  毫秒  (  石英晶
                   體頻率為  16 MHz )。
                   回傳  :  程序開始執行至當前所經過的時間，以微秒為單位  ( unsigned long )。

                   範例

                    unsigned long time;      //定義資料形態為  unsigned long  的變數。
                    void setup()
                    {

                    time = micros();            //傳回  Arduino  開發板開始執行至目前為止的時間。
                    }
                    void loop()
                    {
                    }


                   delay(ms)
                        Arduino  的  delay()  函式功能是在設定毫秒延遲時間，只有一個參數  ms  ，

                   代表設定值為毫秒之意。  ms  參數的資料形態為  unsigned long，可以設定的範
                   圍為  0 ~ ( 232-1 )，最大值可設定約  50  天的延遲。  此函式沒有傳回值。
                   ms  ：  暫停多少毫秒  ( unsigned long )。
                   暫停晶片執行多少毫秒範例:


                    void setup()

                                                            66]]></page><page Index="76"><![CDATA[{

                    Serial.begin(9600);
                    delay(1000);          //設定延遲  1  秒  = 1000  毫秒
                    }
                    void loop()

                    {
                    Serial.print(millis()) ;
                    delay(500); //暫停半秒（500  毫秒）
                    }



                   「毫」是  10  的負  3  次方的意思，所以「毫秒」就是  10  的負  3  次方秒，也就
                   是 0.01 秒。

                                                  表2.14常用單位轉換表
                               符號           中文            英文                 符號意義

                               p            微微            pico               10  的負  12  次方
                               n            奈             nano               10  的負  9  次方

                               u            微             micro              10  的負  6  次方

                               m            毫             milli              10  的負  3  次方
                               K            仟             kilo               10  的  3  次方

                               M            百萬            mega               10  的  6  次方
                               G            十億            giga               10  的  9  次方

                               T            兆             tera               10  的  12  次方

                   delay Microseconds(us)

                        Arduino  的  delayMicroseconds()  函式功能是在設定微秒延遲時間，只有一
                   個參數  μs ，代表微秒之意。  μs  參數的資料形態為  unsigned int，可以設定範圍
                   為  0 ~ ( 216 -1 )，最大可以設定  65  毫秒的延遲。  此函式沒有傳回值。
                   μs  ：  暫停多少微秒  ( unsigned int )。

                   暫停晶片執行多少微秒範例:

                    void setup()
                    {

                    Serial.begin(9600);
                    }
                    void loop()

                    {
                                                            67]]></page><page Index="77"><![CDATA[Serial.print(millis()) ;

                    delayMicroseconds(1000);          //設定延遲  1  毫秒  = 1000  微秒。
                    }



                   2.2.4 數學函式


                       min()
                       max()

                       abs()
                       constrain()
                       map()
                       pow()

                       sqrt()

                   三角函式以及基本的數學運算


                   min(x, y)
                   回傳兩數之間較小者範例：

                    #define sensorPin1 7

                    #define sensorPin2 8 void setup()
                    {
                    int val;

                    PinMode(sensorPin1,INPUT);  //  將     腳  位    sensorPin1  (7)  定 為 輸 入 模 式
                    PinMode(sensorPin2,INPUT);  //  將   腳  位    sensorPin2  (8)  定為輸入模式 val  =
                    min(analogRead (sensorPin1), analogRead (sensorPin2)) ;
                    }
                    void loop()

                    {    }




                   max(x, y)
                   回傳兩數之間較大者範例：


                    #define sensorPin1 7
                    #define sensorPin2 8 void setup()

                                                            68]]></page><page Index="78"><![CDATA[{

                    int val;
                    PinMode(sensorPin1,INPUT);  //  將     腳  位    sensorPin1  (7)  定 為 輸 入 模 式
                    PinMode(sensorPin2,INPUT); //  將腳位  sensorPin2 (8)  定為輸入模式 val = max
                    (analogRead (sensorPin1), analogRead (sensorPin2)) ;

                    }
                    void loop()
                    {    }




                   abs(x)
                   回傳該數的絕對值，可以將負數轉正數。範例：


                    #define sensorPin1 7 void setup()
                    {

                    int val;
                    PinMode(sensorPin1,INPUT); //  將腳位  sensorPin (7)  定為輸入模式
                    val = abs(analogRead (sensorPin1)-500);
                    //  回傳讀值-500  的絕對值
                    }

                    void loop()
                    {    }




                   constrain(x, a, b)
                   判斷  x  變數位於  a  與  b  之間的狀態。x  若小於  a  回傳  a；介於  a  與  b  之間
                   回傳

                   x  本身；大於  b  回傳  b

                   範例：


                    #define sensorPin1 7
                    #define sensorPin2 8
                    #define sensorPin 12 void setup()

                    {
                    int val;

                                                            69]]></page><page Index="79"><![CDATA[PinMode(sensorPin1,INPUT);  //  將     腳  位    sensorPin1  (7)  定 為 輸 入 模 式

                    PinMode(sensorPin2,INPUT);  //  將     腳  位    sensorPin2  (8)  定 為 輸 入 模 式
                    PinMode(sensorPin,INPUT); //  將腳位  sensorPin (12)  定為輸入模式
                    val  =  constrain(analogRead(sensorPin),  analogRead  (sensorPin1),  analogRead
                    (sensorPin2)) ;
                    //  忽略大於  255  的數

                    }
                    void loop()
                    {

                    }




                   map(value, fromLow, fromHigh, toLow, toHigh)
                        將  value  變數依照  fromLow  與  fromHigh  範圍，對等轉換至  toLow  與
                   toHigh  範圍。時常使用於讀取類比訊號，轉換至程式所需要的範圍值。
                   例如：


                    #define sensorPin1 7
                    #define sensorPin2 8
                    #define sensorPin 12 void setup()

                    {
                    int val;
                    PinMode(sensorPin1,INPUT); //  將腳位  sensorPin1 (7)  定為輸入模式

                    PinMode(sensorPin2,INPUT);  //  將     腳  位    sensorPin2  (8)  定 為 輸 入 模 式
                    PinMode(sensorPin,INPUT);  //  將   腳  位    sensorPin  (12)  定為輸入模式 val  =
                    map(analogRead(sensorPin), analogRead (sensorPin1), analogRead
                    (sensorPin2),0,100) ;
                    //  將  analog0  所讀取到的訊號對等轉換至  100  –  200  之間的數值

                    }
                    void loop()
                    {    }




                   double pow(base, exponent)
                   回傳一個數(base)的指數(exponent)值。範例：



                                                            70]]></page><page Index="80"><![CDATA[int y=2;

                    double x = pow(y, 32); //  設定  x  為  y  的  32  次方




                   double sqrt(x)
                   回傳  double  型態的取平方根值。範例：


                    int y=2123;
                    double x = sqrt (y); //  回傳  2123  平方根的近似值





                   2.2.5 三角函式

                       sin()

                       cos()
                       tan()

                   double sin(rad)
                   回傳角度（radians）的三角函式  sine  值。

                   範例：

                    int y=45;

                    double sine = sin (y);   //  近  似  值  0.70710678118654




                   double cos(rad)
                   回傳角度（radians）的三角函式  cosine  值。範例：


                    int y=45;
                    double cosine = cos (y); //  近  似  值  0.70710678118654




                   double tan(rad)
                   回傳角度（radians）的三角函式  tangent  值。範例：

                                                            71]]></page><page Index="81"><![CDATA[int y=45;
                    double tangent = tan (y); //  近  似  值  1





                   2.2.6 亂數函式



                       randomSeed()
                       random()

                   本函數是用來產生亂數用途：

                   randomSeed(seed)
                        事實上在  Arduino  裡的亂數是可以被預知的。所以如果需要一個真正的亂
                   數 ，   可以呼叫此函式重新設定產生亂數種子。你可以使用亂數當作亂數的種子，

                   以確保數字以隨機的方式出現，通常會使用類比輸入當作亂數種子，藉此可以產
                   生與環境有關的亂數。
                   範例：

                    #define sensorPin 7 void setup()

                    {
                    randomSeed(analogRead(sensorPin)); //  使用類比輸入當作亂數種子
                    }

                    void loop()
                    {
                    }




                   long random(min, max)
                   回傳指定區間的亂數，型態為  long。如果沒有指定最小值，預設為  0。範例：


                    #define sensorPin 7 long randNumber; void setup(){
                    Serial.begin(9600);
                    // if analog input Pin sensorPin(7) is unconnected, random analog

                    // noise will cause the call to randomSeed() to generate
                    // different seed numbers each time the sketch runs.

                                                            72]]></page><page Index="82"><![CDATA[//    randomSeed()      will     then     shuffle    the    random      function.

                    randomSeed(analogRead(sensorPin));
                    }
                    void loop() {
                    //  print  a  random  number  from  0  to  299  randNumber  =  random(300);

                    Serial.println(randNumber);
                    // print a random number from     0 to 100
                    randNumber = random(0, 100);      //    回傳  0  –  99  之間的數字
                    Serial.println(randNumber); delay(50);

                    }




                   2.2.7 通訊函式


                        你可以在許多例子中，看見一些使用序列埠與電腦交換資訊的範例，以下是
                   函式解釋。


                   Serial.begin(speed)
                        你可以指定  Arduino  從電腦交換資訊的速率，通常我們使用  9600 bps。當
                   然也可以使用其他的速度，但是通常不會超過  115,200 bps（每秒位元組）。

                   範例：
                    void setup() {
                    Serial.begin(9600); // open the serial port at 9600 bps:

                    }
                    void loop() {
                    }

                   Serial.print(data)

                   Serial.print(data,  格式字串(encoding))
                   經序列埠傳送資料，提供編碼方式的選項。如果沒有指定，預設以一般文字傳送。
                   範例：


                    int x = 0; // variable
                    void setup() {
                    Serial.begin(9600);
                    }



                                                            73]]></page><page Index="83"><![CDATA[void loop() {

                    // print labels Serial.print("NO FORMAT");
                    Serial.print("\t"); Serial.print("DEC");
                    Serial.print("\t"); Serial.print("HEX");
                    Serial.print("\t");

                    Serial.print("OCT");
                    Serial.print("\t");
                    Serial.print("BIN");
                    Serial.print("\t");

                    }




                   Serial.println(data)
                   Serial.println(data, ,格式字串(encoding))
                        與  Serial.print()相同，但會在資料尾端加上換行字元（  ）。意思如同你在鍵
                   盤上打了一些資料後按下  Enter。

                   範例：

                    int x = 0; // variable void setup() {
                    Serial.begin(9600);

                    }
                    void loop() {
                    // print labels

                    Serial.print("NO FORMAT");        // prints a label Serial.print("\t");  // prints a tab
                    Serial.print("DEC");
                    Serial.print("\t");
                    Serial.print("HEX");  Serial.print("\t");  Serial.print("OCT");  Serial.print("\t");
                    Serial.print("BIN");

                    Serial.print("\t");

                    for(x=0; x< 64; x++){

                    Serial.print(x);
                    Serial.print("\t");
                    Serial.print(x, DEC);        // print as an ASCII-encoded decimal Serial.print("\t");
                         // prints a tab
                    Serial.print(x, HEX);        //  print  as  an  ASCII-encoded  hexadecimal

                    Serial.print("\t");  // prints a tab

                                                            74]]></page><page Index="84"><![CDATA[Serial.print(x, OCT);        //  print  as  an ASCII-encoded  octal  Serial.print("\t");

                         // prints a tab
                    Serial.println(x, BIN);  // print as an ASCII-encoded binary
                    //   then adds the carriage return with "println" delay(200);      //  delay  200
                    milliseconds

                    }
                    Serial.println("");  // prints another carriage return
                    }



                   2.2.8 格式字串(encoding)


                        Arduino  的  print()和  println()，在列印內容時，可以指定列印內容使用哪一

                   種格式列印，若不指定，則以原有內容列印。
                   列印格式如下：

                   1.  BIN(二進位，或以  2  為基數)，

                   2.  OCT(八進制，或以  8  為基數)，
                   3.  DEC(十進位，或以  10  為基數)，
                   4.  HEX(十六進位，或以  16  為基數)。



                   使用範例如下：

                       Serial.print(78,BIN)輸出為“1001110＂

                       Serial.print(78,OCT)輸出為“116＂
                       Serial.print(78,DEC)輸出為“78＂
                       Serial.print(78,HEX)輸出為“4E＂




                   對於浮點型數位，可以指定輸出的小數數位。例如


                       Serial.println(1.23456,0)輸出為“1＂
                       Serial.println(1.23456,2)輸出為“1.23＂
                       Serial.println(1.23456,4)輸出為“1.2346＂




                                                            75]]></page><page Index="85"><![CDATA[Print & Println    列印格式(printformat01)


                    /*
                    使用  for  迴圈列印一個數字的各種格式。
                    */
                    int x = 0; //  定義一個變數並賦值


                    void setup() {
                    Serial.begin(9600); ////  打開串口傳輸，並設置串列傳輸速率為  9600

                    }

                    void loop() {
                    ///列印標籤

                    Serial.print("NO FORMAT");
                    Serial.print("\t");
                    Serial.print("DEC");
                    Serial.print("\t");

                    Serial.print("HEX");
                    Serial.print("\t");

                    Serial.print("OCT");

                    Serial.print("\t");

                    Serial.print("BIN"); Serial.print("\t");


                    for(x=0; x< 64; x++){  //  列印  ASCII  碼表的一部分,  修改它的格式得到需要
                    的內容

                    //   列印多種格式：
                    Serial.print(x);    //  以 十 進 位 格 式 將   x  列       印  輸  出    -  與   "DEC" 相   同

                    Serial.print("\t");  //  橫向跳格

                    Serial.print(x, DEC);   //  以十進位格式將  x  列印輸出

                    Serial.print("\t");  //  橫向跳格

                    Serial.print(x, HEX);   //  以十六進位格式列印輸出
                    Serial.print("\t");  //  橫向跳格



                                                            76]]></page><page Index="86"><![CDATA[Serial.print(x, OCT);   //  以八進制格式列印輸出

                    Serial.print("\t");  //  橫向跳格

                    Serial.println(x, BIN);  //  以二進位格式列印輸出
                    //   然後用  "println"列印一個回車
                    delay(200);    //  延  時  200ms

                    }
                    Serial.println("");  //  列印一個空字元，並自動換行
                    }




                   int Serial.available()

                        回傳有多少位元組（bytes）的資料尚未被  read()函式讀取，如果回傳值是  0
                   代表所有序列埠上資料都已經被  read()函式讀取。
                   範例：


                    int incomingByte = 0;  // for incoming serial data void setup() {
                    Serial.begin(9600); // opens serial port, sets data rate to 9600 bps
                    }
                    void loop() {

                    // send data only when you receive data: if (Serial.available() > 0) {
                    // read the incoming byte: incomingByte = Serial.read();
                    // say what you got: Serial.print("I received: ");

                    Serial.println(incomingByte, DEC);
                    }
                    }



                   int Serial.read()
                   以  byte  方式讀取  1byte  的序列資料範例：


                    int incomingByte = 0; void setup() {
                    Serial.begin(9600);
                    }
                    void loop() {

                    // send data only when you receive data:
                    if (Serial.available() > 0) {

                                                            77]]></page><page Index="87"><![CDATA[// read the incoming byte:

                    incomingByte = Serial.read();
                    // say what you got:
                    Serial.print("I received: ");
                    Serial.println(incomingByte, DEC);

                    }
                    }



                   int Serial.write()
                   以  byte  方式寫入資料到序列範例：

                    void setup(){ Serial.begin(9600);

                    }
                    void loop(){
                    Serial.write(45); // send a byte with the value 45

                    int bytesSent = Serial.write("hello Arduino , I am a beginner in the Arduino world");
                    }



                   Serial.flush()
                        有時候因為資料速度太快，超過程式處理資料的速度，你可以使用此函式清
                   除緩衝區內的資料。經過此函式可以確保緩衝區(buffer)內的資料都是最新的。
                   範例：


                    void setup(){ Serial.begin(9600);
                    }
                    void loop(){

                    Serial.write(45); // send a byte with the value 45
                    int bytesSent = Serial.write("hello Arduino , I am a beginner in the Arduino world");
                    Serial.flush();
                    }




                   2.2.9 系統函式


                   Arduino  開發版也提供許多硬體相關的函式：


                                                            78]]></page><page Index="88"><![CDATA[系統  idle  函式

                        使用硬體  idle  功能，可以讓  Arduin  進入睡眠狀態，連單晶片都可以進入
                   睡眠狀態，但使用本功能需要使用外掛函式  Enerlib  函式庫，讀者可以到
                   Arduino  官網：  http://playground.arduino.cc/Code/Enerlib，下載其函式庫安裝，或
                   到本書範例檔：  https://github.com/brucetsao/arduino_RFProgramming，下載相關
                   函式與範例。

                        ATMega328  微控器具有六種睡眠模式，底下是依照「省電情況」排列的睡
                   眠模式名稱，以及  Enerlib（註：Energy  和  Library，即：「能源」和「程式庫」
                   的縮寫）程式庫的五道函數指令對照表，排越後面越省電。「消耗電流」欄位指

                   的是 ATmega328  處理器本身，而非整個控制板(趙英傑, 2013, 2014)。
                                       表2.15 ATMega328  微控器六種睡眠模式


                    睡眠模式                 Energy  指令           中文直譯                消耗電流

                    Idle                 Idle()               閒置                  15mA

                    ADC Noise Reduc-                          類比數位轉換器
                                         SleepADC()                               6.5mA
                    tion                                      降低雜訊


                    Power-save           PowerSave()          省電                  1.62mA
                    Standby              Standby()            待機                  1.62mA

                    Extended Standby                          延長待機                0.84mA

                    Power-down           PowerDown()          斷電                  0.36mA


                        微控器內部除了中央處理器（CPU），   還有記憶體、類比數位轉換器、序列
                   通訊…等模組。越省電的模式，仍在運作中的模組就越少。


                        例如，在＂Power-Down＂（電源關閉）睡眠模式之下，微控器僅剩下外部中
                   斷和看門狗計時器（Watchdog Timer）仍持續運作。而在  Idle  睡眠模式底下，SPI,
                   UART（也就是序列埠）、計時器、類比數位轉換器等，仍持續運作，只有中央處

                   理器和快閃記憶體（Flash）時脈訊號被停止。
                   時脈訊號就像心跳一樣，一旦停止時脈訊號，相關的元件也隨之暫停。
                   範例：


                    Arduin  進入睡眠狀態範例(
                    /*
                    Enerlib: easy-to-use wrapper for AVR's Sleep library.
                    By E.P.G. - 11/2010 - Ver. 1.0.0



                                                            79]]></page><page Index="89"><![CDATA[Example showing how to enter in Idle mode and exit from it with INT0.

                    */

                    #include <Enerlib.h>


                    Energy energy;

                    void INT0_ISR(void)
                    {


                    /*
                    The WasSleeping function will return true if Arduino was sleeping before the IRQ.
                    Subsequent calls to WasSleeping will return false until Arduino reenters

                    in a low power state. The WasSleeping function should only be called in the ISR.
                    */
                    if (energy.WasSleeping())
                    {

                    /*
                    Arduino was waked up by IRQ.

                    If you shut down external peripherals before sleeping, you can reinitialize them here.

                    Look  on  ATMega's  datasheet  for  hardware  limitations  in  the  ISR  when
                    microcontroller just leave any low power state.
                    */
                    }

                    else
                    {
                    /*
                    The IRQ happened in awake state.


                    This code is for the "normal" ISR.
                    */
                    }

                    }

                    void setup()
                    {

                    Serial.begin(9600); Serial.println("Program Start") ;

                                                            80]]></page><page Index="90"><![CDATA[attachInterrupt(0, INT0_ISR, LOW);

                    /*
                    Pin 2 will be the "wake button". Due to uC limitations, it needs to be a level interrupt.
                    For experienced programmers:
                    ATMega's datasheet contains information about the rest of wake up sources. The

                    Extended Standby is not implemented.
                    */

                    Serial.println("Now I am Sleeping") ; delay(500);

                    energy.Idle();
                    }

                    void loop()

                    {

                    Serial.println("I am waken ") ; delay(1000);
                    }



                   attachInterrupt(插斷)
                        當開發者攥寫程式時，在  loop()程式段之中，攥寫許多大量的程式碼，並且

                   重覆的執行，當我們需要在某些時後去檢查某一樣硬體，如按鈕、讀卡機、RFID、
                   鍵盤、滑鼠等周邊裝置，若這些檢查、讀取該周邊的函式，寫在  loop()程式段之
                   中，  則必需每一個迴圈都必需耗時去檢查，不但造成程式不順暢，還會錯失讀
                   取這些檢查、讀取該周邊的函式的時機。

                        這時後我們就需要用到這些  Arduino  開發板外部插斷接腳，由於  Arduino
                   開發板使用外部插斷接腳，不同開發板其接腳都不太相同，我們可以參考表  6  之
                   Arduino  開發板外部插斷接腳對照表。


                                       表2.16 Arduino  開發板外部插斷接腳對照

                                         Board     int   int   int    int   int   int
                                                   .0    .1    .2     .3    .4    .5

                                    Uno,          2     3
                                    Ethernet

                                    Mega2560      2     3      21     20    19    18
                                    Leonardo      3     2      0     1     7



                                                            81]]></page><page Index="91"><![CDATA[attachInterrupt(第幾號外部插斷,  執行之函式名稱, LOW/HIGH);


                   參數解說：

                        第  一  個  參  數  ：  使  用  那  一  個  外  部  插  斷  ，  其  接  腳  請  參  考  參  考  表    6  之

                   Arduino
                   開發板外部插斷接腳對照表。


                        第二個參數：為執行之函式名稱；在  Arduino  程式區自行定義一個若
                   使用插斷後，執行的函式名稱
                        第三個參數：驅動外部硬體插斷所使用的電位，  HIGH  表高電位，
                   LOW  表低電位


                   範例：
                    外部插斷測式程式(IRQTest)
                    void setup() {

                    // put your setup code here, to run once:
                    Serial.begin(9600); Serial.println("Program Start") ;
                    attachInterrupt(0, TheButtonPressed, LOW);
                    }


                    void loop() {
                    //  put  your  main  code  here,  to  run  repeatedly:  Serial.print("now  program  run  in
                    loop()");

                    }

                    void TheButtonPressed()
                    {

                    Serial.println("The Button is pressed by user") ;
                    }

                   Wire

                        Wire庫可以讓Arduino與IIC / TWI設備進行通信。  與SPI匯流排一樣，
                   IIC也是主從方式通訊，因此不能同時存在兩個主設備，只能是一個主設備
                   與一個或多個從設備進行通訊。使用之前使用以下語句進行Wire庫聲明。
                   其相關介紹可參照官網(https://www.arduino.cc/en/Reference/Wire)。


                    #include <Wire.h>

                                                            82]]></page><page Index="92"><![CDATA[表2.17，顯示了TWI引腳在各種Arduino板上的位置。

                   (在Arduino UNO板上，SDA（資料線）和SCL（時鐘線）位於靠近AREF引
                   腳上面的引腳。)

                                                 表2.17 I2C / TWI pins
                                   Board          I2C / TWI pins
                                   Uno, Ethernet A4 (SDA), A5 (SCL)

                                   Mega2560       20 (SDA), 21 (SCL)
                                   Leonardo       2 (SDA), 3 (SCL)
                                   Due            20 (SDA), 21 (SCL), SDA1, SCL1


                        從Arduino 1.0開始，Wire庫繼承Stream流，使其與其他讀/寫的庫一致。
                   因此現在send()和receive()已被read()和write()取代。一般來說I2C地址有7位

                   和8位的版本。  7位元是設備標識碼，而第8位元則是為了確認設備當前狀
                   態是正在寫入還是讀取。  而Arduino -Wire庫始終使用的是7位位址。如果
                   您使用了8位元元，則需要刪除低位元元，從而得到0到127之間的地址。但
                   是，位址從0到7  被保留了,  因此您在開發的時候請不要使用它們!!!  可以
                   從8開始使用。

                        請注意，連接SDA / SCL引腳時需要一個上拉電阻。  此外MEGA 2560
                   開發板上引腳20-21具有上拉電阻。Wire庫的實現使用了32位元組緩衝區，
                   因此任何通信都必須在此限制之內。  單次傳輸中超出的位元組將被丟棄。


                   Wire 函式庫包含以下:
                   –  begin
                   –  requestFrom

                   –  beginTransmission
                   –  endTransmission
                   –  write

                   –  available
                   –  read
                   –  SetClock
                   –  onReceive
                   –  onRequest


                   begin
                   初始化 Wire 庫，並以主機或從機身份加入 I2C 匯流排。通常來說這個函數

                   只調用一次。

                   語法
                                                            83]]></page><page Index="93"><![CDATA[Wire.begin()
                    Wire.begin(address)
                   參數
                   address（可選）:7 位從機的地址；  如果這個參數未指定，則預設以主機身
                   份加入匯流排。

                   注:位址從 0 到 7  被保留了,  因此您在開發的時候請不要使用它們!!!  可以
                   從 8 開始使用。
                   回傳值:無


                   requestFrom
                        由主設備用來向從設備請求位元組。請求發送之後可以使用 available()
                   和 read()來接受並讀取數據。從 Arduino 1.0.1 開始，requestFrom()接受一
                   個布林參數來適配某些 I2C 設備來達到相容的目的。

                   如果為 true，則 requestFrom()在請求之後發送停止消息，從而釋放 I2C 匯
                   流排。
                   如果為 false，則 requestFrom()在請求之後發送重啟消息。

                   匯流排不會釋放，這個操作就阻止了另一個主設備在消息之間請求。  這樣
                   一來，一台主設備就可以在控制下發送多個請求。
                   預設值是 true。

                   語法

                    Wire.requestFrom(address, quantity)
                    Wire.requestFrom(address, quantity, stop)


                   參數
                   address:  設備的 7 位元位址，用於請求位元組
                   quantity:  請求的位元組數
                   stop (bool):  值為 true 則在請求後發送停止消息，釋放匯流排。值為  false

                   則在請求後發送重啟資訊，以保持連接處於活動狀態。
                   返回數值型別  :byte
                   返回從設備回應的位元組數


                   beginTransmission
                        使 用 指 定 的 位 址 開 始 向 I2C 從 設 備 進 行 傳 輸 。 在 調 用 了
                   Wire.beginTransmission(address)函數之後，使用 write()函數對要傳輸的位元
                   組進行佇列，並通過調用 endTransmission()進行傳輸。

                   語法
                    Wire.beginTransmission(address)

                                                            84]]></page><page Index="94"><![CDATA[參數
                   address:  要傳輸資料的目的設備的 7 位元位址
                   回傳值:無


                   endTransmission
                   停止與從機的資料傳輸

                   語法

                    Wire.endTransmission()
                    Wire.endTransmission(stop)

                   參數

                   stop(bool):  參數值為 true 時將在請求後發送停止指令並釋放匯流排;參數
                   值為 false 時將在請求後發送重新開機的指令，保持連接狀態。
                   返回數值型別:byte

                   返回傳輸的狀態值：
                   0:  成功
                   1:  資料量超過傳送緩存容納限制
                   2:  傳送位址時收到  NACK
                   3:  傳送資料時收到  NACK

                   4:  其它錯誤

                   write

                        對於從設備來說: write()用於回應來自主設備的請求，即從設備寫入資
                   料。對於主設備來說: write()將資料進行佇列，用以從主設備傳輸到從設備，
                   這個函數通常在 beginTransmission()和 endTransmission()之間進行調用。

                   語法

                    Wire.write(value)
                    Wire.write(string)
                    Wire.write(data, length)


                   參數
                   value:  一個要發送的單字節
                   string:  一系列要發送的字串

                   data:  要作為位元組發送的陣列資料
                   length:  要傳輸的位元組數

                                                            85]]></page><page Index="95"><![CDATA[返回數值型別  : byte

                   write()將返回寫入的位元組數，雖然讀取這個回傳值是不必要的。

                   available
                        available()  函數可用於檢查是否接收到資料。該函數將會返回等待讀

                   取的資料位元組數。應該在調用 requestFrom()之後再在主設備上調用此函
                   數，或者在從設備的 onReceive()的事件處理函數內的調用此函數。詳情參
                   考主設備讀取,從設備發送和主設備寫入，從設備接受 available()函數屬於
                   Stream 類。該函數可被 Stream 類的子類所使用，如（Serial, WiFiClient, File

                   等）。

                   語法
                    Wire.available()


                   參數無
                   回傳值:返回緩衝區中可讀取的位元組數。


                   read
                        讀取在 requestFrom()調用後從從設備回應發送到主設備的位元組，或
                   從主設備發送到從設備的位元組。本函數屬於 Stream 類。該函數可被
                   Stream 類的子類所使用，如（Serial, WiFiClient, File  等）。


                   語法
                    Wire.read（）


                   參數:無
                   回傳值:讀取的下一個字元，回傳值為接讀取到的資料流程中的 1 個字元。
                   如果沒有資料時，回傳值為-1。


                   SetClock
                        SetClock()函數用於修改 I2C 通信的時鐘頻率。I2C 從設備沒有最低的工
                   作時鐘頻率，但是通常以 100KHz 為基準。


                   語法
                    Wire.setClock（clockFrequency）


                   參數
                   clockFrequency：所需通信時鐘的值（以赫茲為單位）。可接受的值為 100000

                                                            86]]></page><page Index="96"><![CDATA[（標準模式）和 400000（快速模式）。一些處理器還支援 10000（低速模

                   式），1000000（加快速模式）和 3400000（高速模式）。請參考特定的處理
                   器文檔，以確保支援所需的模式。
                   回傳值:無


                   onReceive
                   當從設備接收到來自主機的傳輸時，註冊要調用的函數。

                   語法

                    Wire.onReceive(handler)

                   參數
                   handler：從機接收資料時要調用的函數；這個函數應該使用一個 int 參數

                   （用於從主設備讀取位元組數），並且這個函數不應返回任何內容，
                   例如：  void myHandler(int numBytes)
                   回傳值:無


                   onRequest
                   當主設備請求從從設備發送資料時，從設備通過 onRequest 設置調用的函
                   數。


                   語法
                    Wire.onRequest(handler)


                   參數
                   handler：當主設備請求從從設備發送資料時，從設備要調用的函數。此函
                   數不帶參數，不返回任何值，例如：  void myHandler()
                   回傳值:無


                   兩塊 UNO 通過 IIC 進行板間通訊
                   主設備讀取，從設備發送。在這個示例中，將使用兩塊開發板通過 I2C 通訊協定
                   在主設備讀取/從設備發送的方式進行通信。


                   Arduino UNO 主設備通過使用 Wire 庫,  可以請求並讀取從唯一定址的從設備
                   Arduino UNO 發送來的 6 位元組資料。  收到該消息後，便可以在 Arduino IDE
                   串口監視器窗中進行查看。


                   電路連接

                                                            87]]></page><page Index="97"><![CDATA[將主設備開發板的引腳 4（或 SDA 資料引腳）和引腳 5（或 SCL 時鐘引腳）連

                   接到從設備開發板的對應引腳上。如圖 2.9 所示，電路圖以兩塊 UNO 為例進行
                   連接。為了保證串口通信的運行，必須通過 USB 將開發板連接到電腦上並保證
                   各個開發板的供電。






















                                                 圖 2.9  連接兩塊 UNO

                   主設備讀取

                    //  引入 Wire 庫文件
                    #include <Wire.h>

                    void setup()

                    {
                            // Wire 初始化,  加入 i2c 匯流排
                            //  如果未指定，則以主機身份加入匯流排。
                            Wire.begin();

                            //  初始化串口並設置串列傳輸速率為 9600
                            Serial.begin(9600);
                    }


                    void loop()
                    {
                            //  向從設備＃8 請求 6 個位元組
                            Wire.requestFrom(8, 6);

                            //  當從從設備接收到資訊時值為 true
                            while (Wire.available())
                            {
                                    //  接受並讀取從設備發來的一個位元組的資料

                                    char c = Wire.read();

                                                            88]]></page><page Index="98"><![CDATA[//  向串口列印該位元組

                                    Serial.print(c);
                            }
                            //  延時 500 毫秒
                            delay(500);

                    }

                   從設備發送
                    //  引入 Wire 庫文件

                    #include <Wire.h>

                    void setup()
                    {

                            // Wire 初始化,  並以從設備位址#8 的身份加入 i2c 匯流排
                            Wire.begin(8);
                            //  註冊請求回應事件

                            Wire.onRequest(requestEvent);
                    }

                    void loop()
                    {

                            delay(100);
                    }


                    //  每當接收到來自主機的資料時執行的事件函數
                    //  此函數被註冊為事件，調用請見 setup（）
                    void requestEvent()
                    {
                            //  用 6 個位元組的消息進行回應

                            Wire.write("hello ");
                            //  以此回應主設備的請求
                    }



                   主設備寫入,  從設備接受
                   在這個示例中，將使用兩個開發板通過 I2C 同步串列協定以主機寫入從機接受的
                   方式相互通信。



                                                            89]]></page><page Index="99"><![CDATA[Arduino UNO（主設備）經過程式設計，每半秒向唯一定址的從設備發送 6 個位

                   元組的資料。  從設備收到該消息後，可以在 Arduino IDE  的串口監視器視窗中
                   查看該資料。

                   主設備寫入
                    //  引入 Wire 庫文件

                    #include <Wire.h>

                    void setup()

                    {
                            // Wire 初始化,  加入 i2c 匯流排
                            //  如果未指定，則以主機身份加入匯流排。
                            Wire.begin();

                    }

                    //  定義一個 byte 變數以便串口調試
                    byte x = 0;


                    void loop()
                    {
                            //  將資料傳送到從設備＃8

                            Wire.beginTransmission(8);
                            //  發送 5 個位元組
                            Wire.write("x is ");
                            //  發送一個位元組

                            Wire.write(x);
                            //  停止傳送
                            Wire.endTransmission();


                            x++;
                            delay(500);
                    }


                   從設備接受
                    //  引入 Wire 庫文件
                    #include <Wire.h>


                    void setup()

                                                            90]]></page><page Index="100"><![CDATA[{

                            // Wire 初始化,  並以從設備位址#8 的身份加入 i2c 匯流排
                            Wire.begin(8);
                            //  註冊接受事件函數
                            Wire.onReceive(receiveEvent);
                            //  初始化串口並設置串列傳輸速率為 9600

                            Serial.begin(9600);
                    }


                    void loop()
                    {
                            delay(100);
                    }


                    //  每當接收到來自主機的資料時執行的事件函數
                    //  此函數被註冊為事件，調用請見 setup（）
                    void receiveEvent(int howMany)

                    {
                            //  迴圈讀取資料(除了最後一個字元)
                            while (1 < Wire.available())
                            {
                                    //  接收位元組資料並賦值給變數 c(char)

                                    char c = Wire.read();
                                    //  列印該位元組
                                    //太極創客團隊  / Taichi-Maker (www.taichi-maker.com)

                                    Serial.print(c);
                            }
                            //  以 int 整數的形式接受位元組資料並賦值給 x(int)
                            int x = Wire.read();
                            //  列印該 int 變數 x

                            Serial.println(x);
                    }













                                                            91]]></page><page Index="101"><![CDATA[CH 3  智慧農場專案









































                   3.1 專案概述



                        本專案透過 DHT 溫、濕度感測器，檢測植物水耕棉的濕度與溫度，當植物
                   的濕度不足時將啟動抽水馬達替植物澆水，取代了人工澆水的行為。此外，也有
                   設計水位感測器，當給植物澆種的水不足時會透過 Wifi 模組提醒栽種者須將水
                   箱填滿水，栽種者不必時刻盯著植物查看供水量是否不足，另透過 App 與雲端

                   系統也可不必猜測植物濕度是否不足。



























                                                            92]]></page><page Index="102"><![CDATA[3.2 系統架構



































                                                    圖 3.1 系統架構

                        依據系統架構，如圖 3.1，可知其功能：透過 DHT11 溫溼度感測器偵測，當
                   空氣、溫度或土壤過於乾燥時，Arduino 打開 Relay 自動抽水灌溉。此外，使用

                   者亦可於雲端或使用 App 查看目前溫、濕度與水位的曲線圖並開啟灌溉或關閉，
                   而系統只在土壤溼度過乾或溫度太高時決定是否灌溉，其餘時段則停止自動灌
                   溉，當儲存的水位經水位偵測器偵測到不足時，使用者可從 App 上得知。


                   3.3  技術說明



                        本專案開發工具與環境如 3.1 表，以 C 語言在 Arduino IDE 開發主要控制程

                   式，並經 ESP8266 Wifi 以 Get 傳輸方式傳輸資料至伺服器上。伺服器以 apache、
                   mysql 及 php 搭建環境，伺服器端前端網頁則再搭配 HTML5、Java Script、jQuery
                   等語言呈現曲線圖。最後再以 Thunkable 構建 webview 框架，將所撰寫的 RWD
                   前端網頁建置於框架內。












                                                            93]]></page><page Index="103"><![CDATA[表 3.1  智慧農場開發環境

                    開發程式語言與 本系統應用採用 C、HTML5、Java Script、jQuery、PHP 等
                    技術                  開發語言完成

                    資料交換技術              Post/Get  傳輸
                    系統開發工具              Ardunio Sketch、Notpad++、Thunkable

                    作業系統軟體              Win10、Android、iOS
                    Web Server          apache
                    DB Server           mysql


                   3.4  硬體接線




                        本專案硬體接線如圖 3.2 所示，Arduino 腳位 2、3 與 ESP8266 Tx、Rx 連接。
                   腳位 4 則可連接光敏電阻(搭建植物燈使用)。腳位 8 則與 Relay 的 S 訊號腳位連
                   接，用以控制 Relay 上的動作，而 Relay 上外電 7-12V 接 Relay 上的 COM 孔，
                   NO 孔接抽水馬達的正極。腳位 9 與 DHT 11  訊號 S 腳位連接，腳位 10 與 11 則

                   分別與開關按鈕連接，按鈕為配合抽水馬達故加上 220Ω，以配合手動控制抽水
                                                                                   2
                   馬達。A0 腳位接水位偵測器，A4、A5 分別接 LCD 1206 上 I C SDA 與 SCL 腳
                   位 。 5V 電分別接給 Relay、LCD 1206。3V 電則接給 DHT 11、水位偵測器、ESP8266。

                   GND 則與各元件共地使用。完成接線後如圖 3.3 所示，Arduino 電源可以電池驅
                   動，其相關元件可參照 BOM 表 3.2。

































                                                圖 3.2 智慧農場硬體接線


                                                            94]]></page><page Index="104"><![CDATA[圖 3.3 BOM 表電子零件組裝完成


                                                 表 3.2 智慧農場 BOM
                               名稱                  用量                   說明
                               Ardunio Uno         1                    主機板

                               LCD 1602            1                    LCD 顯示幕
                               DHT 11              1                    溫、濕感測器
                               Funduino            1                    水位偵測器

                               Relay               1                    單路繼電器
                               ESP8266 12F         1                    Wifi 模組
                               按鍵                  2                    手控按鈕

                               電阻 220Ω             1                    ESP8266 EN 用
                               電阻  10K             1                    ESP8266 GND 用
                               電阻  1K              2                    按鍵用

                               抽水馬達                1
                               水管                  2                    一入、一出
                               控制盒                 1
                               水箱                  1

                               水耕棉                 1
                               育苗網                 1




                                                            95]]></page><page Index="105"><![CDATA[3.5  元件介紹























                                                  圖 3.4 Arduino UNO

                        Arduino UNO 為一款基於 ATmega328P  的微控制器板。  它擁有 14  個數位
                   輸入/  輸出接腳（其中 6  個可用作 PWM  輸出），6  個類比輸入，16 MHz 石英晶
                   體，USB  連接孔，電源插孔，ICSP  接頭與重置按鈕，可通過  USB  連接或外部
                   電源供電。

                   3.5.1 LCD 1602 顯示幕















                                                    圖 3.5 LCD1602
                        圖 3.5 為 LCD 1602 顯示幕，1602 為基本液晶模組，其中 16 表示一行顯示
                   16 個字元，02  表示顯示  2  行。1602  也就是表示  2 行，每行  16 個字元的液晶
                   模組，而 1602 前面的字母表示廠家名稱。黑屏白字之顯示效果較佳，有背光的

                   液晶模組則表示背光板電源後螢幕有底光，雖然顯示效果較好，但代價是自身功
                   率耗能較大，相比於無背光板的模組較薄，不適合在光線較暗的環境中使用。顯
                                            2
                   示器背面的  LCM1602 I C 控制板有四個針腳，分別為  GND、VCC、SDA  與
                           2
                   SCL。I C 能夠讓兩個裝置之間以穩定、高速、雙向的方式及最少的 I/O 引腳的
                   情形來進行通訊。因為它使用兩條線來進行通訊，一條時脈線（SCL）和一條數
                                        2
                   據線（SDA），所以 I C 所使用的通訊協定也被稱之為「雙線」通訊協定。比較特
                             2
                   別的是，I C 允許多個從屬裝置能共享同條通訊線路，但也就因為如此，開啟通
                                     2
                   訊的功能則是由 I C 主體來控制要與誰通訊。因此 Arduino 的接線為 VCC  接到
                   5V，GND  接到  GND，SDA  接到 Arduino SDA(A4)，SCL  接到  Arduino SCL(A5)。


                                                            96]]></page><page Index="106"><![CDATA[在使用 LCD 1602 時須先安裝  LiquidCrystal  函式庫，下載之後解壓縮到

                   Arduino  的  libraries  目錄中即可。
                    #include <Wire.h>    // Arduino IDE  內建
                    // LCD I2C Library，可從這裡可以下載：
                    // https://bitbucket.org/fmalpartida/new-liquidcrystal/downloads


                    #include <LiquidCrystal_I2C.h>

                    // Set the pins on the I2C chip used for LCD connections:

                    // addr, en,rw,rs,d4,d5,d6,d7,bl,blpol
                    LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);    //  設定  LCD I2C
                    位址


                    void setup() {
                        Serial.begin(115200);    //  用於手動輸入文字
                        lcd.begin(16, 2);            //  初始化  LCD，一行  16  的字元，共  2  行，預設開
                    啟背光


                        //  閃爍三次
                        for(int i = 0; i < 3; i++) {
                            lcd.backlight(); //  開啟背光

                            delay(250);
                            lcd.noBacklight(); //  關閉背光
                            delay(250);
                        }

                        lcd.backlight();

                        //  輸出初始化文字
                        lcd.setCursor(0, 0); //  設定游標位置在第一行行首

                        lcd.print("Hello, world!");
                        delay(1000);
                        lcd.setCursor(0, 1); //  設定游標位置在第二行行首
                        lcd.print("GTWang.org");

                        delay(8000);

                        //  告知使用者可以開始手動輸入訊息
                        lcd.clear();

                        lcd.setCursor(0, 0);

                                                            97]]></page><page Index="107"><![CDATA[lcd.print("Use Serial Mon");

                        lcd.setCursor(0, 1);
                        lcd.print("Type to display");
                    }


                    void loop() {
                        //  當使用者手動輸入訊息
                        if (Serial.available()) {
                            //  等待一小段時間，確認資料都接收下來了

                            delay(100);
                            //  清除舊訊息
                            lcd.clear();
                            //  讀取新訊息

                            while (Serial.available() > 0) {
                                //  將訊息顯示在  LCD  上
                                lcd.write(Serial.read());
                            }

                        }
                    }
                                                          2
                   注意:  當初次使用時若無法顯示，則 I C 背後有一個藍色的可調電阻旋鈕，向左
                   或向右，試著調整就可顯示，其原因可能是 LCD 1206 出廠時亮度值太高或太低。



                   3.5.2 DC-5V Relay  單路繼電器

























                                                   圖 3.6 DC-5V Relay


                        Arduino Uno 只能提供 5V 或 3.3V 的直流電給外部設備，若是我們需要更高

                                                            98]]></page><page Index="108"><![CDATA[電壓或是交流電，像是要控制電風扇、檯燈，這時就必須靠繼電器(Relay)了。繼

                   電器一般會分兩邊，一邊各 3 個接腳。PIN 腳的那邊是用來和 Arduino 溝通的，
                   +就是 VCC，-就是 GND，IN 則是訊號線，我們可以透過這個訊號線來控制繼電
                   器的開或關。

                   另一邊則是電源線的接腳：

                   NO：Normal Open，常開，正常情況是不通電的。
                   COM：Common Ground，共接電，習慣上把外電接到這個接腳，再從 NO 或 NC
                   接到設備上。

                   NC：Normal Close，常閉，在正常情況下是接通的。
                   NO 和 NC 一次只會選擇接一個，至於要接哪一個，要看實際的情況。


























                                                    圖 3.7 Relay 接線


                        圖 3.7 為使用 Relay 之接線範例，利用 Arduino 3.3V 模擬外電等亮 LED。將
                   Arduino 的腳位 7 接至 Relay 的訊號(S)上，Relay 正極(+)接至 Arduino 5V，負極
                   (-)接至 Arduino 的 GND。Arduino 3.3V 接至 Relay COM，NO 接至 LED。
                    void setup() {

                        pinMode(7,OUTPUT);
                    }

                    void loop() {

                        digitalWrite(7,HIGH);
                        delay(2000);
                        digitalWrite(7,LOW);
                        delay(1000);

                    }

                                                            99]]></page><page Index="109"><![CDATA[3.5.3 Funduino - Water Sensor  水位偵測器









































                                             圖 3.8 Funduino - Water Sensor


                        圖 3.8 為 Funduino - Water Sensor  水位偵測器，為一款簡單易上手、性價比
                   較高之水位/水滴識別檢測傳感器，其通過具有一系列的暴露的平行導線之線跡
                   測量其水滴/水量大小從而判斷水位。輕鬆完成水量到模擬信號的轉換，輸出所

                   得出之模擬值可直接被 Arduino 開發板讀取，達到水位報警的功效。
                    void setup()
                    {
                      Serial.begin(9600);


                    }

                    void loop()

                    {
                      Serial.println(analogRead(A0));
                      delay(100);
                    }



                                                           100]]></page><page Index="110"><![CDATA[3.5.4 DC3~5V 之水泵(抽水馬達)



















                                           圖 3.9 DC3~5V 之水泵(抽水馬達)

                        圖 3.9 所示為 DC3~5V 之水泵(抽水馬達)，水泵只有兩條電線，一條接  5V

                   一條接  GND，通電之後就會啟動內部的馬達開始抽水，所以在電路上使用一個
                   繼電器作為開關，透過網頁控制繼電器，就可以啟動水泵或關閉水泵。我們亦可
                   稱之為「幫浦」，透過馬達的加壓，可以做到一個管子抽水，接著從另一個管子
                   放水的動作。


                   3.5.5  按鈕開關



















                                                    圖 3.10 按鈕開關


                        圖 3.10 所示為按鈕開關，用途多元，可控制 LED 燈亮燈滅、亮滅順序、各
                   式操作指令執行，抑或是程式啟動與否等。














                                                           101]]></page><page Index="111"><![CDATA[3.5.6 DHT 11  溫、濕感測器














































                                            圖 3.11 DHT11 溫、濕度感測器

                        DHT11 溫、濕度感測器，如圖 3.11 所示，為一款含有已校準數字信號輸出

                   的溫濕度復合傳感器，它應用專用的數字模塊采集技術和溫濕度傳感技術，以確
                   保產品具有極高的可靠性和卓越的長期穩定性。傳感器包括一個電阻式感濕元件
                   和一個NTC測溫元件，並與一個高性能 8 位單片機相連接，其接線請參照圖 3.12。
                   供電電壓：3.3~5.5V DC
                   輸出：單總線數字信號

                   測量範圍：濕度 20-90%RH，溫度 0~50℃

















                                                           102]]></page><page Index="112"><![CDATA[圖 3.12 DHT11 接線

                   使用步驟:
                   Step1.匯入 DHT11 程式庫，如圖 3.13 所示，草稿碼->匯入程式庫->管理程式庫






















                                                  圖 3.13 DHT11 匯入

                   Step2.  如圖 3.14 所示，在上方搜尋輸入"DHT"，選擇 DHT sensor library 進行安
                   裝，安裝完成就可使用 DHT11 程式庫。




















                                                           103]]></page><page Index="113"><![CDATA[圖 3.14 DHT 程式庫管理


                    #include "DHT.h"
                    #define dhtPin 8            //讀取 DHT11 Data
                    #define dhtType DHT11 //選用 DHT11


                    DHT dht(dhtPin, dhtType); // Initialize DHT sensor

                    void setup() {

                        Serial.begin(9600);//設定鮑率 9600
                        dht.begin();//啟動 DHT
                    }


                    void loop() {
                        float h = dht.readHumidity();//讀取濕度
                        float t = dht.readTemperature();//讀取攝氏溫度
                        float f = dht.readTemperature(true);//讀取華氏溫度

                        if (isnan(h) || isnan(t) || isnan(f)) {
                            Serial.println("無法從 DHT 傳感器讀取！");
                            return;
                        }
                        Serial.print("濕度: ");


                                                           104]]></page><page Index="114"><![CDATA[Serial.print(h);

                        Serial.print("%\t");
                        Serial.print("攝氏溫度: ");
                        Serial.print(t);
                        Serial.print("*C\t");
                        Serial.print("華氏溫度: ");

                        Serial.print(f);
                        Serial.print("*F\n");
                        delay(5000);//延時 5 秒

                    }


                   3.5.7 ESP8266 12F - Wifi 模組



















                                                  圖 3.15 ESP8266 12F


                        圖 3.15 所示為ESP8266 12F - Wifi模組，為一個Wifi且具有SOC (system on a
                   chip)的晶片，而SOC是一個將電腦或其他電子系統集成到單一晶片的積體電路，

                   並且ES8266 本身也可稱為一個Microcontroller(微控制器)又可簡稱MCU，亦有人
                   將其稱之為單晶片微控制器(Single Chip Microcontroller)，MCU將ROM、RAM、
                   CPU、I/O集合在同一個晶片中，為因應不同的使用場合做不同組合之控制。
                   ESP8266 是達成  Arduino Wifi  的便宜方案，本書使用的是ESP8266 12F版本。


                        買來的 ESP8266 開發板上可能已經裝有某個版本的  AT  韌體，但當開始使
                   用時依筆者使用經驗，建議先重新燒錄其 firmware，這個步驟很常用到的，若沒
                   重新燒錄在使用過程中時常會突然就沒法跟 Arduino 傳送訊號，這時就得靠重新

                   刷 Flash 才能繼續傳送，故當第一次使用時就先重新燒錄吧。
                   首  先   ，  可  至    ESP8266 官     網  下  載   ( 最  新  的    ESP8266_NONOS_SDK ：
                   https://github.com/espressif/ESP8266_NONOS_SDK/releases。本書以  3.0.4  為例。
                   此為 ESP8266 的韌體 firmware。)或至 https://reurl.cc/gmG1RN 下載本書整理好的

                   燒錄工具(ESP8266 的  Flash Download Tools：

                                                           105]]></page><page Index="115"><![CDATA[https://www.espressif.com/en/support/download/other-tools。本書以  v3.8.5  為例。

                   此為燒錄工具。)  與  韌體，也可參照
                   https://www.youtube.com/watch?v=tIq0Wn0hduY  影片教學。
                        會使用到的燒錄軟體為:flash_download_tool_v3.8.5，其接線圖有三種分別為:
                        1.  燒錄接線:如圖3.16所示，須將GPIO0接10KΩ並共地。

                        2.  使用與監聽:  如圖3.17所示，GPIO0不接。
                        3.  使用:  如圖所3.18示，GPIO0不接外，TX與RX接腳也不需接。

                   ESP8266 需穩定 3V，故在使用上建議獨立電源供給使用，而 CH_PD(EN)此腳位
                   依筆者經驗以 220Ω、1KΩ 或 10KΩ 都可，其中以 220Ω 最為穩定。
























                                                 圖 3.16 ESP8266 燒錄接線

























                                                 圖 3.17 ESP8266 使用+監聽










                                                           106]]></page><page Index="116"><![CDATA[圖 3.18 ESP8266 使用


                        依  照  圖  3.16 使  用  燒  錄  接  線  後  執  行    Flash  Download  Tools  資  料  夾  中  的
                   flash_download_tool_3.8.5.exe，點選  Developer mode  然後選  ESP8266。這樣就
                   會帶出下面的燒錄畫面，如圖 3.19、圖 3.20 所示。






















                                               圖 3.19 ESP8266  燒錄工具開啟

























                                                           107]]></page><page Index="117"><![CDATA[圖 3.20 ESP8266  燒錄工具使用





























































                                               圖 3.21 ESP8266  設定韌體選項


                        接著設定燒錄選項與檔案（所有檔案在  ESP8266_NONOS_SDK-3.0.4），如
                   圖 3.21 所示，在需寫入的檔案及位址其設定如下：

                   \bin\boot_v1.7.bin  →  0x000000
                   \bin\at\1024+1024\user1.2048.new.5.bin  →  0x01000
                   \bin\esp_init_data_default_v08.bin  →  0x1FC000
                   \bin\blank.bin  →  0x7E000
                   \bin\blank.bin  →  0x1FB000


                                                           108]]></page><page Index="118"><![CDATA[\bin\blank.bin  →  0x1FE000

                   SpiFlashConfig 設定：
                   SPI SPEED -> 40MHz
                   SPI MODE -> QIO
                   FLASH SIZE -> 16Mbit

                   COM -> ESP8266 COM port
                   BAUD -> 115200
                        按下  START 後開始燒錄，請耐心等待燒錄完成。以上參數可參考本書提供
                   連     結     內     的     (     esp8266-technical_reference_cn.pdf     與          4a-

                   esp8266_at_instruction_set_en.pdf  )或官網  AT  指令集文件內也有寫。如果是
                   ESP-01，要改選  8Mbit  以及  512+512\user1.2048.new.5.bin。基本上當  ESP8266
                   完成韌體更新之後，它的  Baud Rate 就會自動變成  9600。若沒有的話可利用 AT
                   command 更改，因此接下來我們要重新與  ESP8266 連接時，就需要使用  9600(若
                   無法則使用 115200  或  230400 )的  Baud Rate 設定去與它連接，如圖 3.22 所示。



























                                           圖 3.22 Arduino  與  ESP8266  接線

                        開啟 Arduino 開發工具，將以下範例程式上傳至 Arduino 並編譯，完成後開
                   啟序列埠監控視窗輸入 A T ，如圖 3.23 所示，即可看到 OK 此代表 A T  Command

                   已可正常使用。













                                                  圖 3.23 A T  Command 測試


                                                           109]]></page><page Index="119"><![CDATA[A T  Command 測試範例程式:

                    #include <SoftwareSerial.h>
                    SoftwareSerial ESPserial (2, 3); //  連接 ESP8266 的軟體序列埠  (Rx, Tx)
                    void setup() {

                        Serial.begin(9600);    //可改為  115200 或 230400

                        ESPserial.begin(9600);    //可改為  115200 或 230400
                        ESPserial.println("AT+GMR");    //取得韌體版本
                    }

                    void loop() {

                        if (Serial.available()) { //  將序列埠輸入的字串傳給 ESP8266
                            ESPserial.write(Serial.read());

                        }

                        if (ESPserial.available()) { //  將 ESP8266 輸入的字串回傳給 Arduino 序列埠
                            Serial.write(ESPserial.read());

                        }

                    }


                   ESP8266 的 Wifi 連線有三種模式：
                   1.Station 模式：連線到現有 Wifi 的裝置，如接 IP 分享緝或手機的熱點。
                   2.AP 模式：無線基地台，提供 Wifi 環境供連線，變成 IP 分享器或手機熱點。
                   3.Station+AP 混合模式：允許同時使用以上兩種模式的功能。

                        透過「AT+CWMODE」的指令，我們就可以設定或取得目前 Wifi 連線模式：
                   「AT+CWMODE?」查詢當前模式
                   「AT+CWMODE=2」將模式設定為第 2 種(AP 模式)。
                        在使用上，最好先把  ESP8266 設定到想要的模式，再使用其他的指令來連

                   線。因為，有些指令只能在特定的模式中使用，使用指令時必須特別注意。因此，
                   首先把模式設定成第一種  Station 模式。讓  ESP8266 去連接現有的  Wifi 網路，
                   而要知道有哪些現有的網路可供連線， 可 使用「AT+CWLAP」顯示可連線的 Wifi

                   網路清單。知道有哪些網路之後，就可以選一個  Wifi 網路來連線，要進行連線
                   必須使用「AT+CWJAP」指令：
                   「AT+CWJAP=<SSID>,<Password>」連線到已存在的無線網路。
                   「AT+CWJAP?」查詢已連線到的無線網路。
                   <SSID>：無線網路的識別名稱(要加雙引號)。

                   <Password>：無線網路的密碼(要加雙引號)。

                                                           110]]></page><page Index="120"><![CDATA[如需要切斷  Wifi 連線，可以使用「AT+CWQAP」切斷已連線的無線網路。

                   雖然  ESP8266  已經連線到  Wifi，但是如果  ESP8266 要跟同一個  Wifi 中的其他
                   裝置通訊，就必須要再跟該裝置建立  Socket 連線。ESP8266 有兩種跟裝置建立
                   Socket 連線的方式：
                   1.由  ESP8266 扮演伺服器，等候其他裝置(客戶端)來與自己連接。
                   2.由其他裝置扮演伺服器，由  ESP8266(客戶端)去主動連接該伺服器。


                        一般來說，伺服器類似店家的角色，必須經常保持待命，不可以隨便從 Wifi
                   中離線，否則客戶端就會找不到伺服器。所以我們必須評估連線的兩端，誰比較

                   適合當伺服器或客戶端。或者連線的兩方都客戶端，而讓第三方做伺服器，作為
                   兩客戶端之間的橋梁，為他們轉送資訊。

                        若選擇讓  ESP8266 進入伺服器模式，則需先進行多重連線的設定。這個設
                   定讓  ESP8266 能夠進行一對多的連線。只有多重連線被設定為開啟時，ESP8266

                   才能夠進入伺服器模式。
                   指令「AT+CIPMUX」
                   「AT+CIPMUX?」查詢目前的設定值

                   「AT+CIPMUX=1」允許一對多的多重連線。
                   「AT+CIPMUX=0」關閉多重連線，只能一對一連線。此時無法進入伺服器模式。

                        當 ESP8266 作為伺服器等候客戶端的連線時，需要使用以下指令：
                   指令「AT+CIPSERVER」

                   「AT+CIPSERVER= <mode>[,<port>]」開啟(或關閉)伺服器，等候客戶端透過指
                   定的連接埠(Port)連線。
                   <mode>：0 關閉伺服器，1 開啟。

                   <port>：網路連接埠號碼。範圍從  0~65535 皆可。連線到伺服器的裝置必須知道
                   連接埠(Port)號碼才能進行連線。一般根據不同的用途，會有慣用的連接埠號碼，
                   如網頁的 80 埠。
                   ※注意：此處的  Prot 是網路連接埠(TCP/UDP Port)，並非 Arduino 上提的 Port 序
                   列埠(Serial Prot  或  COM Port)。


                        當 ESP8266 作為客戶端，對伺服器進行連線，我們需要使用以下指令：
                   指令「AT+CIPSTART」

                   「AT+CIPSTART=?」查詢目前已經建立的連線資訊。
                   「AT+CIPSTART =<type>,<addr>,<port>」建立連線，只適用於 CIPMUX=0 的情
                   況。
                   「AT+CIPSTART=<id>,<type>,<addr>,<port>」建立連線，只適用於 CIPMUX=1 的
                   情況。


                                                           111]]></page><page Index="121"><![CDATA[<id>：範圍  0~4。推測最多可以連線到 5 台伺服器，這是用來代表此連線的代號。

                   <type>：連線類型，可為"TCP"或"UDP"(要加引號)。
                   <addr>：連線的  IP 位址，如"192.168.43.31"(要加引號)。
                   <port>：伺服器接受連線的連接埠(Port)號碼(這個不用加引號)。


                        由上述可知，在 ESP8266 作為伺服器時，我們必須知道  ESP8266 的  IP 位
                   址，如此其他裝置才能根據這個  IP 與  ESP8266 連線。透過「AT+CIFSR」指令，
                   我們就可以查詢到  ESP8266 的  IP 位址。
                   AT+CIFSR：顯示  ESP8266 目前的  IP 位址。

                   一旦連線建立之後，就可以透過「AT+CIPSEND」指令傳送訊息：
                   「AT+CIPSEND=<length>」只適用於  CIPMUX=0  的情況。
                   「AT+CIPSEND=<id>,<length>」只適用於  CIPMUX=1  的情況。
                   <id>：在多重連線的情況下，需要輸入連線的代號，ESP8266 才會知道要把訊息
                   發送給哪一條連線。

                   <length>要發送的訊息長度。等到此指令發送出去之後，會出現「>」符號在螢幕，
                   這時就可以輸入符合訊息長度的訊息。
                   最後如果要中斷連線，則可以使用以下指令：

                   指令「AT+CIPCLOSE」
                   「AT+CIPCLOSE=<id>」中斷指定的連線。適用於  CIPMUX=1  的情況
                   「AT+CIPCLOSE」中斷連線。適用於  CIPMUX=0  的情況
                   <id>：要中斷的連線代號。


                    #include <SoftwareSerial.h>
                    SoftwareSerial sSerial(2,3); //(RX,TX)  與  ESP8266  介接的軟體串列埠
                    String ssid="GogoJR";    //無線基地台識別

                    String pwd="Jokerwu";    //無線基地台密碼

                    void setup() {
                        Serial.begin(9600);    //設定軟體序列埠速率  (to PC)
                        sSerial.begin(9600);    //設定軟體序列埠速率  (to ESP8266)


                        Serial.println("*** SoftSerial connection to ESP8266 ***");
                        Serial.println("Firmware version : " + get_version());

                        Serial.println("Baud rate : " + get_baud());
                        Serial.println("Get IP : " + get_ip());
                        Serial.println("Mode : " + get_mode());
                        Serial.println("Set Mode=3 : " + set_mode(3));

                        Serial.println("Mode : " + get_mode());

                                                           112]]></page><page Index="122"><![CDATA[Serial.println("Set Mode=1 : " + set_mode(1));

                        Serial.println("Mode : " + get_mode());
                        Serial.println("Mux : " + get_mux());
                        Serial.println("Set Mux=1 : " + set_mux(1));
                        Serial.println("Mux : " + get_mux());

                        Serial.println("Set Mux=0 : " + set_mux(0));
                        Serial.println("Mux : " + get_mux());
                        Serial.println("Get AP : " + get_ap());
                        Serial.println("Quit AP : " + quit_ap());

                        Serial.println("Get AP : " + get_ap());
                        Serial.println("Get IP : " + get_ip());
                        Serial.println("Joint AP : " + joint_ap(ssid, pwd));
                        Serial.println("Get AP : " + get_ap());

                        Serial.println("Get IP : " + get_ip());
                        Serial.println("Connect Google : " + start_tcp("www.google.com",80));
                        Serial.println("Send GET : " + send_data("GET /"));
                        Serial.println("Connect Thingspeak : " + start_tcp("106.1.0.2",80));

                        Serial.println("Send GET : " + send_data("GET /iot/test.php"));
                        }

                    void loop() {

                        if (sSerial.available()) {    //若軟體串列埠  RX  有收到來自  ESP8266  的回應
                    字元
                            Serial.write(sSerial.read());    //在串列埠監控視窗顯示  ESP8266  的回應字
                    元

                            }
                        if (Serial.available())  {    //若串列埠  RX  有收到來自  PC  的  AT  指令字元
                    (USB TX)
                            sSerial.write(Serial.read());    //將  PC  的傳來的字元傳給  ESP8266

                            }
                        }

                    String get_ESP8266_response() {    //取得  ESP8266  的回應字串

                        String str="";    //儲存接收到的回應字串
                        char c;    //儲存接收到的回應字元
                        while (sSerial.available()) {    //若軟體序列埠接收緩衝器還有資料
                            c=sSerial.read();    //必須放入宣告為  char  之變數  (才會轉成字元)
                            str.concat(c);    //串接回應字元


                                                           113]]></page><page Index="123"><![CDATA[delay(10);    //務必要延遲,  否則太快

                            }
                        str.trim();    //去除頭尾空白字元
                        return str;
                        }


                    String get_version() {
                        sSerial.println("AT+GMR");    //取得韌體版本
                        sSerial.flush();    //等待序列埠傳送完畢

                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串
                        /*if (str.indexOf("OK") == -1) {return "NG";}
                        else {return str.substring(0,str.indexOf("\r\n"));}*/

                        return str;
                        }

                    String get_baud() {

                        sSerial.println("AT+CIOBAUD?");    //取得傳送速率
                        sSerial.flush();    //等待序列埠傳送完畢
                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串

                        /*if (str.indexOf("OK") == -1) {return "NG";}
                        else {return str.substring(str.indexOf(":")+1,str.indexOf("\r\n"));}*/
                        return str;
                        }


                    String get_ip() {
                        sSerial.println("AT+CIFSR");    //取得  ESP8266 IP
                        sSerial.flush();    //等待序列埠傳送完畢

                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串
                        /*if (str.indexOf("OK") == -1) {return "NG";}
                        else {return str.substring(0,str.indexOf("\r\n"));}*/

                        return str;
                        }

                    String get_mode() {
                        sSerial.println("AT+CWMODE?");    //取得工作模式


                                                           114]]></page><page Index="124"><![CDATA[sSerial.flush();    //等待序列埠傳送完畢

                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串
                        /*if (str.indexOf("OK") != -1) {
                            return str.substring(str.indexOf(":")+1,str.indexOf("\r\n"));

                            }
                        else {return "NG";}*/
                        return str;
                        }


                    String set_mode(byte mode) {
                        sSerial.println("AT+CWMODE=" + String(mode));    //設定工作模式
                        sSerial.flush();    //等待序列埠傳送完畢

                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串
                        /*if (str.indexOf("OK") != -1 || str.indexOf("no change") != -1) {return "OK";}
                        else {return "NG";}*/

                        return str;
                        }

                    String get_mux() {
                        sSerial.println("AT+CIPMUX?");    //取得連線模式

                        sSerial.flush();    //等待序列埠傳送完畢
                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串

                        /*if (str.indexOf("OK") != -1) {
                            return str.substring(str.indexOf(":")+1,str.indexOf("\r\n"));
                            }
                        else {return "NG";}*/

                        return str;
                        }

                    String set_mux(byte mux) {    //0=single, 1=multiple

                        sSerial.println("AT+CIPMUX=" + String(mux));    //設定連線模式
                        sSerial.flush();    //等待序列埠傳送完畢
                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串

                        /*if (str.indexOf("OK") != -1) {return "OK";}

                                                           115]]></page><page Index="125"><![CDATA[else {return "NG";}*/

                        return str;
                        }

                    String get_ap() {
                        sSerial.println("AT+CWJAP?");    //取得連線之 AP

                        sSerial.flush();    //等待序列埠傳送完畢
                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串

                        /*if (str.indexOf("OK") != -1) {
                            return str.substring(str.indexOf(":")+1,str.indexOf("\r\n"));
                            }
                        else {return "NG";}*/

                        return str;
                        }

                    String joint_ap(String ssid, String pwd) {

                        sSerial.println("AT+CWJAP=\"" + ssid + "\",\"" + pwd + "\"");    //連線
                        sSerial.flush();    //等待序列埠傳送完畢
                        delay(7000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串

                        /*if (str.indexOf("OK") != -1) {return "OK";}
                        else {return "NG";}*/
                        return str;
                        }


                    String quit_ap() {
                        sSerial.println("AT+CWQAP");    //離線
                        sSerial.flush();    //等待序列埠傳送完畢

                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串
                        /*if (str.indexOf("OK") != -1) {return "OK";}
                        else {return "NG";}*/

                        return str;
                        }

                    String start_tcp(String address, byte port) {

                        sSerial.println("AT+CIPSTART=\"TCP\",\"" + address + "\"," + String(port));

                                                           116]]></page><page Index="126"><![CDATA[sSerial.flush();    //等待序列埠傳送完畢

                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串
                        /*if (str.indexOf("Linked") != -1) {return "OK";}
                        else {return "NG";}*/

                        return str;
                        }

                    String send_data(String s) {

                        String s1=s + "\r\n";    //務必加上跳行
                        sSerial.println("AT+CIPSEND=" + String(s1.length()));
                        sSerial.flush();    //等待序列埠傳送完畢
                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串

                        if (str.indexOf(">") != -1) {    //收到  >  開始傳送資料
                            sSerial.println(s1); //傳送資料
                            sSerial.flush();    //等待序列埠傳送完畢

                            delay(7000);
                            str=get_ESP8266_response();    //取得  ESP8266  回應字串
                            if (str.indexOf("+IPD") != -1) {return "OK";}    //傳送成功會自動拆線
                            else {    //傳送不成功須自行拆線
                                close_ip();    //關閉  IP  連線

                                return "NG";
                                }
                            }

                        else {    //傳送不成功須自行拆線
                            close_ip();    //關閉  IP  連線
                            return "NG";
                            }

                        }

                    String close_ip() {
                        sSerial.println("AT+CIPCLOSE");    //關閉  IP  連線

                        sSerial.flush();    //等待序列埠傳送完畢
                        delay(1000);
                        String str=get_ESP8266_response();    //取得  ESP8266  回應字串
                        if (str.indexOf("OK") != -1) {return "OK";}

                        else {return "NG";}

                                                           117]]></page><page Index="127"><![CDATA[}


                        當瞭解相關指令後，接著就是要如何運用 ESP8266 傳輸資料至伺服器上，
                   首先須與欲連線的伺服器  80  埠建立  TCP  連線, AT  指令如下  :
                   AT+CIPSTART="TCP","192.168.0.12",80
                   其中  192.168.0.12  乃是  我們自己架設的伺服器 IP  位址。當連線成功 ESP8266

                   會回應  :
                   OK
                   表示已經建立  TCP  連線了。


                        接著是要告訴  ESP8266  我們打算要傳送多少字元的資料，以便其準備所需
                   之緩衝區。所使用的  AT  指令是  CIPSEND， 故 向目的主機發出如下格式之  GET
                   請求  : GET /目的網頁網址

                        // prepare GET string
                        String getStr = "GET /iot/insert.php?temp=21&humi=50";
                        getStr += "\r\n\r\n";


                        // send data length
                        cmd = "AT+CIPSEND=";
                        cmd += String(getStr.length());
                        ser.println(cmd);

                        Serial.println(cmd);

                        而此處目的網頁就是  我們將資料傳輸至伺服器時，寫入資料庫的資料網頁
                   程式  insert.php :

                   /iot/insert.php?temp=21&humi=50
                   其格式為
                   /iot/insert.php?欄位 1=數值 1&欄位 2=數值 2....
                        當傳送  AT  指令給  ESP8266  時都必須在後面加上  \r\n  這兩個跳行字元,

                   因此全部字元長度須再加上  2,  故會有 getStr += "\r\n\r\n";這段原碼。
                        特別注意，在傳輸字串時總字元長度必須恰恰好，多跟少都不行，ESP8266
                   會因為長度問題而當在那邊，導致無法完成傳送。此  AT  指令下完後，ESP8266
                   會回應一個大於提示號，表示可以開始傳送資料  :

                   >
                   最後是就是把要溫溼度資料的  GET  指令字串貼到  >  後面傳送 ，因此程式如下:
                    if(ser.find(">")){
                            ser.print(getStr);

                            Serial.println(">"+getStr);

                                                           118]]></page><page Index="128"><![CDATA[成功的話，ESP8266  會回應 SEND OK。當傳送完資料  ESP8266  就自動拆

                   除  TCP  連線，進入 AT+CIPCLOSE。綜上所述，當 ESP8266 進行資料傳輸時，
                   可簡略為四個步驟如本書範例程式  :
                   1.與目的主機建立  TCP  連線  :
                   AT+CIPSTART="TCP","192.168.0.12",80      //連線  伺服器  主機
                   在  Arduino  中以字串表示時，須將雙引號以倒斜線跳開  :

                   String cmd="AT+CIPSTART=\"TCP\",\"192.168.0.12\",80";

                   2.傳送  GET  字串長度給  ESP8266 :

                   AT+CIPSEND=GET  字串長度

                   3.傳送  GET  字串給  ESP8266 :
                   ser.println(GET  字串)


                   4.關閉  TCP  連線  :
                   AT+CIPCLOSE


                   範例程式如下  :
                    #include <SoftwareSerial.h>
                    #include <stdlib.h>


                    SoftwareSerial ser(2, 3); // RX, TX

                    String ssid="無線基地台識別";    //無線基地台識別
                    String pwd="無線基地台密碼";    //無線基地台密碼

                    String server="192.168.0.12";      //這裡填入你要連線的目標 IP

                    #define DEBUG true


                    // this runs once
                    void setup() {
                        // enable debug serial
                        Serial.begin(9600);

                        // enable software serial
                        ser.begin(9600);

                        // reset ESP8266

                        ser.println("AT+RST");

                                                           119]]></page><page Index="129"><![CDATA[String cmd="AT+CWJAP=\"";
                        cmd+=ssid;
                        cmd+="\",\"";
                        cmd+=pwd;

                        cmd+="\"";
                        cmd+="\r\n";

                        Serial.println("*** SoftSerial connection to ESP8266 ***");

                        sendData("AT+CWMODE=1\r\n",100,DEBUG); //  設定為 STA 模式
                        sendData(cmd,10000,DEBUG); //  取得連線(視 AP 連線效能作調整，預設 7000
                    毫秒)
                        sendData("AT+CIFSR\r\n",100,DEBUG); //  獲得 IP
                        sendData("AT+CIPMUX=1\r\n",100,DEBUG); //  開啟多除連接模式

                        sendData("AT+CIPSERVER=1,80\r\n",100,DEBUG); //  設定連接埠為 8080
                        Serial.println("Ready");
                    }


                    // the loop
                    void loop() {
                    //sendData("AT+CIFSR\r\n",100,DEBUG); //  獲得 IP

                        // TCP connection
                        String cmd = "AT+CIPSTART=\"TCP\",\"";
                        cmd += "192.168.0.12"; //
                        cmd += "\",80";

                        ser.println(cmd);

                        if(ser.find("Error")){
                            Serial.println("AT+CIPSTART error");

                            return;
                        }

                        // prepare GET string

                        String getStr = "GET /iot/insert.php?temp=21&humi=50";
                        getStr += "\r\n\r\n";

                        // send data length

                        cmd = "AT+CIPSEND=";

                                                           120]]></page><page Index="130"><![CDATA[cmd += String(getStr.length());

                        ser.println(cmd);
                        Serial.println(cmd);

                        if(ser.find(">")){

                            ser.print(getStr);
                            Serial.println(">"+getStr);
                        }
                        else{

                            ser.println("AT+CIPCLOSE");
                            // alert user
                            Serial.println("AT+CIPCLOSE");
                        }


                        // thingspeak needs 15 sec delay between updates
                        delay(1000);
                    }


                    String sendData(String command, const int timeout, boolean debug) {
                        String response="";
                        ser.print(command); // send the read character to the esp8266

                        long int time=millis();
                          do{
                            while(ser.available()) {
                                // The esp has data so display its output to the serial window

                                char c=ser.read(); // read the next character.
                                response += c;
                                }


                          if(response.charAt(response.length()-
                    2)=='O'&&response.charAt(response.length()-1)=='K'){
                              time=0;
                          }

                            }while ((time+timeout) > millis());
                        if (debug) {Serial.print(response);}

                        Serial.println(response);



                                                           121]]></page><page Index="131"><![CDATA[return response;

                        }

                   3.6 軟體架構


















































                                               圖 3.24 智慧農場軟體流程


                        如圖 3.24 所示，當 Arduino 程式啟動時，偵測元件、ESP8266 與手動偵測皆
                   同時啟動進行，因此我們這時就需要以多執行緒的方式進行。在本專案的軟體思
                   路上，分為自動與手動兩執行緒，在自動控制上的執行緒，以周邊偵測元件與

                   ESP8266 資料傳輸。而手動控制功能則較為單純，純粹判斷按鈕開關，啟動或停
                   止抽水馬達即可。

                   3.7 伺服器架設




                        PHP（全稱：PHP：Hypertext Preprocessor，即「PHP：超文字預處理器」）是

                                                           122]]></page><page Index="132"><![CDATA[一種開源運行在伺服器端的通用電腦語言，尤其適用於網路開發並可嵌入 HTML

                   中使用。PHP 的語法借鑑吸收 C 語言、Java 和 Perl 等流行電腦語言的特點，因
                   此比其他語言編寫腳本更快，且易於一般程式設計師學習。PHP 的主要目標是允
                   許網路開發人員快速編寫動態頁面，但 PHP 也被用於其他很多領域。並且具有
                   開源、獨立平台，兼容性、嵌入式腳本等特點，故用於 Web 的開發越來越廣泛。

                   但對於初學者來說 Apache、PHP 以及 MySQL 的安裝和配置較為複雜，因此可
                   以選擇 WAMP（Windows+Apache+MySQKL+PHP）集成安裝環境快速配置 PHP
                   伺服器。因此，本書以一種 PHP 的集成安裝環境 Wampserver 做介紹與使用。
                   Wampserver 集成了 Approach 伺服器、PHP 預處理器以及 MySQL 伺服器，這樣

                   快速地解決電腦環境的安裝配置，可以讓使用者把更多的精力用在項目的開發中。
                   步驟
                   Step1.首先從 http://sourceforge.net/projects/wampserver/  下載軟體安裝包，雙擊打
                   開，選擇 English，點擊"OK"。


                   圖 3.25 Wampserver64 下載

                   Step2.點擊"I accept the agreement"，然後點擊"Next"。

                   圖 3.26 Wampserver64  安裝

                   Step3.點擊"Next"。
                   圖 3.27 Wampserver64  安裝


                   Step4.這是可以選擇將軟體存在那個盤中，我是存在 D 盤中，然後點擊"Next"。
                   圖 3.28 Wampserver64  安裝路徑


                   Step5.這是選擇文件目錄，電腦直接創建了一個新的文件，因此可以直接點擊
                   "Next"。
                   圖 3.29 Wampserver64  路徑選擇

                   Step6.點擊"Install"。

                   圖 3.30 Wampserver64  安裝

                   Step7.開始安裝（大概需要一兩分鐘）。

                   圖 3.31 Wampserver64  安裝

                   Step8.安裝瀏覽器，彈出一個對話框，點擊"否"。

                   Step9.桌面出現圖標，雙擊。


                                                           123]]></page><page Index="133"><![CDATA[圖 3.32 Wampserver64  開啟


                   Step10.出現一個黑色窗口但是隨後消失。
                   圖 3.33 Wampserver64  啟動


                   Step11.打開瀏覽器，在地址欄中輸入"http://localhost/"或者"http://127.0.0.1/",按下
                   <Enter>鍵，出現介面則安裝基本成功。
                   圖 3.34 Wampserver64  測試


                   注意：軟體安裝啟動之後在電腦下方的任務欄圖標是綠色表示是安裝成功的。如
                   果是橙色的，有可能是埠號「80」被占用的情況。更改一下埠號即可。這個軟體
                   由於是在瀏覽器顯示結果，因此使用時需要聯網。
                        最  後  ，  當  想  由  手  機  或  外  部  連  進  apache  server 時  會  出  現    You  don't  have
                   permission to access / on the server  問題，則需修改 httpd.conf  檔案，將

                    <Directory "${INSTALL_DIR}/www/">
                            Options +Indexes +Includes +FollowSymLinks +MultiViews
                            AllowOverride All

                            Require local
                            Order deny,allow
                            Allow from all
                    </Directory>

                   更改為
                    <Directory "${INSTALL_DIR}/www/">
                            Options +Indexes +Includes +FollowSymLinks +MultiViews

                            AllowOverride All
                            Require local
                            Require all granted
                            Order deny,allow
                            Allow from all

                    </Directory>
                        這樣外網就可以訪問主網站了。此外，在  php.ini 內可找到  display_errors，
                   設定為  On  是開啟錯誤訊息，Off  是關閉輸出:

                    display_errors = On      #  開啟錯誤提示
                    display_errors = Off      #  關閉錯誤提示
                   而在  php.ini  有一項設定可以使用短標籤縮寫:
                    short_open_tag = On

                   就可以<?php ?>  與  <? ?>併用，當修改後記得存檔並重新啟動 apache server。


                                                           124]]></page><page Index="134"><![CDATA[3.8 系統程式


                        因為本專案需同時進行溫、濕度、水位等環境偵測，並且有手動控制抽水馬
                   達與雲端控制，故我們須使用多執行緒的方式進行。而 Arduino 開發板可藉助
                   SCoop 即可輕鬆實現多執行緒。Arduino 多執行緒庫 SCoop  多執行緒是指從軟體
                   或者硬體上實現多個執行緒併發執行的技術。


                   Step1.  載入庫檔案 SCoop  到 https://github.com/fabriceo/SCoop 下載 SCoop 庫，
                   然後新增到 Arduino IDE 中。


                   Step2.  初始化設定，引入標頭檔案
                    #include "SCoop.h"


                   Step3.設定 setup
                    void setup() {
                    mySCoop.start();

                    }

                   Step4.設定 loop
                    void loop() {

                    yield();
                    }

                   Step5.定義的執行緒並實現具體功能

                    defineTask(TaskTest);
                    void TaskTest::setup() {
                    //這裏是 setup
                    }

                    void TaskTest::loop() {
                      //這是是 loop，需要執行的動作寫在此處。
                    }

                        如果只是想在某個執行緒中暫停，請使用 sleep(ms)。若使用 delay()，則會使
                   整個程式都暫停。以下為簡單例子實現 12 與 13 腳位的燈以多執行緒的方式每秒
                   閃爍一次。
                    #include "SCoop.h"

                    defineTask(Task1);

                    void Task1::setup() {

                                                           125]]></page><page Index="135"><![CDATA[pinMode(13, OUTPUT);

                    }

                    void Task1::loop() {
                    digitalWrite(13, HIGH);

                    sleep(1000);
                    digitalWrite(13, LOW);
                    sleep(1000);
                    }


                    defineTaskLoop(Task2) {
                    digitalWrite(12, HIGH);
                    sleep(100);

                    digitalWrite(12, LOW);
                    sleep(100);
                    }


                    void setup() {
                    mySCoop.start();
                    pinMode(12, OUTPUT);
                    }


                    void loop() {
                    yield();
                    }


                   以下為簡單例子實現每毫秒輸出計數器的數值同時腳位 6 的燈每秒閃爍一次

                    //1.引標頭檔

                    //2.setup mySCoop.start();
                    //loop yield();
                    //暫停使用 sleep();

                    //sleep 與 delay 的區別在於 delay 是全域暫停，sleep 是分支暫停

                    #include<SCoop.h>//聲明函式程式庫
                    int count=0;
                    //簡單的使用兩種定義方式

                    //如果不需要定義埠這種方式最簡單 defineTaskLoop(X){}

                                                           126]]></page><page Index="136"><![CDATA[//每毫秒輸出計數器的數值

                    defineTaskLoop(Task2){
                    Serial.println(count++);
                    sleep(1);
                    }
                    //如果需要使用埠則這種定義可以兼顧埠定義和程式迴圈、

                    //腳位 6 的燈每秒閃爍一次
                    //defineTask 是一個詞，不可隔開
                    defineTask(Task1)


                    void Task1::setup(){
                    pinMode(6,OUTPUT);
                    }

                    void Task1::loop(){
                    digitalWrite(6,!digitalRead(6));
                    sleep(1000);
                    }


                    void setup() {
                    // put your setup code here, to run once:
                    Serial.begin(9600);

                    mySCoop.start();
                    }

                    void loop() {

                    // put your main code here, to run repeatedly:
                    //loop 裡面需要使用 yield()函數
                    yield();
                    }



                   3.8.1 Arduino


                        本專案 Arduino 主程式，可分為四個區塊介紹，其分別為前置命令與宣告、
                   執行緒、主程式、副程式。

                   前置命令與宣告
                        首先我們引入 wifi 需使用的 SoftwareSerial.h 軟體序列函式以及 C 標準函數

                   庫的頭文件 stdlib.h，聲明了數值與字符串轉換函數,  偽隨機數生成函數,  動態內

                                                           127]]></page><page Index="137"><![CDATA[存分配函數,  進程控制函數等公共函數。

                    #include <SoftwareSerial.h>
                    #include < stdlib.h >

                   接著引入多執行緒 Scoop.h， 及 LCD 1206  需使用的 LiquidCrystal 函式庫及 DHT。

                    #include <SCoop.h>          //包含 SCoop  頭文件  多執行緒用
                    #include <LiquidCrystal_PCF8574.h>
                    #include "DHT.h"


                   最後，宣告如下相關腳位與變數:
                   DHT 11 溫、濕度使用的宣告與相關變數
                    #define DHTPIN 9 // //設定 DHT 腳位
                    #define DHTTYPE DHT11 // //設定感測器型號為 DHT11

                    DHT dht(DHTPIN, DHTTYPE);
                    float h =0;//濕度帶小數點型態
                    float t =0;//溫度帶小數點型態


                   ESP8266 12F Wifi 使用的宣告與相關變數
                    SoftwareSerial ser(2, 3); // RX, TX
                    String ssid="GoGoJR";    //無線基地台識別

                    String pwd="a123456789";    //無線基地台密碼
                    String server="192.168.0.10";      //這裡填入你要連線的目標 IP
                    #define DEBUG true //所有的序列命令將被執行並且在序列監視窗上有資料，
                    否則它將跳過代碼中的序列列印命令。


                   Lcd 1206  使用的宣告與相關變數
                    LiquidCrystal_PCF8574 lcd(0x27);

                    //  設定 i2c 位址，一般情況就是 0x27 和 0x3F 兩種

                   其他相關腳位與變數

                    double temp,data; //水位偵測用
                    int RoutPin = 8; //Relay
                    int inPin = 10; //  開關  開
                    int inPin2 = 11; //  開關  關
                    int outPin = 13; //測試 LED





                                                           128]]></page><page Index="138"><![CDATA[執行緒

                   第一執行緒，此執行緒為手動控制，單純用以按鈕開關控制。
                    defineTaskLoop(myTask1)        //創建線程 myTask1
                    {
                        //開關  switch

                        pinMode(inPin, INPUT);
                        pinMode(inPin2, INPUT);
                        pinMode(outPin, OUTPUT);//LED
                        pinMode(RoutPin,OUTPUT);//relay

                    }

                   第二執行緒，此執行緒包含 setup()  初始化與 loop()執行緒內的主動作。setup()
                   初始化主要以 DHT  與  LCD 1206 為主。

                    defineTask(myTask2);      //創建線程 myTask2
                    void myTask2::setup() { //設定線程 myTask2
                        Serial.println("DHTxx test!");

                        dht.begin();    //初始化 DHT
                        lcd.begin(16, 2); //  初始化 LCD
                        lcd.setBacklight(255);
                        lcd.clear();
                        lcd.setCursor(0, 0);    //設定游標位置  (字,行)

                        lcd.print("*~ first line.");
                        lcd.setCursor(0, 1);
                        lcd.print("~* second line.");

                    }

                   loop()執行緒內的主動作以抽水馬達的控制為主。
                    void myTask2::loop()    { //設定線程 myTask2 循環
                      //開關控制

                        if (digitalRead(inPin) == HIGH )
                        {
                            digitalWrite(RoutPin, 1);//開

                        }
                        if (digitalRead(inPin2) == HIGH ) //關
                        {
                            //digitalWrite(outPin, 0);

                            digitalWrite(RoutPin, 0);
                        }

                                                           129]]></page><page Index="139"><![CDATA[}


                   主程式
                        主程式內 setup()  初始化，首先確定開機後 ESP8266 Wifi 是否連線成功，連
                   線成功後則驅動 mySCoop.start();  進入多執行緒啟動初始化。

                    void setup()
                    {
                        Serial.begin(9600);

                        ser.begin(9600);//Ardunio <-> Wifi
                      //wifi
                              // reset ESP8266
                        ser.println("AT+RST");
                        String cmd="AT+CWJAP=\"";

                        cmd+=ssid;
                        cmd+="\",\"";
                        cmd+=pwd;

                        cmd+="\"";
                        cmd+="\r\n";
                        Serial.println("*** SoftSerial connection to ESP8266 ***");
                        sendData("AT+CWMODE=3\r\n",100,DEBUG); //  設定為 STA 模式
                        sendData(cmd,10000,DEBUG); //  取得連線(視 AP 連線效能作調整，預設 7000

                    毫秒)
                        sendData("AT+CIFSR\r\n",100,DEBUG); //  獲得 IP
                        sendData("AT+CIPMUX=1\r\n",100,DEBUG); //  開啟多除連接模式

                        sendData("AT+CIPSERVER=1,80\r\n",100,DEBUG); //  設定連接埠為 8080
                        Serial.println("Ready");
                        while (!Serial);
                        mySCoop.start();
                    } // setup()





                        loop()內則以 DetectSensor()，此為溫溼度與水位偵測程式。WifiSendata()與
                   WifiGdata()則分別為 Wifi 的資料傳送與接收，最後執行 mySCoop.sleep(1000)，
                   讓執行緒暫停 1 秒，以便資料傳輸順利。
                    void loop()

                    {
                        DetectSensor(); //偵測副程式

                                                           130]]></page><page Index="140"><![CDATA[WifiSendata(); //Wifi  傳輸

                        WifiGdata(); //Wifi  接收
                        //Serial.println("Gogo~Joker~~~~");
                        mySCoop.sleep(1000);
                    } // loop()



                   副程式

                        為方便我們了解與使用 ESP8266 AT Command 資料傳輸，故首先將資料傳輸
                   以副程式方式撰寫出 sendData(command, timeout, debug)函式，此函式使用上如:
                   sendData("AT+CIFSR\r\n",100,DEBUG)，帶有 AT command 與 timeout 時間及模式
                   三個參數，後續使用上當 AT Command 傳遞成功、失敗就可下一步、重新傳送或
                   跳出等控制。

                    String sendData(String command, const int timeout, boolean debug) {
                        String response="";//回傳值變數
                        ser.print(command); //  傳送 AT Command  給 esp8266

                        long int time=millis();
                          do{
                            while(ser.available()) {
                                //  將 ESP8266 的值放入回傳值變數 response 以便顯示
                                char c=ser.read();

                                response += c;
                                }
                          if(response.charAt(response.length()-

                    2)=='O'&&response.charAt(response.length()-1)=='K'){
                              time=0;
                          }
                            }while ((time+timeout) > millis());//時間控制
                        if (debug) {Serial.print(response);}

                        Serial.println(response); //序列監視窗顯現回傳值
                        return response;
                        }


                   Wifi  資料傳輸，此副程式主要控制 AT Command Get 傳輸資料給伺服器。
                    void WifiSendata()
                    {

                        // TCP connection
                        String cmd = "AT+CIPSTART=\"TCP\",\"";

                                                           131]]></page><page Index="141"><![CDATA[cmd += server; //  連線目標 IP

                        cmd += "\",80";
                        ser.println(cmd);
                        if(ser.find("Error")){
                            Serial.println("AT+CIPSTART error");

                            return;
                      }
                        // prepare GET string
                        String getStr = "GET /iot/insert.php?temp=";

                        getStr +=t;
                        getStr +="&humi=";
                        getStr +=h;
                        getStr += "\r\n\r\n";

                        // send data length
                        cmd = "AT+CIPSEND=";
                        cmd += String(getStr.length());
                        ser.println(cmd);

                        Serial.println(cmd);
                        //delay(1000);
                        if(ser.find(">")){
                            ser.print(getStr);

                            Serial.println(">"+getStr);
                        }
                        else{
                            ser.println("AT+CIPCLOSE");

                            // alert user
                            Serial.println("AT+CIPCLOSE");
                        }
                        // thingspeak needs 15 sec delay between updates

                        delay(5000);
                    }



                        Wifi  資料接收，此副程式主要控制 AT Command Get 取得伺服器網頁資料。
                   其方式為:先使用 Get 方式取得伺服器上頁面資料，再從 ser.find 到的資料判斷是
                   ON 或 OFF。
                    void WifiGdata()

                    {

                                                           132]]></page><page Index="142"><![CDATA[//wifi

                        String cmd = "AT+CIPSTART=\"TCP\",\"";
                        cmd += server; //  連線目標 IP
                        cmd += "\",80";
                        ser.println(cmd);


                        if(ser.find("Error")){
                            Serial.println("AT+CIPSTART error");
                            return;

                        }
                        // prepare GET string
                        String getStr = "GET /iot/test.php";
                        getStr += "\r\n\r\n";

                        // send data length
                        cmd = "AT+CIPSEND=";
                        cmd += String(getStr.length());
                        ser.println(cmd);

                        Serial.println(cmd);
                        delay(1000);

                        if(ser.find(">")){

                            ser.print(getStr);
                            delay(1000);
                            Serial.println("GData >"+getStr);
                            //

                            if(ser.find("On"))
                                    {
                                    digitalWrite(13,1); // toggle pin
                                    Serial.print("Turn On!!!");

                                    }
                                    else
                                    {
                                        digitalWrite(13,0); // toggle pin

                                    Serial.print("Turn Off!!!");
                                    }
                            //
                        }

                        else{

                                                           133]]></page><page Index="143"><![CDATA[ser.println("AT+CIPCLOSE");

                            // alert user
                            Serial.println("AT+CIPCLOSE");
                        }
                        // thingspeak needs 15 sec delay between updates

                        delay(5000);
                    }


                        偵測副程式，主要為 DHT、LCD 1206、水位偵測構成，最後搭配 if 判斷式，
                   判斷是否開啟抽水馬達。
                    void DetectSensor()
                    {
                        delay(1000);

                        h = dht.readHumidity();      //取得濕度
                        t = dht.readTemperature();    //取得溫度 C
                        Serial.print("Humidity: ");

                        Serial.print(h);
                        Serial.print(" %\t");
                        Serial.print("Temperature: ");
                        Serial.print(t);
                        Serial.println(" *C ");


                        lcd.clear();
                        lcd.setCursor(0, 0);    //設定游標位置  (字,行)

                        lcd.print("RH    :"); //Humidity
                        lcd.setCursor(7, 0);
                        lcd.print(h);
                        lcd.setCursor(14, 0);
                        lcd.print("%");


                        lcd.setCursor(0, 1);    //設定游標位置  (字,行)
                        lcd.print("Temp:");//Temperature

                        lcd.setCursor(7, 1);
                        lcd.print(t);
                        lcd.setCursor(13, 1);
                        lcd.print((char)223); //用特殊字元顯示符號的"度"
                        lcd.setCursor(14, 1);

                        lcd.print("C");

                                                           134]]></page><page Index="144"><![CDATA[//水位偵測

                      int value = analogRead(A0);
                        Serial.print(value);
                        Serial.print("      ");
                        temp=(long)analogRead(0); //讀出類比量值

                        data=(temp/670)*4;
                        Serial.print("the depth is:");
                        Serial.print(data);
                        Serial.println("cm");

                        delay(1000);
                        lcd.clear();
                        lcd.setCursor(0, 0);    //設定游標位置  (字,行)
                        lcd.print("Water:"); //Humidity

                        lcd.setCursor(7, 0);
                        lcd.print(data);
                        lcd.setCursor(14, 0);
                        lcd.print("cm");


                    //抽水自動控制
                        if (t > 28 ) //溫度控制
                        {
                            //digitalWrite(outPin, 1);//開

                            digitalWrite(RoutPin, 1);//relay 開
                        }else if(h<20) //濕度控制
                            {

                            //digitalWrite(outPin, 1);//Led 開
                            digitalWrite(RoutPin, 1);//relay 開
                            }
                        else

                        {
                            //digitalWrite(outPin, 0);//關
                            digitalWrite(RoutPin, 0);//關
                        }

                    }






                                                           135]]></page><page Index="145"><![CDATA[完整程式

                    /*
                      *  本範程式為 Arduino  智慧農場  範例  By Joker Wu
                    */
                    #include <SoftwareSerial.h>

                    #include <stdlib.h>
                    #include <SCoop.h>          //包含 SCoop  頭文件  多執行緒用
                    #include <LiquidCrystal_PCF8574.h>
                    #include "DHT.h"


                    #define DHTPIN 9
                    #define DHTTYPE DHT11
                    //---wifi

                    SoftwareSerial ser(2, 3); // RX, TX
                    String ssid=" GoGoJR ";    //無線基地台識別
                    String pwd="a123456789";    //無線基地台密碼
                    String server="192.168.0.10";      //這裡填入你要連線的目標 IP

                    #define DEBUG true
                    //---
                    LiquidCrystal_PCF8574 lcd(0x27);    //  設定 i2c 位址，一般情況就是 0x27 和
                    0x3F 兩種

                    DHT dht(DHTPIN, DHTTYPE);
                    double temp,data; //水位偵測用
                    int RoutPin = 8; //Relay
                    int inPin = 10; //  開關  開

                    int inPin2 = 11; //  開關  關
                    int outPin = 13; //測試 LED

                      float h =0;//濕度
                      float t =0;//溫度

                    //------------------多執行緒用
                    defineTaskLoop(myTask1)        //創建線程 myTask1
                    {

                        //開關  switch
                        pinMode(inPin, INPUT);
                        pinMode(inPin2, INPUT);
                        pinMode(outPin, OUTPUT);//LED

                        pinMode(RoutPin,OUTPUT);//relay

                                                           136]]></page><page Index="146"><![CDATA[}

                    String sendData(String command, const int timeout, boolean debug) {
                        String response="";
                        ser.print(command);
                        long int time=millis();

                          do{
                            while(ser.available()) {
                                char c=ser.read(); // read the next character.
                                response += c;

                                }
                          if(response.charAt(response.length()-
                    2)=='O'&&response.charAt(response.length()-1)=='K'){
                              time=0;

                          }
                            }while ((time+timeout) > millis());
                        if (debug) {Serial.print(response);}
                        Serial.println(response);

                        return response;
                        }
                    defineTask(myTask2);      //創建線程 myTask2
                    //**********************
                    void myTask2::setup() { //設定線程 myTask2

                        Serial.println("DHTxx test!");
                        dht.begin();    //初始化 DHT
                        lcd.begin(16, 2); //  初始化 LCD

                        lcd.setBacklight(255);
                        lcd.clear();
                        lcd.setCursor(0, 0);    //設定游標位置  (字,行)
                        lcd.print("*~ first line.");

                        lcd.setCursor(0, 1);
                        lcd.print("~* second line.");
                    }
                    void myTask2::loop()    { //設定線程 myTask2 循環

                      //開關控制
                        if (digitalRead(inPin) == HIGH )
                        {
                            digitalWrite(RoutPin, 1);//開

                        }

                                                           137]]></page><page Index="147"><![CDATA[if (digitalRead(inPin2) == HIGH ) //關

                        {
                            digitalWrite(RoutPin, 0);
                        }
                    }

                    //==========================
                    void setup()
                    {
                        Serial.begin(9600);

                        ser.begin(9600);//Ardunio <-> Wifi
                        ser.println("AT+RST");
                        String cmd="AT+CWJAP=\"";
                        cmd+=ssid;

                        cmd+="\",\"";
                        cmd+=pwd;
                        cmd+="\"";
                        cmd+="\r\n";

                        Serial.println("*** SoftSerial connection to ESP8266 ***");
                        sendData("AT+CWMODE=3\r\n",100,DEBUG); //  設定為 STA 模式
                        sendData(cmd,10000,DEBUG); //  取得連線(視 AP 連線效能作調整，預設 7000
                    毫秒)
                        sendData("AT+CIFSR\r\n",100,DEBUG); //  獲得 IP

                        sendData("AT+CIPMUX=1\r\n",100,DEBUG); //  開啟多除連接模式
                        sendData("AT+CIPSERVER=1,80\r\n",100,DEBUG); //  設定連接埠為 8080
                        Serial.println("Ready");

                        while (!Serial);
                        mySCoop.start();
                    } // setup()
                    void loop()

                    {
                        DetectSensor(); //偵測副程式
                        WifiSendata(); //Wifi  傳輸
                        WifiGdata(); //Wifi  接收

                        //Serial.println("Gogo~Joker~~~~");
                        mySCoop.sleep(1000);
                    } // loop()
                    //Wifi Send

                    void WifiSendata()

                                                           138]]></page><page Index="148"><![CDATA[{

                        // TCP connection
                        String cmd = "AT+CIPSTART=\"TCP\",\"";
                        cmd += server; //  連線目標 IP
                        cmd += "\",80";

                        ser.println(cmd);
                        if(ser.find("Error")){
                            Serial.println("AT+CIPSTART error");
                            return;

                      }
                        // prepare GET string
                        String getStr = "GET /iot/insert.php?temp=";
                        getStr +=t;

                        getStr +="&humi=";
                        getStr +=h;
                        getStr += "\r\n\r\n";
                        // send data length

                        cmd = "AT+CIPSEND=";
                        cmd += String(getStr.length());
                        ser.println(cmd);
                        Serial.println(cmd);

                        //delay(1000);
                        if(ser.find(">")){
                            ser.print(getStr);
                            Serial.println(">"+getStr);

                        }
                        else{
                            ser.println("AT+CIPCLOSE");
                            // alert user

                            Serial.println("AT+CIPCLOSE");
                        }
                        // thingspeak needs 15 sec delay between updates
                        delay(5000);

                    }
                    //**************
                    //Wifi Get Data
                    void WifiGdata()

                    {

                                                           139]]></page><page Index="149"><![CDATA[//wifi

                        String cmd = "AT+CIPSTART=\"TCP\",\"";
                        cmd += server; //  連線目標 IP
                        cmd += "\",80";
                        ser.println(cmd);


                        if(ser.find("Error")){
                            Serial.println("AT+CIPSTART error");
                            return;

                        }
                        // prepare GET string
                        String getStr = "GET /iot/test.php";
                        getStr += "\r\n\r\n";

                        // send data length
                        cmd = "AT+CIPSEND=";
                        cmd += String(getStr.length());
                        ser.println(cmd);

                        Serial.println(cmd);
                        delay(1000);

                        if(ser.find(">")){

                            ser.print(getStr);
                            delay(1000);
                            Serial.println("GData >"+getStr);
                            if(ser.find("On"))

                                    {
                                    digitalWrite(13,1); // toggle pin
                                    Serial.print("Turn On!!!");
                                    }

                                    else
                                    {
                                        digitalWrite(13,0); // toggle pin
                                    Serial.print("Turn Off!!!");

                                    }
                        }
                        else{
                            ser.println("AT+CIPCLOSE");

                            // alert user

                                                           140]]></page><page Index="150"><![CDATA[Serial.println("AT+CIPCLOSE");

                        }
                        // thingspeak needs 15 sec delay between updates
                        delay(5000);
                    }
                    //偵測副程式

                    void DetectSensor()
                    {
                        delay(1000);

                        h = dht.readHumidity();      //取得濕度
                        t = dht.readTemperature();    //取得溫度 C
                        Serial.print("Humidity: ");
                        Serial.print(h);

                        Serial.print(" %\t");
                        Serial.print("Temperature: ");
                        Serial.print(t);
                        Serial.println(" *C ");


                        lcd.clear();
                        lcd.setCursor(0, 0);    //設定游標位置  (字,行)
                        lcd.print("RH    :"); //Humidity

                        lcd.setCursor(7, 0);
                        lcd.print(h);
                        lcd.setCursor(14, 0);
                        lcd.print("%");


                        lcd.setCursor(0, 1);    //設定游標位置  (字,行)
                        lcd.print("Temp:");//Temperature
                        lcd.setCursor(7, 1);

                        lcd.print(t);
                        lcd.setCursor(13, 1);
                        lcd.print((char)223); //用特殊字元顯示符號的"度"
                        lcd.setCursor(14, 1);

                        lcd.print("C");

                    //水位偵測
                      int value = analogRead(A0);

                        Serial.print(value);

                                                           141]]></page><page Index="151"><![CDATA[Serial.print("      ");

                        temp=(long)analogRead(0); //讀出類比量值
                        data=(temp/670)*4;
                        Serial.print("the depth is:");
                        Serial.print(data);

                        Serial.println("cm");
                        delay(1000);
                        lcd.clear();
                        lcd.setCursor(0, 0);    //設定游標位置  (字,行)

                        lcd.print("Water:"); //Humidity
                        lcd.setCursor(7, 0);
                        lcd.print(data);
                        lcd.setCursor(14, 0);

                        lcd.print("cm");
                    //抽水自動控制
                        if (t > 28 ) //溫度控制
                        {

                            //digitalWrite(outPin, 1);//開
                            digitalWrite(RoutPin, 1);//relay 開
                        }else if(h<20) //濕度控制
                            {
                            //digitalWrite(outPin, 1);//Led 開

                            digitalWrite(RoutPin, 1);//relay 開
                            }
                        else

                        {
                            //digitalWrite(outPin, 0);//關
                            digitalWrite(RoutPin, 0);//關
                        }

                    }


                   3.8.2 Web


                   將 arduino 傳來之資料，透過 php $_GET 方式寫入 mysql 資料庫內。
                    Insert.php

                    <?php

                    //http://127.0.0.1/iot/insert.php?temp=25&humi=50&water=10

                                                           142]]></page><page Index="152"><![CDATA[DEFINE ('DBServer', 'localhost');

                    DEFINE ('DBName', 'iotFarm');
                    DEFINE ('DBUser', 'root');
                    DEFINE ('DBPw', '');


                    $conDb = mysqli_connect(DBServer,DBUser,DBPw);
                    if (!$conDb) {
                            die("Can not connect to DB: " . mysqli_error($conDb));
                            exit();

                    }

                    $selectDb = mysqli_select_db($conDb, DBName);
                    if (!$selectDb) {

                            die("Database selection failed: " . mysqli_error($conDb));
                            exit();
                    }
                    $temp = mysqli_real_escape_string($conDb, $_GET['temp']);

                    $humi = mysqli_real_escape_string($conDb,$_GET['humi']);
                    $water = mysqli_real_escape_string($conDb,$_GET['water']);
                    $Y=date('Y');
                    $m=date('m');

                    $d=date('d');
                    $H=date('H')+8;
                    $i=date('i');
                    $s=date('s');

                    $datetime = $Y ."-".    $m . "-" . $d . " " . $H . ":" . $i .":".$s;
                    $query = "INSERT INTO iotdata (temp, humi,water, datetime) VALUES ('$temp',
                    '$humi', '$water','$datetime')";
                    $result = mysqli_query($conDb, $query) or trigger_error("query error " .

                    mysqli_error($conDb));
                    mysqli_close($conDb);
                    ?>


                   顯示曲線圖
                    Odc.php
                    <?php

                    $servername = "localhost";
                    $username = "root";

                                                           143]]></page><page Index="153"><![CDATA[$password = "";

                    $dbname = "iotFarm";
                    $d ="";
                    $h ="";
                    $t ="";

                    $w ="";

                    // Create connection
                    $conn = new mysqli($servername, $username, $password, $dbname);

                    // Check connection
                    if ($conn->connect_error) {
                        die("Connection failed: " . $conn->connect_error);
                    }


                    $sql = "SELECT * FROM iotdata order by id desc";
                    $result = $conn->query($sql);


                    if ($result->num_rows > 0) {
                        // output data of each row
                        while($row = $result->fetch_assoc()) {
                            $d .= "'".$row["datetime"]."'". " , ";

                         $h .= "'".$row["humi"]."'". " , ";
                            $t .= "'".$row["temp"]."'". " , ";
                            $w .= "'".$row["water"]."'". " , ";
                        }

                    } else {
                        echo "0 results";
                    }
                    $conn->close();

                    ?>
                    <!DOCTYPE html>
                    <html style="height: 100%">
                          <head>

                                  <meta charset="utf-8">
                               <!-- <meta http-equiv='refresh' content='5'/>-->
                          </head>


                          <body style="height: 100%; margin: 0">

                                                           144]]></page><page Index="154"><![CDATA[<br>

                    <br>
                                  <div id="container" style="height: 300%;width:100%" ></div>
                                  <script type="text/javascript" src="echarts.min.js"></script>
                                  <script type="text/javascript">

                    var dom = document.getElementById("container");
                    var myChart = echarts.init(dom);
                    var app = {};
                    option = null;

                    var colors = ['#5793f3', '#d14a61', '#675bba'];
                    option = {
                            color: colors,


                            tooltip: {
                                    trigger: 'none',
                                    axisPointer: {
                                            type: 'cross'

                                    }
                            },
                            legend: {
                            },

                            grid: {
                                    top: 70,
                                    bottom: 50
                            },

                            xAxis: [
                                    {
                                            type: 'category',
                                            axisTick: {

                                                    alignWithLabel: true
                                            },
                                            axisLine: {
                                                    onZero: false,

                                                    lineStyle: {
                                                            color: colors[1]
                                                    }
                                            },

                                            axisPointer: {

                                                           145]]></page><page Index="155"><![CDATA[label: {

                                                            formatter: function (params) {
                                                                    return '溫度    ' + params.value
                                                                            + (params.seriesData.length ? '：' +
                    params.seriesData[0].data : '');

                                                            }
                                                    }
                                            },
                                            data: [<?php echo $d;?>]

                                    },
                                    {
                                            type: 'category',
                                            axisTick: {

                                                    alignWithLabel: true
                                            },
                                            axisLine: {
                                                    onZero: false,

                                                    lineStyle: {
                                                            color: colors[0]
                                                    }
                                            },

                                            axisPointer: {
                                                    label: {
                                                            formatter: function (params) {
                                                                    return '濕度    ' + params.value

                                                                            + (params.seriesData.length ? '：' +
                    params.seriesData[0].data : '');
                                                            }
                                                    }

                                            },
                                            data: [<?php echo $d;?>]
                                    }
                            ],

                            yAxis: [
                                    {
                                            type: 'value'
                                    }

                            ],

                                                           146]]></page><page Index="156"><![CDATA[series: [

                                    {
                                            name: '濕度',
                                            type: 'line',
                                            xAxisIndex: 1,

                                            smooth: true,
                                            data: [<?php echo $h;?>]
                                    },
                                    {

                                            name: '溫度',
                                            type: 'line',
                                            smooth: true,
                                            data: [<?php echo $t;?>]

                                    },
                                    {
                                            name: '水位',
                                            type: 'line',

                                            smooth: true,
                                            data: [<?php echo $w;?>]
                                    }
                            ]

                    };
                    ;
                    if (option && typeof option === "object") {
                            myChart.setOption(option, true);

                    }
                                  </script>
                          </body>
                    </html>


                   以 php 開讀檔方式，網頁控制 Arduino 抽水馬達。
                    on.php


                    <?php
                    $str = "On";
                            $file = fopen("test.txt","w+"); //開啟檔案

                            fwrite($file,$str);
                            fclose($file);

                                                           147]]></page><page Index="157"><![CDATA[header( "location:page1.php");    //回 index.php

                    ?>
                    Off.php
                    <?php
                    $str = "Off";

                            $file = fopen("test.txt","w+"); //開啟檔案
                            fwrite($file,$str);
                            fclose($file);
                    header( "location:page1.php");    //回 index.php

                    ?>

                   主頁面

                    Page1.php
                    <!DOCTYPE html>
                    <html    >

                    <head>
                        <meta charset="UTF-8">
                        <meta http-equiv="X-UA-Compatible" content="IE=edge">
                        <meta name="generator" content="Mobirise v5.2.0, mobirise.com">
                        <meta name="viewport" content="width=device-width, initial-scale=1,

                    minimum-scale=1">
                        <link rel="shortcut icon" href="assets/images/logo-121x121.png"
                    type="image/x-icon">

                        <meta name="description" content="">
                        <title>Page 1</title>
                        <link rel="stylesheet" href="assets/web/assets/mobirise-icons2/mobirise2.css">
                        <link rel="stylesheet" href="assets/tether/tether.min.css">
                        <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">

                        <link rel="stylesheet" href="assets/bootstrap/css/bootstrap-grid.min.css">
                        <link rel="stylesheet" href="assets/bootstrap/css/bootstrap-reboot.min.css">
                        <link rel="stylesheet" href="assets/dropdown/css/style.css">

                        <link rel="stylesheet" href="assets/socicon/css/styles.css">
                        <link rel="stylesheet" href="assets/theme/css/style.css">
                        <link rel="preload" as="style" href="assets/mobirise/css/mbr-
                    additional.css"><link rel="stylesheet" href="assets/mobirise/css/mbr-
                    additional.css" type="text/css">

                    </head>
                    <body>

                                                           148]]></page><page Index="158"><![CDATA[<section class="menu cid-s48OLK6784" once="menu" id="menu1-m">

                            <nav class="navbar navbar-dropdown navbar-fixed-top navbar-expand-lg
                    navbar-dark bg-dark">
                                    <div class="container">
                                            <div class="navbar-brand ">

                                                    <span class="navbar-logo">
                                                                    <img src="assets/images/logofarm.png"
                    alt="Mobirise" style="height: 2.8rem;">
                                                    </span>

                                                    <span class="navbar-caption-wrap"><a class="navbar-caption
                    text-primary display-2" href="index.html">智慧農場</a></span>
                                            </div>
                                            <button class="navbar-toggler " type="button" data-

                    toggle="collapse" data-target="#navbarSupportedContent" aria-
                    controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle
                    navigation">
                                                    <div class="hamburger">

                                                            <span></span>
                                                            <span></span>
                                                            <span></span>
                                                            <span></span>

                                                    </div>
                                            </button>
                                            <div class="collapse navbar-collapse"
                    id="navbarSupportedContent">

                                                    <ul class="navbar-nav nav-dropdown nav-right " data-app-
                    modern-menu="true">
                                       <li class="nav-item"><a class="nav-link link    text-primary
                    display-4" id="goHome" href="index.html">回首頁</a></li>

                                                      </ul>
                                            </div>
                                    </div>
                            </nav>

                    </section>
                    <section class="pricing1 cid-sgA38kY8B3"      id="pricing1-p">
                            <div class="container">
                                    <div class="row justify-content-center">

                                            <div class="card col-12 col-lg-6">

                                                           149]]></page><page Index="159"><![CDATA[<a id="btn1" class="btn btn-light display-4"

                    style="display:none;background-color:#2299AA" ><img
                    src="assets/images/on1.png"></a>
                                                            <a id="btn2" class="btn btn-light display-4 "
                    style="background-color:#2299AA" ><img    src="assets/images/off1.png"></a>


                                            </div>
                                    </div>
                            </div>

                    </section>
                    <div style="margin: 50px;">
                            <img src="assets/images/data1.png">
                            <?php

                            include("select.php");
                            ?>
                            <span class="styleSpan" ><?php echo $h ?></span>
                            <span class="styleSpan"><?php echo $w ?></span>

                            <span class="styleSpan2">5</span>
                    </div>
                    <section class="header1 cid-rSTTteTWbo" id="header16-1">
                            <br>

                            <br>
                            <br>
                            <?php
                            include("odc.php");

                            ?>
                                                  </div>
                                            </div>
                                    </div>

                            </section>
                    <section class="footer7 cid-sgQCGLKA4c" once="footers" id="footer7-6"
                    style="background-color: #000;>
                            <div class="container">

                                    <div class="media-container-row align-center mbr-white">
                                            <div class="col-12">
                                            <p>By Joker Wu</p>
                                            <p>All Rights Reserved</p>



                                                           150]]></page><page Index="160"><![CDATA[</div>

                                    </div>
                            </div>
                    </section>
                    <section style="background-color: #fff; font-family: -apple-system,

                    BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
                    color:#aaa; font-size:12px; padding: 0; align-items: center; display: flex;"><a
                    href="https://mobirise.site/c" style="flex: 1 1; height: 3rem; padding-left:
                    1rem;"></a><p style="flex: 0 0 auto; margin:0; padding-right:1rem;">Site <a

                    href="https://mobirise.site/f" style="color:#aaa;">was built</a> with
                    Mobirise</p></section><script
                    src="assets/web/assets/jquery/jquery.min.js"></script>    <script
                    src="assets/popper/popper.min.js"></script>    <script

                    src="assets/tether/tether.min.js"></script>    <script
                    src="assets/bootstrap/js/bootstrap.min.js"></script>    <script
                    src="assets/smoothscroll/smooth-scroll.js"></script>    <script
                    src="assets/dropdown/js/nav-dropdown.js"></script>    <script

                    src="assets/dropdown/js/navbar-dropdown.js"></script>    <script
                    src="assets/touchswipe/jquery.touch-swipe.min.js"></script>    <script
                    src="assets/theme/js/script.js"></script>
                        <script src="assets/web/assets/jquery/jquery.min.js"></script>

                        <script src="assets/popper/popper.min.js"></script>
                        <script src="assets/bootstrap/js/bootstrap.min.js"></script>
                        <script src="assets/tether/tether.min.js"></script>
                        <script src="assets/smoothscroll/smooth-scroll.js"></script>

                        <script src="assets/dropdown/js/nav-dropdown.js"></script>
                        <script src="assets/dropdown/js/navbar-dropdown.js"></script>
                        <script src="assets/touchswipe/jquery.touch-swipe.min.js"></script>
                        <script src="assets/theme/js/script.js"></script>

                        <script>
                            var btn = false;
                            $("#btn1").click(function(){
                                            if(btn){

                                                    $("#btn1").hide();
                                                    $("#btn2").show();
                                                    btn = false;
                                            }else{

                                                    $("#btn1").show();

                                                           151]]></page><page Index="161"><![CDATA[$("#btn2").hide();

                                                    btn = true;
                                            }
                                            $.ajax({
                                                    url:"off.php",

                                                    type:"GET",
                                                    data:"",
                                                    success: function(){},
                                                    error:function(){alert('error');}

                                            });
                                    });
                                    $("#btn2").click(function(){
                                            if(btn){

                                                    $("#btn1").hide();
                                                    $("#btn2").show();
                                                    btn = false;
                                            }else{

                                                    $("#btn1").show();
                                                    $("#btn2").hide();
                                                    btn = true;
                                            }

                                            $.ajax({
                                                    url:"on.php",
                                                    type:"GET",
                                                    data:"",

                                                    success: function(){},
                                                    error:function(){alert('error');}
                                            });
                                    });

                            </script>
                    </body>
                    </html>














                                                           152]]></page><page Index="162"><![CDATA[圖 3.35 智慧農場開場動畫




























                                                 圖 3.36 智慧農場首頁












                                                           153]]></page><page Index="163"><![CDATA[圖 3.37 智慧農場變化曲線


                   3.8.3 App


                        本專案 App 以 Thunkable(https://thunkable.com/)工具建置，如圖 3.38 所
                   示，開啟後點選左側工具箱內 Web Viewer 框架工具，如圖 3.39 所示，在右側
                   屬性視窗輸入 url，如圖 3.40 所示，最後於上方選單點擊，如圖 3.41 所示，輸
                   出下載 iOS 或 Android 安裝檔，成果 App 執行畫面如圖 3.42、圖 3.43 所示。


























                                              圖 3.38 Thunkable  開發工具


                                                           154]]></page><page Index="164"><![CDATA[圖 3.39 Thunkable Web Viewer





























                                          圖 3.40 Thunkable Web Viewer  設定




















                                                           155]]></page><page Index="165"><![CDATA[圖 3.41 Thunkable  輸出 iOS、Android 安裝檔









































                                         圖 3.42 智慧農場 App 開場動畫、首頁













                                                           156]]></page><page Index="166"><![CDATA[圖 3.43 智慧農場 App 曲線


                   3.8.4 MySQL


                        phpMyAdmin 是一套以 PHP 為基礎，以網頁方式建立在伺服器上，讓管理
                   者可以透過網頁的介面去管理 MySQL 資料庫。首先確定伺服器已啟動，如果不
                   知道如何看的話，可以直接在網址輸入 localhost 或者 127.0.0.1，查看頁面是否有

                   網 頁 資 訊 。 接 著 我 們 就 透 過 網 址 來 登 入 phpMyAdmin ， 在 網 址 輸 入
                   localhost/phpmyadmin 或者 127.0.0.1/phpmyadmin，WampServer 預設帳號為 root
                   密碼則不需填寫，如圖 3.44 所示，填寫完點執行。

































                                               圖 3.44 phpMyAdmin  登入
                   修改密碼

                   進入後的第一件事，不是新增資料表。基於安全性我們要幫 root 設定密碼，點

                                                           157]]></page><page Index="167"><![CDATA[擊頁面，如圖 3.45 所示，修改密碼來設定一組新密碼。





















                                                    圖 3.45 修改密碼


                   進入頁面後，在密碼那兩欄輸入你要設定的密碼，如圖 3.46 所示，之後點擊執
                   行。之後登入後就需要使用這組密碼才能登入。






















                                                    圖 3.46 密碼輸入

                   新增資料庫(Database)
                        在左側的主選單中點選新增，如圖 3.47 所示，然後再頁面的資料庫名稱輸
                   入你想命名的名稱，編碼方面選擇 utf8mb4_unicode_ci，然後點建立。



















                                                           158]]></page><page Index="168"><![CDATA[圖 3.47 新增資料庫

                   新增資料表(Table)
                        建立成功後，我們在 user 資料庫建立一張資料表，如圖 3.48 所示。資料表
                   名稱命名為 member 欄位數 4。






















                                                   圖 3.48 建立資料表


                        再來設定資料表的資料結構屬性值，如圖 3.49 所示填入相同的值。之後點
                   儲存，就建立好一張資料表了。

                   PRIMARY KEY(主鍵):代表欄位的 id 的值是唯一值，不會有相同的值。

                   AUTO_INCREMENT(自動累加):欄位的值會自動累加。
                   UNSIGNED:欄位值為正整數。















                                                           159]]></page><page Index="169"><![CDATA[圖 3.49 資料欄位結構


                   最後依據上述之教學，將本專案資料庫、資料表建立如圖 3.50 所示。

















                                              圖 3.50 智慧農場資料庫結構
                   3.8 成果



                        本專案搭配水族缸與壓克力做成控制盒後，其成果外觀如圖 3.51 所示。透
                   過本專案可學習到 Arduino 元件的控制與多執行緒使用，並且透過 Wifi 模組的
                   資料傳輸，了解無線網路的通訊方法及伺服器接收、寫入至資料庫，為後續物聯

                   網的運用奠定出基礎。























                                                 圖 3.51 智慧農場成果


                                                           160]]></page><page Index="170"><![CDATA[CH 4  居家智能系統









                             居家智能系統





                   4.1 專案概述


                        本專案透過 RFID 讀寫器模組，檢測並讀取晶片卡上之運算元，  當晶片卡
                   與電子鎖之傳輸訊號吻合時，即可達到開鎖；另外，本專案也透過 4*4 薄膜鍵盤

                   模擬現實中所應用之手動輸入密碼鎖，改變了人們出門時必須攜帶鑰匙的不便，
                   當輸入密碼時會將資料傳輸至內建程式，並藉由連接繼電器傳送指令至伺服馬達
                   執行開鎖的動作。


                   4.2 系統架構
































                                                圖 4.1 居家智能系統架構


                        依據系統架構，如圖 4.1 所示，可知其功能：透過 RFID 與薄膜鍵盤開啟門
                   鎖(伺服馬達模擬)，而當門鎖被打開或有動作時，LCD 顯示幕會顯示該 RFID 卡

                   片的卡號或輸入之密碼，再經過 Wifi 傳輸給伺服器紀錄，使用者即可從 App 上
                   得知何時門鎖被打開或有動作。
                                                           161]]></page><page Index="171"><![CDATA[4.3 技術說明


                        本專案開發工具與環境如 4.1 表，以 C 語言在 Arduino IDE 開發主要控制程
                   式，並經 ESP8266 Wifi 以 Get 傳輸方式傳輸資料至伺服器上。伺服器以 apache、
                   mysql 及 php 搭建環境，伺服器端前端網頁則再搭配 HTML5、Java Script、jQuery
                   等語言呈現曲線圖。最後再以 Thunkable 構建 webview 框架，將所撰寫的 RWD

                   前端網頁建置於框架內。

                                             表 4.1 智能居家系統開發環境

                    開發程式語言與 本系統應用採用 C、HTML5、Java Script、jQuery、PHP 等
                    技術                  開發語言完成
                    資料交換技術              Post/Get  傳輸

                    系統開發工具              Ardunio Sketch、Notpad++、Thunkable
                    作業系統軟體              Win10、Android、iOS
                    Web Server          apache

                    DB Server           mysql


                   4.4 硬體接線



































                                                圖 4.2 智能居家硬體接線

                        本專案硬體接線如圖 4.2 所示，Arduino 腳位 2、3 與 ESP8266 Tx、Rx 連接。
                   腳位 4、5 則連接薄膜鍵盤列(ROWS)的腳位左邊數來第 4、3 腳其原因為 RFID


                                                           162]]></page><page Index="172"><![CDATA[SPI 介面的晶片線會佔據 Arduino 數位 10 腳，以及 MISO、MOSI 各又佔據 12、

                   11 腳。因此薄膜鍵盤的腳位以:
                   列(ROWS)的腳位：從最左邊算起 4 個 PIN(A2, A3, 5, 4)。
                   行(COLS)的腳位：從最右邊算起 4 個 PIN(6,7,8,9)  。
                   RFID  接腳則為: 3.3V 接 3V、RST(重置)接  A0、GND 接 GND、MISO(主機<-資
                   料)接 12、MOSI(主機->資料)接 11、SCK(時脉)接 13、SDA(晶片選擇)接 10。

                                                                        2
                   伺服馬達則接在 A1，A4、A5 分別接 LCD 1206 上 I C SDA 與 SCL 腳位。最後，
                   3V 電源供給 ESP8266 與 RFID，5V 電源供給伺服馬達與 LCD。GND 則與所有
                   元件共地。完成接線後如圖 4.3 所示，Arduino 電源可以電池驅動，其相關元件

                   可參照 BOM 表 4.2。






















                                           圖 4.3 BOM 表電子零件組裝完成


                                                 表 4.2 居家智能 BOM
                       名稱                   用量               說明

                       Ardunio Uno          1                主機板
                       LCD 1602             1                LCD 顯示幕
                       4x4 矩陣薄膜鍵盤  1                         輸入密碼

                       SG90 Micro Servo  1                   伺服馬達
                       Relay                1                單路繼電器
                       ESP8266 12F          1                Wifi 模組

                       RFID-RC522           1                讀寫器模組
                       電阻 220Ω              2                ESP8266 MOD 用
                       POWER-MB102          1                麵包版專用電源模組
                       控制盒                  1








                                                           163]]></page><page Index="173"><![CDATA[4.5 元件介紹


                   4.5.1 SG90 Micro Servo 伺服馬達（servo motor）


























                                   圖 4.4 SG90 Micro Servo 伺服馬達（servo motor）


                        SG90 Micro Servo 伺服馬達（servo motor），因常用於遙控模型飛機，所以又
                   稱為 RC 伺服機（RC Servo，Radio Control Servo，Remote Control Servo）、伺服
                   馬達舵機。於伺服馬達內含有直流馬達、齒輪箱、軸柄、以及控制電路，可透過
                   訊號控制軸柄的停止角度，大多為 0 到 180 度，但不同廠牌型號會有不同的範
                   圍；經由齒輪箱降速後，變成適當可用的轉速，並且提供更高的轉矩（扭轉力）。






























                                             圖 4.5 SG90 Micro Servo 接線



                                                           164]]></page><page Index="174"><![CDATA[Arduino 內建操控伺服馬達的程式庫，已經將零零總總的東西通通包起來，

                   使用方法非常簡單，讓我們能以非常簡單的方式操控伺服馬達的旋轉角度。因為
                   需使用 PWM，所以會影響原本的 PWM 腳位，使用此程式庫時，數位腳位 9 與
                   10 便無法輸出 PWM，不管有無接伺服馬達，於是我們通常也會將伺服馬達的訊
                   號線接在數位腳位 9 或 10。


                    #include <Servo.h>

                    Servo myservo; //  建立 Servo 物件，控制伺服馬達


                    void setup()
                    {
                        myservo.attach(9); //  連接數位腳位 9，伺服馬達的訊號線

                    }

                    void loop()
                    {

                        for(int i = 0; i <= 180; i+=1){
                            myservo.write(i); //  使用 write，傳入角度，從 0 度轉到 180 度
                            delay(20);
                        }

                        for(int i = 180; i >= 0; i-=1){
                            myservo.write(i);//  使用 write，傳入角度，從 180 度轉到 0 度
                            delay(20);
                        }

                    }

                        不過 Servo 預設的脈衝寬度範圍是 544 到 2400µs，跟 SG90 的 500 到 2400
                   差了一些些，我們可修正此點。Servo 程式庫中，還有 read()可用，但只是讀取上
                   次傳入 write()的值。


                    #include <Servo.h>


                    Servo myservo;
                    int readdata=0;//取得上次角度用變數
                    void setup()
                    {

                    Serial.begin (9600);

                                                           165]]></page><page Index="175"><![CDATA[readdata = myservo.read ();//取得前次角度

                    Serial.print ( readdata );

                        myservo.attach(9, 500, 2400); //  修正脈衝寬度範圍
                        myservo.write(90); //  一開始先置中 90 度

                        delay(3000);
                    }

                    void loop()

                    {
                        for(int i = 500; i <= 2400; i+=100){
                            myservo.writeMicroseconds(i); //  直接以脈衝寬度控制


                            delay(300);
                        }
                        for(int i = 2400; i >= 500; i-=100){
                            myservo.writeMicroseconds(i);


                            delay(300);
                        }
                    }



                   4.5.2 4×4 矩陣薄膜鍵盤



























                                                圖 4.6 4×4 矩陣薄膜鍵盤



                                                           166]]></page><page Index="176"><![CDATA[4×4 矩陣薄膜鍵盤，該鍵盤帶有 8P 杜邦頭，間距 2.54mm。可插上排針，接

                   著連接到 Arduino，使用非常簡單。鍵盤背面白色貼紙可揭去，能牢固粘貼於機
                   箱表面。可用它輸入數字參數等信息，特別是對於 LCD 模塊，GSM/GPRS 模塊
                   等需要參數輸入的模塊。薄膜防水耐用，可經受幾萬次按壓。
                   列(ROWS)的腳位：從最左邊算起 4 個 PIN(11, 10, 9, 8)。
                   行(COLS)的腳位：從最右邊算起 4 個 PIN(7, 6, 5, 4)。


                        鍵盤的程式並不難，其實可以不用函式庫就能自行寫出來，但為了方便，
                   還是習慣用函式庫，選擇的是最常見的 Adafruit Keypad 函庫。撰寫 Arduino 按

                   鍵偵測程式，最簡單也是最好的方式，就是採用既有的程式庫。本單元將示範
                   使用 Keypad 程式庫，把偵測到的按鍵字元顯示在序列埠監控視窗。如圖 4.7 所
                   示，安裝 Keypad 程式庫。






























                                               圖 4.7 安裝 Keypad 程式庫

                   使用此程式庫，我們的程式碼需要定義按鍵模組的行（col）、列（row）數、連
                   接 Arduino 的腳位以及按鍵所代表的字元。

                    //4x4 薄膜鍵盤範例程式

                    #include "Adafruit_Keypad.h"


                    const byte ROWS = 4; //  列數(橫的)
                    const byte COLS = 4; //  行數(直的)
                    //鍵盤上每一個按鍵的名稱

                    char keys[ROWS][COLS] = {

                                                           167]]></page><page Index="177"><![CDATA[{'1','2','3','A'},

                        {'4','5','6','B'},
                        {'7','8','9','C'},
                        {'*','0','#','D'}
                    };
                    byte rowPins[ROWS] = {11, 10, 9, 8}; //定義列的腳位

                    byte colPins[COLS] = {7, 6, 5, 4}; //定義行的腳位

                    //初始化鍵盤

                    Adafruit_Keypad customKeypad = Adafruit_Keypad( makeKeymap(keys), rowPins,
                    colPins, ROWS, COLS);

                    void setup() {

                        Serial.begin(9600);
                        customKeypad.begin();
                        Serial.println("KeyPad Test...");
                    }


                    void loop() {
                        //  開始偵測使用者的按鍵狀態
                        customKeypad.tick();


                        //判斷按了哪一個鍵
                        while(customKeypad.available()){
                            keypadEvent e = customKeypad.read();

                            Serial.print((char)e.bit.KEY);
                            if(e.bit.EVENT == KEY_JUST_PRESSED) Serial.println(" pressed");
                            //按下的狀態是 KEY_JUST_PRESSED
                            else if(e.bit.EVENT == KEY_JUST_RELEASED) Serial.println(" released");
                            //放開的狀態是 KEY_JUST_RELEASED

                        }

                        delay(10);

                    }

                   不使用程式庫的程式範例
                    const byte colPins[4] = {9, 8, 7, 6};          //  設定「行」腳位
                    const byte rowPins[4] = {13, 12, 11, 10}; //  設定「列」腳位


                                                           168]]></page><page Index="178"><![CDATA[const char keymap[4][4] = {          //  設定按鍵的「行、列」代表值

                            {'1','2','3','A'},
                            {'4','5','6','B'},
                            {'7','8','9','C'},
                            {'*','0','#','D'}

                    };

                    byte i, j;            //  暫存迴圈的索引數字
                    byte scanVal;      //  暫存掃描到的按鍵值


                    void setup(){
                        Serial.begin(9600);


                        for (i = 0; i < = 3; i++) {
                            pinMode(rowPins[i], INPUT);
                            pinMode(colPins[i], OUTPUT);
                            digitalWrite(colPins[i], HIGH);

                            digitalWrite(rowPins[i], HIGH);
                        }
                    }


                    void loop() {
                        for (i = 0; i <= 3; i++) {
                            for (j = 0; j <= 3; j++) {
                                digitalWrite(colPins[j], LOW);

                                scanVal = digitalRead(rowPins[i]);

                                if (scanVal == LOW) {        //  如果輸入值是「低電位」…
                                    Serial.println(keymap[i][j]);    //  輸出按鍵代表的字元
                                    delay(200);    //  掃描按鍵的間隔時間

                                    digitalWrite(colPins[j], HIGH);
                                    break;              //  跳出迴圈
                                }

                                digitalWrite(colPins[j], HIGH);
                            }
                        }
                    }



                                                           169]]></page><page Index="179"><![CDATA[4.5.3 RFID-RC522














































                                                   圖 4.8 RFID-RC522

                        RFID-RC522 讀寫器模組，主要應用於 13.56MHz 非接觸式通信中高集成度

                   的讀寫卡芯片，是針對“三表＂應用推出的一款低電壓、低成本、體積小的非接
                   觸式讀寫卡芯片，是智能儀表和便攜式手持設備研發的較好選擇。這裏我們使用
                   的  RFID  識別裝置的型號為  RC522，RC522  主要針對  13.56MHZ  的無線電頻
                   率識別，工作電壓為  3.3V  ，上頭共有八支接腳，分別是  SDA、SCK、MOSI、

                   MISO、IRQ、GND、RST、VCC，其中  SDA、SCK、MOSI、MISO  負責訊號的
                   輸入和輸出。SPI 匯流排規定了 4 個保留邏輯訊號介面：
                   SCLK（Serial Clock）：串列時脈，由主機發出
                   MOSI（Master Output, Slave Input）：主機輸出從機輸入訊號（資料由主機發出）

                   MISO（Master Input, Slave Output）：主機輸入從機輸出訊號（資料由從機發出）
                   SS（Slave Select）：片選訊號，由主機發出，一般是低電位有效
                        由於  Arduino UNO  本身的數位腳各自有各自的功能，13  對應  Serial Clock
                   ( SCK )，12  對應  Master-in slave-out ( MISO )，11  是  Master-out slave-in ( MOSI )，

                   10  是  Slave select ( SS )，因此我們將** SDA  接  10，SCK  接  13，MOSI  接  11，

                                                           170]]></page><page Index="180"><![CDATA[MISO  接  12，IRQ  是中斷的腳位，RST  是重置的腳位**，這裡就我不需要接這

                   兩個接腳。至於  GND  接在  GND，VCC  接在  3.3V  的位置  (  注意不要接成  5V
                   或  VCC，可能會燒壞  )，接線可參照圖 4.9。


























                                                 圖 4.9 MFRC522 接線


                   完成接線後，再來就是安裝 MFRC522 函式庫，如圖 4.10 所示，在程式管理員
                   中直接下載。






























                                             圖 4.10 MFRC522 函式庫安裝

                   底下列舉本單元使用到的 MFRC522 程式物件的方法和屬性：
                   MFRC522 物件.PCD_Init()：初始化 MFRC522 讀卡機模組
                   MFRC522 物件.PICC_IsNewCardPresent()：是否感應到新的卡片


                                                           171]]></page><page Index="181"><![CDATA[MFRC522 物件.PICC_ReadCardSerial()：讀取卡片的資料

                   MFRC522 物件.PICC_GetType()：取得卡片類型
                   MFRC522 物件.PICC_GetTypeName()：取得卡片類型名稱
                   每張 Mifare 卡片都有個唯一的 ID（unique identifier，簡稱 UID），當讀寫機讀取
                   到卡片的資料之後，UID 的長度和內容，可從底下兩個屬性值取得：
                   MFRC522 物件.uid.size：包含 UID 的長度

                   MFRC522 物件.uid.uidByte：包含 UID 碼的陣列

                   SPI  是一種四線制串列匯流排介面，為主/從結構，四條導線分別為串列時脈

                   (SCLK)、主出從入(MOSI)、主入從出(MISO)和從選(SS)訊號。主元件為時脈提供
                   者，可發起讀取從元件或寫入從元件作業。這時主元件將與一個從元件進行對話。
                   當匯流排上存在多個從元件時，要發起一次傳輸，主元件將把該從元件選擇線拉
                   低，然後分別透過 MOSI 和 MISO 線路啟動數據發送或接收。Arduino  已經提供

                   SPI 函式庫  ，在  Arduino  程式標頭加上  #include <SPI.h>  便可以使用  SPI 函式
                   庫。

                   程式範例

                    #include <SPI.h>
                    #include <MFRC522.h>          //  引用程式庫

                    #define RST_PIN            A0                //  讀卡機的重置腳位
                    #define SS_PIN              10                //  晶片選擇腳位


                    MFRC522 mfrc522(SS_PIN, RST_PIN);    //  建立 MFRC522 物件


                    void setup() {
                        Serial.begin(9600);
                        Serial.println("RFID reader is ready!");


                        SPI.begin();
                        mfrc522.PCD_Init();      //  初始化 MFRC522 讀卡機模組
                    }


                    void loop() {
                            //  確認是否有新卡片
                            if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial())
                    {
                                byte *id = mfrc522.uid.uidByte;      //  取得卡片的 UID


                                                           172]]></page><page Index="182"><![CDATA[byte idSize = mfrc522.uid.size;      //  取得 UID 的長度


                                Serial.print("PICC type: ");            //  顯示卡片類型
                                //  根據卡片回應的 SAK 值（mfrc522.uid.sak）判斷卡片類型
                                MFRC522::PICC_Type                    piccType                      =

                    mfrc522.PICC_GetType(mfrc522.uid.sak);
                                Serial.println(mfrc522.PICC_GetTypeName(piccType));

                                Serial.print("UID Size: ");              //  顯示卡片的 UID 長度值

                                Serial.println(idSize);

                                for (byte i = 0; i < idSize; i++) {    //  逐一顯示 UID 碼
                                    Serial.print("id[");

                                    Serial.print(i);
                                    Serial.print("]: ");
                                    Serial.println(id[i], HEX);              //  以 16 進位顯示 UID 值
                                }

                                Serial.println();

                                mfrc522.PICC_HaltA();    //  讓卡片進入停止模式
                            }

                    }

                   副程式方法的程式範例
                    #include <SPI.h>

                    #include <MFRC522.h>

                    #define RST_PIN                  9
                    #define SS_PIN                    10    //就是模組上的 SDA 接腳



                    MFRC522 mfrc522;      //  建立 MFRC522 實體


                    void setup() {

                        Serial.begin(9600);

                        SPI.begin();                //  初始化 SPI 介面


                                                           173]]></page><page Index="183"><![CDATA[mfrc522.PCD_Init(SS_PIN, RST_PIN); //  初始化 MFRC522 卡
                        Serial.print(F("Reader "));
                        Serial.print(F(": "));
                        mfrc522.PCD_DumpVersionToSerial(); //  顯示讀卡設備的版本


                    }



                    void loop() {

                        //  檢查是不是一張新的卡
                        if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial()) {
                                //  顯示卡片內容

                                Serial.print(F("Card UID:"));
                                dump_byte_array(mfrc522.uid.uidByte,  mfrc522.uid.size);  //  顯示卡片的
                    UID

                                Serial.println();
                                Serial.print(F("PICC type: "));
                                MFRC522::PICC_Type                    piccType                      =
                    mfrc522.PICC_GetType(mfrc522.uid.sak);

                                Serial.println(mfrc522.PICC_GetTypeName(piccType));    //顯示卡片的類
                    型

                                mfrc522.PICC_HaltA();    //  卡片進入停止模式

                            }
                    }

                    /**
                      *  這個副程式把讀取到的 UID，用 16 進位顯示出來

                      */
                    void dump_byte_array(byte *buffer, byte bufferSize) {
                        for (byte i = 0; i < bufferSize; i++) {

                            Serial.print(buffer[i] < 0x10 ? " 0" : " ");
                            Serial.print(buffer[i], HEX);
                        }
                    }



                                                           174]]></page><page Index="184"><![CDATA[4.5.4  電源模組

































































                                              圖 4.11 麵包版專用電源模組
                        圖4.11為麵包版專用電源模組，上下兩路兩路獨立控制，可切換為 0V、3.3V、

                   5V 模組上具有兩組 3.3V、5V 直流輸出插針，方便外部做引出使用。








                                                           175]]></page><page Index="185"><![CDATA[4.6 軟體架構









































                                             圖 4.12 居家智能系統軟體架構


                        如圖 4.11 所示，當 Arduino 程式啟動時，LCD 顯示、RFID、薄膜鍵盤與
                   ESP8266 皆同時啟動進行，因此我們這時如第三章智慧農場專案一樣需要以多執
                   行緒的方式進行。在本專案的軟體思路上，分為 LCD 顯示與 RFID 感應、薄膜

                   鍵盤手動輸入兩執行緒，在自動控制上的執行緒，以 RFID、薄膜鍵盤輸入與
                   ESP8266 資料傳輸。而 LCD 顯示功能則較為單純，純粹判斷目前狀態顯示於 LCD
                   上。


                   4.7 系統程式


                        本專案與智慧農場專案相同，故需引入 Scoop 多執行緒庫，其關於 Scoop
                   多執行緒介紹請參照第三章。



                   4.7.1 Arduino

                   本專案 Arduino 主程式，可分為四個區塊介紹，其分別為前置命令與宣告、執行
                   緒、主程式、副程式。


                                                           176]]></page><page Index="186"><![CDATA[前置命令與宣告

                        首先我們引入 wifi 需使用的 SoftwareSerial.h 軟體序列函式以及多執行緒
                   Scoop 及 LCD 顯示 LiquidCrystal 函式庫，請相關介紹請參照第三章。
                    #include <SoftwareSerial.h>
                    #include <SCoop.h>
                    #include <LiquidCrystal_PCF8574.h>    //  引用 LCD 序列顯示器的程式庫

                   接著，引入 Keypad 函式庫，其相關介紹請參照本章元件介紹。
                    #include <Keypad.h>
                                          2
                   Wire.h  為 Arduino 的 I C 函式庫，可至 Arduino 官網 Wire.h 函式庫了解。
                    #include <Wire.h>
                   SPI 函式庫，在  Arduino  程式標頭加上  #include <SPI.h>  便可以使用  SPI 函式
                   庫，可至 Arduino 官網 Wire.h 函式庫了解。

                    #include <SPI.h>//RFID
                   MFRC522，其相關介紹請參照本章元件介紹。
                    #include <MFRC522.h>          // RFID 引用程式庫

                   Servo 伺服馬達函式庫，Arduino  內建，不用安裝。
                    #include <Servo.h>      //載入伺服馬達函式庫

                   薄膜按鍵相關宣告與變數

                    #define KEY_ROWS 4    //  薄膜按鍵的列數
                    #define KEY_COLS 4      //  薄膜按鍵的行數
                    //  設置按鍵模組

                    char keymap[KEY_ROWS][KEY_COLS] = {
                        {'1', '2', '3', 'A'},
                        {'4', '5', '6', 'B'},
                        {'7', '8', '9', 'C'},

                        {'*', '0', '#', 'D'}
                    };

                    byte rowPins[KEY_ROWS] = {A2, A3, 5,4}; //Rows 0 to 3

                    byte colPins[KEY_COLS] = {9, 8, 7, 6}; //Columns 0 to 3

                    Keypad keypad = Keypad(makeKeymap(keymap), rowPins, colPins, KEY_ROWS,
                    KEY_COLS);


                    String passcode = "1234";      //  預設密碼
                    String inputCode = "";            //  暫存用戶的按鍵字串

                    bool acceptKey = true;            //  代表是否接受用戶按鍵輸入的變數，預設為「接
                                                           177]]></page><page Index="187"><![CDATA[受」



                   LCD 1206  相關宣告與變數
                    #define LCD_ROWS 2    // LCD 顯示器的列數

                    #define LCD_COLS 16    // LCD 顯示器的行數
                    //  建立 LCD 顯示器物件：lcd(資料腳,  時脈腳, TWO_WIRE);
                    LiquidCrystal_PCF8574 lcd(0x27);    // LCD 設定 i2c 位址，一般情況就是 0x27
                    和 0x3F 兩種


                   RFID 相關宣告與變數
                    #define RST_PIN            A0                //  讀卡機的重置腳位
                    #define SS_PIN              10                //  晶片選擇腳位

                    MFRC522 mfrc522(SS_PIN, RST_PIN);    //  建立 MFRC522 物件
                    char *reference;
                    byte uid[]={0xB,0x44,0xA1,0x59};    //這是我們指定的卡片 UID，可由讀取 UID

                    的程式取得特定卡片的 UID，再修改這行

                   伺服馬達相關宣告與變數
                    Servo myservo;    //  建立 SERVO  伺服馬達物件


                   Wifi  相關宣告與變數
                    SoftwareSerial ser(2, 3); // RX, TX

                    String ssid="**************";    //無線基地台識別
                    String pwd="**************";    //無線基地台密碼
                    String server="192.168.0.1";      //這裡填入你要連線的目標 IP
                    String card="0"; //紀錄 RFID  卡號

                    #define DEBUG true

                   執行緒

                   本專案建立兩執行緒，一為 LCD 顯示用，另一為 RFID 用。使用上先建立出兩
                   線程。
                   defineTask(TaskTest1);//創建子線程 1
                   defineTask(TaskTest2);//創建子線程 2


                   於第一執行緒，子線程 1 做為 LCD 顯示用，於初始化時進行驅動 WifiConn()函
                   式建立 Wifi 連線以及 resetLocker()  進行 LCD 初始化。
                    void TaskTest1::setup()//線程 1 設定

                                                           178]]></page><page Index="188"><![CDATA[{

                        WifiConn();//ok
                        lcd.begin(16, 2); //  初始化 LCD
                        lcd.setBacklight(255);
                        lcd.clear();

                        resetLocker();
                    }
                    void TaskTest1::loop()//線程 1 循環
                    {

                    }

                   第二執行緒，子線程 2 做為 RFID 初始化用，主要進行 SPI 的啟動與初始化
                   MFRC522。

                    void TaskTest2::setup()//線程 2 設定
                    {
                        Serial.println("RFID reader is ready!");

                        SPI.begin();
                        mfrc522.PCD_Init(SS_PIN, RST_PIN); //  初始化 MFRC522 卡
                        mfrc522.PCD_DumpVersionToSerial(); //  顯示讀卡設備的版本
                    }


                    void TaskTest2::loop()//線程 2 循環
                    {
                    }


                   主程式
                   主程式 setup()初始化，主要進行 Wifi 連線、伺服馬達初始設定與執行多執行緒。
                    void setup() {

                        //WifiConn();
                        Serial.begin(9600);
                        ser.begin(9600);//Ardunio <-> Wifi
                        myservo.attach(A1);    //  設定要將伺服馬達接到哪一個 PIN 腳

                        mySCoop.start();
                    }



                   主程式 loop()為判斷鍵盤輸入與否以及 RFID 卡片的感應動作，經過判斷後啟動
                   openDoor()進行開門控制與 WifiSendata()資料傳輸。

                                                           179]]></page><page Index="189"><![CDATA[void loop()

                    {
                    //鍵盤  keypad
                            char key = keypad.getKey();

                        //  若目前接受用戶輸入，而且有新的字元輸入…

                        if (acceptKey && key != NO_KEY) {
                    if (key == '*') {      //  清除畫面
                                clearRow(4);    //  從第 4 個字元開始清除

                                inputCode = "";
                            } else if (key == '#') {    //  比對輸入密碼
                                WifiSendata(); //傳送資料至伺服器
                                checkPinCode();

                                //WifiConn();
                            } else {
                                inputCode += key;    //  儲存用戶的按鍵字元
                                //inputCode = inputCode+key;    //  儲存用戶的按鍵字元

                                lcd.print('*');
                                Serial.println(inputCode);
                                //WifiSendata(); //傳送資料至伺服器
                            }

                        }
                    //-----------
                    //  確認是否有新卡片
                            if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial())

                    {
                                byte *id = mfrc522.uid.uidByte;      //  取得卡片的 UID (第 20 行)
                                byte idSize = mfrc522.uid.size;      //  取得 UID 的長度
                                //
                                //把取得的 UID，拿來比對我們指定好的 UID

                                bool they_match = true; //  初始值是假設為真
                                for ( int i = 0; i < 4; i++ ) { //  卡片 UID 為 4 段，分別做比對
                                    if ( uid[i] != mfrc522.uid.uidByte[i] ) {

                                        they_match = false; //  如果任何一個比對不正確，they_match 就為
                    false，然後就結束比對
                                        break;
                                    }

                                }

                                                           180]]></page><page Index="190"><![CDATA[//在監控視窗中顯示比對的結果
                                if(they_match){
                                    Serial.print(F("Access Granted!"));
                                    //

                                    lcd.clear();
                                    lcd.setCursor(0, 0);    //設定游標位置  (字,行)
                                    lcd.print("UID:"); //"Card UID:"+


                                    byte *cuid = mfrc522.uid.uidByte;      //讀取卡片 ID
                                    byte cuidSize = mfrc522.uid.size;      //卡片 ID 的長度
                                    for (byte i = 0; i < cuidSize; i++) {
                                    //lcd.print("0x");
                                    lcd.print(cuid[i], HEX);            //顯示 id

                                    lcd.print(" ");
                                    card += String(cuid[i], HEX);
                                }


                                lcd.setCursor(0, 1);    //設定游標位置  (字,行)
                                lcd.print("Access Granted!");//

                                    //伺服馬達

                                    openDoor();
                                    WifiSendata(); //傳送資料至伺服器
                                    card="";

                                    //
                                    resetLocker();          //  重設 LCD 顯示文字和輸入狀態
                                }else{
                                    Serial.print(F("Access Denied!"));

                                }
                                //
                                mfrc522.PICC_HaltA();    //  讓卡片進入停止模式
                            }

                    //-----------
                        yield();
                    }




                                                           181]]></page><page Index="191"><![CDATA[副程式

                   本專案副程式有 sendData()、WifiSendata()此兩副程式可參照第三章智慧農場 3.8
                   節介紹。openDoor()為馬達開門控制程式、clearRow()清除 LCD 顯示、resetLocker()
                   重設 LCD 顯示與 checkPinCode()判斷密碼輸入。
                    //伺服馬達  開門

                    void openDoor() {
                              myservo.write(0);    //旋轉到 0 度，就是一般所說的歸零
                              sleep(1000);
                              myservo.write(90); //旋轉到 90 度

                              sleep(1000);
                              myservo.write(180); //旋轉到 180 度
                              sleep(1000);
                              myservo.write(90);

                              sleep(1000);
                    }

                   clearRow()，本函式為清除 LCD 顯示，當密碼輸入錯誤或感應後進行畫面清除。

                    void clearRow(byte n) {
                        byte last = LCD_COLS - n;
                        lcd.setCursor(n, 1); //  移動到第 2 行，"PIN:"之後


                        for (byte i = 0; i < last; i++) {
                            lcd.print(" ");
                        }

                        lcd.setCursor(n, 1); //  移回第 2 行，"PIN:"之後
                    }

                   resetLocker()，本函式為清除 LCD 顯示並初始化後進入待機狀態，當密碼輸入錯
                   誤或感應後進行畫面清除後回復待機。

                    //  顯示「GoGo JR...」後，重設 LCD 顯示文字和輸入狀態。
                    void resetLocker() {
                        lcd.clear();

                        lcd.print("GoGo JR...");
                        lcd.setCursor(0, 1);    //  切換到第 2 行
                        lcd.print("PIN:");
                        lcd.cursor();

                        acceptKey = true;
                        inputCode = "";

                                                           182]]></page><page Index="192"><![CDATA[}


                   checkPinCode()，本函式為比對密碼輸入，為本專案主要判斷程式。
                    //  比對輸入的密碼
                    void checkPinCode() {

                        acceptKey = false;    //  暫時不接受用戶按鍵輸入
                        clearRow(0);              //  從第 0 個字元開始清除 LCD 畫面
                        lcd.noCursor();
                        lcd.setCursor(0, 1);    //  切換到第 2 行

                        //  比對密碼
                        if (inputCode == passcode) {
                            lcd.print("Welcome home!");
                            openDoor();

                        } else {
                            lcd.print("***WRONG!!***");
                            //lcd.print(inputCode);

                            Serial.println(inputCode);
                        }
                        //delay(3000);
                        sleep(3000);
                        resetLocker();          //  重設 LCD 顯示文字和輸入狀態

                    }

                   本專案完整程式

                    /*
                    *  居家智慧  RFID  門禁系統  By Joker Wu
                    */
                    #include <SoftwareSerial.h>

                    #include <SCoop.h>
                    #include <Keypad.h>
                    #include <Wire.h>
                    #include <LiquidCrystal_PCF8574.h>    //  引用 LCD 序列顯示器的程式庫

                    #include <SPI.h>//RFID
                    #include <MFRC522.h>          // RFID 引用程式庫

                    #define KEY_ROWS 4    //  薄膜按鍵的列數
                    #define KEY_COLS 4      //  薄膜按鍵的行數

                    #define LCD_ROWS 2    // LCD 顯示器的列數

                                                           183]]></page><page Index="193"><![CDATA[#define LCD_COLS 16    // LCD 顯示器的行數

                    #define RST_PIN            A0                //  讀卡機的重置腳位
                    #define SS_PIN              10                //  晶片選擇腳位
                    #include <Servo.h>      //載入伺服馬達函式庫，內建的，不用安裝

                    Servo myservo;    //  建立 SERVO  伺服馬達物件


                    //  建立 LCD 顯示器物件：lcd(資料腳,  時脈腳, TWO_WIRE);
                    LiquidCrystal_PCF8574 lcd(0x27);    // LCD 設定 i2c 位址，一般情況就是 0x27

                    和 0x3F 兩種

                    //  設置按鍵模組
                    char keymap[KEY_ROWS][KEY_COLS] = {

                        {'1', '2', '3', 'A'},
                        {'4', '5', '6', 'B'},
                        {'7', '8', '9', 'C'},
                        {'*', '0', '#', 'D'}

                    };

                    byte rowPins[KEY_ROWS] = {A2, A3, 5,4}; //Rows 0 to 3
                    byte colPins[KEY_COLS] = {9, 8, 7, 6}; //Columns 0 to 3


                    Keypad keypad = Keypad(makeKeymap(keymap), rowPins, colPins, KEY_ROWS,
                    KEY_COLS);


                    String passcode = "1234";      //  預設密碼
                    String inputCode = "";            //  暫存用戶的按鍵字串
                    bool acceptKey = true;            //  代表是否接受用戶按鍵輸入的變數，預設為「接
                    受」


                    MFRC522 mfrc522(SS_PIN, RST_PIN);    //  建立 MFRC522 物件
                    char *reference;
                    byte uid[]={0xB,0x44,0xA1,0x59};    //這是我們指定的卡片 UID，可由讀取 UID

                    的程式取得特定卡片的 UID，再修改這行

                    //---wifi
                    SoftwareSerial ser(2, 3); // RX, TX
                    String ssid="**************";    //無線基地台識別


                                                           184]]></page><page Index="194"><![CDATA[String pwd="**************";    //無線基地台密碼

                    String server="192.168.0.1";      //這裡填入你要連線的目標 IP
                    String card="0"; //紀錄 RFID  卡號
                    #define DEBUG true
                    //---

                    //wifi send
                    String sendData(String command, const int timeout, boolean debug) {
                        String response="";
                        ser.print(command); // send the read character to the esp8266

                        long int time=millis();
                          do{
                            while(ser.available()) {
                                // The esp has data so display its output to the serial window

                                char c=ser.read(); // read the next character.
                                response += c;
                                }


                          if(response.charAt(response.length()-
                    2)=='O'&&response.charAt(response.length()-1)=='K'){
                              time=0;
                          }

                            }while ((time+timeout) > millis());
                        if (debug) {Serial.print(response);}

                        Serial.println(response);


                        return response;
                        }


                    //Wifi Connection
                    void WifiConn()
                    {
                    //wifi

                        ser.println("AT+RST");// reset ESP8266

                        String cmd="AT+CWJAP=\"";
                        cmd+=ssid;

                        cmd+="\",\"";

                                                           185]]></page><page Index="195"><![CDATA[cmd+=pwd;

                        cmd+="\"";
                        cmd+="\r\n";

                        Serial.println("*** SoftSerial connection to ESP8266 ***");
                        sendData("AT+CWMODE=3\r\n",100,DEBUG); //  設定為 STA 模式

                        sendData(cmd,10000,DEBUG); //  取得連線(視 AP 連線效能作調整，預設 7000
                    毫秒)
                        sendData("AT+CIFSR\r\n",100,DEBUG); //  獲得 IP

                        sendData("AT+CIPMUX=1\r\n",100,DEBUG); //  開啟多除連接模式
                        sendData("AT+CIPSERVER=1,80\r\n",100,DEBUG); //  設定連接埠為 8080
                        Serial.println("Ready");
                        //

                        //while (!Serial);
                    }

                    //Wifi Send

                    void WifiSendata()
                    {
                        //wifi
                        sendData("AT+CIFSR\r\n",100,DEBUG); //  獲得 IP

                        sleep(500);
                        // TCP connection
                        String cmd = "AT+CIPSTART=\"TCP\",\"";
                        cmd += server;

                        cmd += "\",80";
                        ser.println(cmd);

                        if(ser.find("Error")){

                            Serial.println("AT+CIPSTART error");
                            return;
                        }


                        // prepare GET string
                        String getStr = "GET /home/insert.php?cardnu=";
                        getStr +=card;
                        getStr +="&pwdr=";

                        getStr +=inputCode;

                                                           186]]></page><page Index="196"><![CDATA[getStr += "\r\n\r\n";


                        // send data length
                        cmd = "AT+CIPSEND=";
                        cmd += String(getStr.length());

                        ser.println(cmd);
                        Serial.println(cmd);

                        if(ser.find(">")){

                            ser.print(getStr);
                            Serial.println(">"+getStr);
                        }
                        else{

                            ser.println("AT+CIPCLOSE");
                            // alert user
                            Serial.println("AT+CIPCLOSE");
                        }

                        sleep(1000);
                    }

                    //伺服馬達  開門

                    void openDoor() {
                              myservo.write(0);    //旋轉到 0 度，就是一般所說的歸零
                              sleep(1000);
                              myservo.write(90); //旋轉到 90 度

                              sleep(1000);
                              myservo.write(180); //旋轉到 180 度
                              sleep(1000);
                              myservo.write(90);

                              sleep(1000);
                    }

                    void clearRow(byte n) {

                        byte last = LCD_COLS - n;
                        lcd.setCursor(n, 1); //  移動到第 2 行，"PIN:"之後

                        for (byte i = 0; i < last; i++) {

                            lcd.print(" ");

                                                           187]]></page><page Index="197"><![CDATA[}

                        lcd.setCursor(n, 1); //  移回第 2 行，"PIN:"之後
                    }

                    //  顯示「GoGo JR...」後，重設 LCD 顯示文字和輸入狀態。

                    void resetLocker() {
                        lcd.clear();
                        lcd.print("GoGo JR...");
                        lcd.setCursor(0, 1);    //  切換到第 2 行

                        lcd.print("PIN:");
                        lcd.cursor();
                        acceptKey = true;
                        inputCode = "";

                    }

                    //  比對輸入的密碼
                    void checkPinCode() {

                        acceptKey = false;    //  暫時不接受用戶按鍵輸入
                        clearRow(0);              //  從第 0 個字元開始清除 LCD 畫面
                        lcd.noCursor();
                        lcd.setCursor(0, 1);    //  切換到第 2 行
                        //  比對密碼

                        if (inputCode == passcode) {
                            lcd.print("Welcome home!");
                            openDoor();

                        } else {
                            lcd.print("***WRONG!!***");
                            Serial.println(inputCode);
                        }

                        sleep(3000);
                        resetLocker();          //  重設 LCD 顯示文字和輸入狀態
                    }


                    defineTask(TaskTest1);//創建子線程 1
                    defineTask(TaskTest2);//創建子線程 2

                    //LCD 顯示
                    void TaskTest1::setup()//線程 1 設定


                                                           188]]></page><page Index="198"><![CDATA[{

                        WifiConn();//ok
                        lcd.begin(16, 2); //  初始化 LCD
                        lcd.setBacklight(255);
                        lcd.clear();

                        resetLocker();
                    }
                    void TaskTest1::loop()//線程 1 循環
                    {}


                    //RFID
                    void TaskTest2::setup()//線程 2 設定
                    {

                        Serial.println("RFID reader is ready!");
                        SPI.begin();
                        mfrc522.PCD_Init(SS_PIN, RST_PIN); //  初始化 MFRC522 卡
                        mfrc522.PCD_DumpVersionToSerial(); //  顯示讀卡設備的版本

                    }

                    void TaskTest2::loop()//線程 2 循環
                    {}

                    void setup() {
                        Serial.begin(9600);
                        ser.begin(9600);//Ardunio <-> Wifi
                        myservo.attach(A1);    //  設定要將伺服馬達接到哪一個 PIN 腳

                        mySCoop.start();
                    }

                    void loop()

                    {
                    //鍵盤  keypad
                            char key = keypad.getKey();
                        //  若目前接受用戶輸入，而且有新的字元輸入…

                        if (acceptKey && key != NO_KEY) {
                    if (key == '*') {      //  清除畫面
                                clearRow(4);    //  從第 4 個字元開始清除
                                inputCode = "";
                            } else if (key == '#') {    //  比對輸入密碼


                                                           189]]></page><page Index="199"><![CDATA[WifiSendata(); //傳送資料至伺服器

                                checkPinCode();
                            } else {
                                inputCode += key;    //  儲存用戶的按鍵字元
                                lcd.print('*');

                                Serial.println(inputCode);
                            }
                        }
                    //-----------

                    //  確認是否有新卡片
                            if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial())
                    {
                                byte *id = mfrc522.uid.uidByte;      //  取得卡片的 UID (第 20 行)
                                byte idSize = mfrc522.uid.size;      //  取得 UID 的長度

                                //把取得的 UID，拿來比對我們指定好的 UID
                                bool they_match = true; //  初始值是假設為真
                                for ( int i = 0; i < 4; i++ ) { //  卡片 UID 為 4 段，分別做比對

                                    if ( uid[i] != mfrc522.uid.uidByte[i] ) {
                                        they_match = false; //  如果任何一個比對不正確，they_match 就為
                    false，然後就結束比對
                                        break;

                                    }
                                }

                                //在監控視窗中顯示比對的結果

                                if(they_match){
                                    Serial.print(F("Access Granted!"));
                                    //
                                    lcd.clear();
                                    lcd.setCursor(0, 0);    //設定游標位置  (字,行)

                                    lcd.print("UID:"); //"Card UID:"+

                                    byte *cuid = mfrc522.uid.uidByte;      //讀取卡片 ID

                                    byte cuidSize = mfrc522.uid.size;      //卡片 ID 的長度
                                    for (byte i = 0; i < cuidSize; i++) {
                                    lcd.print(cuid[i], HEX);            //顯示 id
                                    lcd.print(" ");

                                    card += String(cuid[i], HEX);

                                                           190]]></page><page Index="200"><![CDATA[}


                                lcd.setCursor(0, 1);    //設定游標位置  (字,行)
                                lcd.print("Access Granted!");//

                                    //伺服馬達

                                    openDoor();
                                    WifiSendata(); //傳送資料至伺服器
                                    card="";

                                    resetLocker();          //  重設 LCD 顯示文字和輸入狀態
                                }else{
                                    Serial.print(F("Access Denied!"));
                                }
                                mfrc522.PICC_HaltA();    //  讓卡片進入停止模式

                            }
                    //-----------
                        yield();

                    }


                   4.7.2 Web

                   本專案伺服器建置與介紹請參照第三章。

























                                          圖 4.13 居家智能系統開門紀錄網頁

                    insert.php
                    <?php

                    //http://127.0.0.1/home/insert.php?cardnu=0xB0x440xA10x59&pwdr=1234

                                                           191]]></page><page Index="201"><![CDATA[DEFINE ('DBServer', 'localhost');

                    DEFINE ('DBName', 'iotest');
                    DEFINE ('DBUser', 'root');
                    DEFINE ('DBPw', '');    //Z*sw1Mdnqjh6Ke!tOoMn


                    $conDb = mysqli_connect(DBServer,DBUser,DBPw);
                    if (!$conDb) {
                            die("Can not connect to DB: " . mysqli_error($conDb));
                            exit();

                    }

                    $selectDb = mysqli_select_db($conDb, DBName);
                    if (!$selectDb) {

                            die("Database selection failed: " . mysqli_error($conDb));
                            exit();
                    }


                    $cardnu = mysqli_real_escape_string($conDb, $_GET['cardnu']);
                    $pwdr = mysqli_real_escape_string($conDb, $_GET['pwdr']);
                    $datetime = date_create()->format('Y-m-d H:i:s');


                    $query = "INSERT INTO homex (cardnu, passwordx, datetime) VALUES ('$cardnu',
                    '$pwdr', '$datetime')";

                    $result  =  mysqli_query($conDb,  $query)  or  trigger_error("query  error  "  .

                    mysqli_error($conDb));

                    mysqli_close($conDb);
                    echo "ok";

                    ?>

                    list.php

                    <section      class="section-table     cid-sfzUWt6Q2S"        style="background-
                    image:url('assets/images/bgc1.png');height:100%" id="table1-1">
                        <div class="container container-table">
                                <div class="table-wrapper">

                                    <div class="container">
                                        <div class="row search">

                                                           192]]></page><page Index="202"><![CDATA[<div class="col-md-6"></div>

                                            <div class="col-md-6">
                                                    <div class="dataTables_filter">
                                                        <!--<label   class="searchInfo   mbr-fonts-style   display-
                    7">Search:</label>

                                                        <input class="form-control input-sm" disabled="">-->
                                                    </div>
                                            </div>
                                        </div>

                                    </div>

                                    <div class="container scroll">
                                        <table  class="table  isSearch"  cellspacing="0"  data-empty="No

                    matching records found">
                                            <thead>
                                                <tr class="table-heads ">
                                                <th class="head-item mbr-fonts-style display-7">

                                                                <!-- 姓  名  </th><th  class="head-item  mbr-fonts-style
                    display-7">-->
                                                                登  入  類  別  </th><th  class="head-item  mbr-fonts-style
                    display-7">
                                                                卡號  /  密碼</th><th class="head-item mbr-fonts-style

                    display-7">
                                                                日期</th></tr>
                                            </thead>

                                            <tbody>
                    <?php
                    $servername = "localhost";
                    $username = "root";

                    $password = "";
                    $dbname = "iotest";

                    // Create connection

                    $conn = new mysqli($servername, $username, $password, $dbname);
                    // Check connection
                    if ($conn->connect_error) {
                        die("Connection failed: " . $conn->connect_error);

                    }

                                                           193]]></page><page Index="203"><![CDATA[$sql = "SELECT * FROM homex order by nox DESC";
                    $result = $conn->query($sql);

                    if ($result->num_rows > 0) {

                        // output data of each row

                        while($row = $result->fetch_assoc()) {
                    ?>


                                            <tr>
                                                <!--<td   class="body-item   mbr-fonts-style   display-
                    7"><?=$row["name"];?></td>-->

                                       <td class="body-item mbr-fonts-style display-7">
                                       <?
                                       $card=$row["cardnu"];
                                       if($card!="")

                                           echo "Card";
                                       else
                                           echo "Password";
                                       ?>

                                       </td>
                                       <td     class="body-item        mbr-fonts-style       display-
                    7"><?=$row["cardnu"];?> / <?=$row["passwordx"];?></td>
                                       <td     class="body-item        mbr-fonts-style       display-

                    7"><?=$row["datetime"];?></td>
                                   </tr>
                    <?
                        }

                    }
                    $conn->close();
                    ?>
                                   </tbody>

                                        </table>
                                    </div>
                                    <div class="container table-info-container">
                                        <div class="row info">

                                            <div class="col-md-6">

                                                           194]]></page><page Index="204"><![CDATA[<div class="dataTables_info mbr-fonts-style display-7">

                                                    <span class="infoBefore">Showing</span>
                                                    <span class="inactive infoRows"></span>
                                                    <span class="infoAfter">entries</span>
                                                    <span class="infoFilteredBefore">(filtered from</span>

                                                    <span class="inactive infoRows"></span>
                                                    <span class="infoFilteredAfter"> total entries)</span>
                                                </div>
                                            </div>

                                            <div class="col-md-6"></div>
                                        </div>
                                    </div>
                                </div>

                            </div>
                    </section>


                   4.7.3 App


                   本專案 App 建置與介紹請參照第三章。








































                                               圖 4.14 居家智能系統 App

                                                           195]]></page><page Index="205"><![CDATA[4.7.4 MySQL


                   本專案資料庫建置與介紹請參照第三章。















                                           圖 4.15 居家智能系統資料庫結構
                   4.8 成果



                        本專案使用壓克力做成控制盒後，其成果外觀如圖 4.16 所示。透過本專案
                   可學習到 RFID 傳輸與薄膜鍵盤的輸入，並更進一步了解物聯網訊號傳遞原理及
                   系統建置方式。




























                                             圖 4.16 居家智能系統成果展示













                                                           196]]></page><page Index="206"><![CDATA[CH 5  智慧循跡/藍芽自走車





                   5.1 專案概述



                        本專案製作主要是在於時代走向自動控制，因為在科技日益月新的情況下，
                   所以我們這次藉由紅外線感測器來讓紅外線自走車能夠在行進時能夠感測到地
                   上之黑線，並沿著黑線前進，且行進時若遭遇障礙物，會於 20 公分前進行「停
                   下」的動作。在這次的專題中，透過  Bluetooth  與  App Inventor  控制自走車的前

                   置基礎操作，我們主要是以 Arduino    UNO 作為晶片板，透過 ZS-040 藍芽模組，
                   接收手機 App Inventor 訊號，控制藍芽自走車，行走與轉速。


                   5.2 系統架構

































                                          圖 5.1 智慧藍芽循跡自走車系統架構


                        依據系統架構，如圖 5.1 所示，本專案主要以超音波偵測前方是否有障礙物，
                   在以紅外線偵測地上軌跡線，透過 L298N 馬達自動控制自走車。此外，本專案
                   也可以 App 透過藍芽傳輸方式控制自走車。


                   5.3 技術說明



                        本專案開發工具與環境如 5.1 表，以 C 語言在 Arduino IDE 開發主要控制程
                   式，以及 App Inventor 建置 App 程式，並進行藍芽傳輸控制馬達。此外本專案運
                                                           197]]></page><page Index="207"><![CDATA[用紅外線感測器與超音波模組，達到自動循跡避障功能。

                                             表 5.1 智能居家系統開發環境

                              開發程式語言與技術  本系統應用採用 C 等開發語言完成

                              資料交換技術                  藍芽技術傳輸
                              系統開發工具                  Ardunio Sketch、MIT App Inventor
                              作業系統軟體                  Win10、Android、iOS


                   5.4 硬體接線










































                                          圖 5.2 智慧藍芽循跡自走車硬體接線

                        本專案硬體接線如圖 5.2 所示，Arduino 腳位 2、3 接於藍芽 Tx 與 Rx，腳位

                   4、5、6、7 分別接於 L298N 上 IN1、IN2、IN3、IN4，若需要調整速度則 9、10
                   腳位可接於 L298N 上之 EnA 與 EnB。超音波感測器 Trig Pin  接於 12、Echo Pin
                   接於 13。TCRT5000 紅外線接於 A3、A4、A5。5V 電供給 L298N、紅外線模組

                   與超音波模組，3V 電供給藍芽模組。完成接線後如圖 5.3 所示，本專案建議
                   Arduino 電源以電池驅動外 L298N 模組也以另一組電磁供給，其相關元件可參照
                   BOM 表 5.2。



                                                           198]]></page><page Index="208"><![CDATA[圖 5.3 BOM 表組裝智慧藍芽循跡自走車

                                           表 5.2 智慧藍芽循跡自走車 BOM

                               名稱                  用量                   說明
                               Ardunio Uno         1                    主機板
                               HC-06               1                    藍芽模組

                               MH-Sensor-serins    3                    IR 感測
                               電池座                 2                    電來源
                               HC-SR04             1                    超音波感測

                               L298N               1                    連結馬達
                               開關                  1                    開關用
                               輪子                  3                    行動用
                               直流馬達                2
























                                                           199]]></page><page Index="209"><![CDATA[5.5 元件介紹


                   5.5.1 HC-06  藍芽通訊模組


                        HC-06:  藍芽為現今最常見的無線通訊設備，假如你手邊有行動裝置如：智

                   慧型手機、平板電腦，絕大部分都有內建藍芽。藍芽模組的傳輸方式非常簡單，
                   使用 UART 資料傳輸，只需將模組上的 TxD(資料傳送)、RxD(資料接收)連接到
                   Arduino 板，並將通訊速度(鮑率：baud rate)設定完成後，就可以傳送資料。





















































                                                     圖 5.4 HC - 06
                   使用設定狀態時 HC-06  和  Arduino  的腳位對應如下：
                   HC-06 VCC  →  Arduino 5V
                   HC-06 GND  →  Arduino GND
                   HC-06 TXD  →  Arduino pin 1


                                                           200]]></page><page Index="210"><![CDATA[HC-06 RXD  →  Arduino pin 0

                   Arduino RESET  →  Arduino GND
                   使用狀態時 HC-06  和  Arduino  的腳位對應如下：
                   HC-06 VCC  →  Arduino 5V
                   HC-06 GND  →  Arduino GND
                   HC-06 TXD  →  Arduino pin 10

                   HC-06 RXD  →  Arduino pin 11
                   藍牙模組的兩種操作模式
                   1.自動連線（automatic connection），又稱為透通模式（  transparent communication）。

                   2.命令回應（order-response），又稱為 A T 模式（AT mode）。

                        平時使用的「自動連線」模式只是把 RxD 腳傳入的資料，轉成藍牙無線訊
                   號傳遞出去；或者將接收到的無線資料，從 TxD 腳傳給 Arduino，模組本身不會

                   解讀資料，也不接受控制。操控藍牙模組的指令統稱 A T 命令（A T -command）。
                   A T 命令並非透過藍牙無線傳輸，而是模組的 TxD 和 RxD 接腳。藍牙模組只有
                   在 A T 模式，才能接收 A T 命令。


                        HC-06 模組在與其他裝置連線之前，都處於 A T 模式狀態；換句話說，只要
                   一通電，HC-06 模組就進入 A T 模式。HC-06 的 A T 命令，採用 9600bps 的速率
                   傳送。通電後，在尚未與裝置連線之前，HC-06 板子上的 LED 將不停地閃爍；
                   一旦與其他藍牙裝置連線（如：手機或電腦），LED 將維持點亮狀態。根據廠商

                   提供的 A T 命令說明書，筆者購買的 HC-06 藍牙模組支援下列 A T 指令（這個模
                   組規定，A T 命令一定要大寫，有些模組不區分大小寫）：
                                               表 5.3 HC-06 AT Command
                    A T 命令               回應               說明

                    AT                   OK               確認通訊用
                    AT+VERSION           OKlinvorV1.8     查看韌體版本(會因版本而顯示不同)
                    AT+NAMEJR            OKsetname        將裝置名稱改為「JR」

                    AT+PIN1234           OKsetPIN         將連線配對碼改為「1234」
                    AT+BAUD1             OK1200           將  baud rate  改為  1200
                    AT+BAUD2             OK2400           將  baud rate  改為  2400

                    AT+BAUD3             OK4800           將  baud rate  改為  4800
                    AT+BAUD4             OK9600           將  baud rate  改為  9600
                    AT+BAUD5             OK19200          將  baud rate  改為  19200
                    AT+BAUD6             OK38400          將  baud rate  改為  38400

                    AT+BAUD7             OK57600          將  baud rate  改為  57600
                    AT+BAUD8             OK115200         將  baud rate  改為  115200


                                                           201]]></page><page Index="211"><![CDATA[常用的 A T 指令有兩個：
                   1.AT+NAME：設定模組的識別名稱。
                   2.AT+PIN：更改配對密碼。假如你不想讓其他人輕易地連接到你的藍牙裝置，可
                   以透過這個 A T 命令修改配對密碼。


                        HC-06 模組的預設名稱就是“HC-06＂，於多人、多組藍牙一起實驗的場合，
                   在電腦或手機上探索藍牙裝置時，將會發現許多叫做“HC-06＂的裝置。為了方
                   便實驗者連接到自己的藍牙設備，可以事先用 A T 命令替每一個模組設定不同的

                   名字，例如，bt01, bt02, bt03,…（註：一般最多允許 32 個英∕數字）。

                    #include <SoftwareSerial.h>      //  引用程式庫

                    //  定義連接藍牙模組的序列埠

                    SoftwareSerial BT(8, 9); //  接收腳,  傳送腳
                    char val;    //  儲存接收資料的變數


                    void setup() {
                        Serial.begin(9600);      //  與電腦序列埠連線
                        Serial.println("BT is ready!");

                        //  設定藍牙模組的連線速率

                        //  如果是 HC-05，請改成 38400
                        BT.begin(9600);
                    }


                    void loop() {
                        //  若收到「序列埠監控視窗」的資料，則送到藍牙模組
                        if (Serial.available()) {

                            val = Serial.read();
                            BT.print(val);
                        }


                        //  若收到藍牙模組的資料，則送到「序列埠監控視窗」
                        if (BT.available()) {
                            val = BT.read();
                            Serial.print(val);

                        }

                                                           202]]></page><page Index="212"><![CDATA[}


                   5.5.2 MH-Sensor-serins


                        MH-Sensor-serins:利用反射式紅外線感測器達成循跡動作，利用紅外線感  應

                   器傳送與接收訊號，再經由微控制器處理適時送出訊號給馬達，使  車子能提前
                   迴避障礙物，以達到防撞的效果。













































                                                  圖 5.5 紅外線感測器





















                                                           203]]></page><page Index="213"><![CDATA[圖 5.6 紅外線感測器接線


                    // (c) Michael Schoeffler 2017, http://www.mschoeffler.de
                    #include <Wire.h>
                    #include <LiquidCrystal_I2C.h>

                    LiquidCrystal_I2C  lcd(0x27,  2,  1,  0,  4,  5,  6,  7,  3,  POSITIVE);  //  initializes  the
                    LCM1602 IIC V1 (LCD module)
                    // 0x27 is the I2C address. This address might be different.
                    const int IN_A0 = A0; // analog input

                    const int IN_D0 = 8; // digital input
                    void setup() {
                        pinMode (IN_A0, INPUT);
                        pinMode (IN_D0, INPUT);

                        lcd.begin(16, 2); // begins connection to the LCD module
                        lcd.backlight(); // turns on the backlight
                    }
                    int value_A0;

                    bool value_D0;
                    void loop() {
                        value_A0 = analogRead(IN_A0); // reads the analog input from the IR distance
                    sensor

                        value_D0 = digitalRead(IN_D0);// reads the digital input from the IR distance
                    sensor

                        lcd.setCursor(0, 0); // sets the cursor of the LCD module to the first line

                        lcd.print("A0:");

                                                           204]]></page><page Index="214"><![CDATA[lcd.setCursor(3, 0); // sets the cursor of the LCD module to the fourth character

                        lcd.print(value_A0); // prints analog value on the LCD module

                        lcd.setCursor(0, 1); // sets the cursor of the LCD module to the first line
                        lcd.print("D0:");

                        lcd.setCursor(3, 1); // sets the cursor of the LCD module to the fourth character
                        lcd.print(value_D0); // prints digital value on the LCD module

                        delay(1000);

                    }


                   5.5.3 直流馬達


                   直流馬達:  一般馬達的基礎結構可劃分為機殼、定子、轉子(電樞)等三  個部分，
                   將定子固定在機殼上後，透過通電後磁場的改變  來驅動轉子轉動，而微型馬達
                   通常轉子扭矩極小而轉速極  高，則可加裝減速機(齒輪箱)來降低轉速及提升輸
                   出的扭  矩(力)，


















                                                    圖 5.7 直流馬達


                   5.5.4 電池座

                   電池座:供應自走車沒接電狀態時的電量供給。













                                                      圖 5.8 電池座



                                                           205]]></page><page Index="215"><![CDATA[5.5.5 L298N 雙 H 橋模組


                     L298N：雙 H 橋驅動器芯片終端驅動器部分的電源區域 VMS：+5 V〜+35 V
                     驅動器部分的峰值電流 Io：2A / Bridge 邏輯部分的終端電源範圍 Vss：4.5-5 .5
                     V 邏輯部分的工作電流範圍：0〜36mA 控制信號輸入電壓範圍：4.5-5.5V 低
                     0V 高最大功耗：20W 存儲溫度：-25〜+130 驅動板尺寸：55mm * 60mm * 30mm

                     驅動板重量：33g 其他功能：控制方向指示燈，電源指示燈，電流檢測，板邏
                     輯部分取電接口


                     L298N 模組常用於驅動車子的左右車輪，可以分別控制左右車輪前進、倒退與
                     停止，會讓車子可以前進、倒退、左轉、右轉與停止。






































                                                      圖 5.9 L298N



                   L298N 為雙 H 橋模組，每個 H 橋使用四個電晶體控制一個馬達的順時針與逆時

                   針旋轉，兩個 H 橋可以控制兩個馬達，L298N 提供四個數位訊號輸入接腳，假
                   設 IN1 與 IN2 接腳控制左側馬達，而 IN3 與 IN4 接腳控制右側馬達，馬達與四
                   個數位訊號輸入接腳的關係如表 5.4 所示，HIGH 表示高電壓，LOW 表示低電
                   壓。




                                                           206]]></page><page Index="216"><![CDATA[表 5.4 L298N 馬達控制

                                         馬達運作                 IN1                 IN2
                                         順時針                  HIGH                LOW
                     左馬達
                                         逆時針                  LOW                 HIGH

                                         停止                   LOW                 LOW
                                         馬達運作                 IN3                 IN4

                                         順時針                  HIGH                LOW
                      右馬達
                                         逆時針                  LOW                 HIGH
                                         停止                   LOW                 LOW


                   如果將左右馬達製作一台自走車，假設馬達順時針表示前進，以下表呈現車子的

                   前進、倒退、左轉、右轉與停止，與 IN1、IN2、IN3 與 IN4 的關係，HIGH 表示
                   高電壓，LOW 表示低電壓。


                                                表 5.5 L298N 自走車控制
                                  車子運作         IN1          IN2          IN3            IN4

                    車子            前進           HIGH         LOW          HIGH           LOW
                                  倒退           LOW          HIGH         LOW            HIGH
                                  停止           LOW          LOW          LOW            LOW

                                  左轉           LOW          LOW          HIGH           LOW
                                  右轉           HIGH         LOW          LOW            LOW


                   實驗接線圖


                   L298N 需要外接電力，因為 Arduino 內建電力恐無法驅動二個馬達，L298N 提供

                   12V 電力的輸入，根據電池電力將正極接線接到 12V，負極接線連接 L298N 的
                   GND 接腳，如圖 5.10。





















                                                   圖 5.10 L298N 接線


                                                           207]]></page><page Index="217"><![CDATA[左右馬達各需要兩個數位訊號接腳，分別控制馬達順時針、逆時針或不旋轉。


                                           表 5.6 L298N 與  Arduino 腳位對應

                                  Arduino 接腳                  L298N 接腳
                                  GND                         GND
                                  D4                          IN1

                                  D5                          IN2
                                  D6                          IN3

                                  D7                          IN4

                   程式實作提示
                   使用函式 digitalWrite 輸出 HIGH 與 LOW 到數位訊號接腳，控制兩個馬達順時

                   針旋轉、逆時針旋轉或停止，本範例自訂前進、倒退與停止函式，控制兩個馬達
                   的順時針旋轉、逆時針旋轉或停止。

                   程式碼與解說

                    const int In1 = 4;
                    const int In2 = 5;
                    const int In3 = 6;
                    const int In4 = 7;

                    void setup(){
                        pinMode(In1, OUTPUT);
                        pinMode(In2, OUTPUT);

                        pinMode(In3, OUTPUT);
                        pinMode(In4, OUTPUT);
                    }
                    void loop(){
                        mfront();

                        delay(2000);
                        mstop();
                        delay(500);

                        mback();
                        delay(2000);
                        mstop();
                        delay(500);
                    }

                    void mstop(){
                        digitalWrite(In1, LOW);

                                                           208]]></page><page Index="218"><![CDATA[digitalWrite(In2, LOW);

                        digitalWrite(In3, LOW);
                        digitalWrite(In4, LOW);
                    }
                    void mfront(){

                        digitalWrite(In1, HIGH);
                        digitalWrite(In2, LOW);
                        digitalWrite(In3, HIGH);
                        digitalWrite(In4, LOW);

                    }
                    void mback(){
                        digitalWrite(In1, LOW);
                        digitalWrite(In2, HIGH);

                        digitalWrite(In3, LOW);
                        digitalWrite(In4, HIGH);
                    }


                   第 1 到 4 行：定義 In1 為 4，表示 In1 接在數位接腳 4，定義 In2 為 5，表示 In2
                   接在數位接腳 5，定義 In3 為 6，表示 In3 接在數位接腳 6，定義 In2 為 7，表示
                   In4 接在數位接腳 7。
                   第 5 到 10 行：在 setup 函式內，使用函式 pinMode 設定 In1、In2、In3 與 In4 接
                   腳為輸出模式。

                   第 11 到 20 行 ： 在    loop 函式內，呼叫 mfront 函式讓輪子順時針旋轉，持續 2 秒 ，
                   呼叫 mstop 函式車子停止，持續 0.5 秒，呼叫 mback 函式讓輪子逆時針旋轉，持
                   續 2 秒，呼叫 mstop 函式車子停止，持續 0.5 秒。

                   第 21 到 26 行：自訂函式 mstop，In1、In2、In3 與 In4 接腳都輸入 LOW 電壓，
                   車子將停止在原地。
                   第 27 到 32 行：自訂函式 mfront，In1 與 In3 輸入 HIGH 電壓，In2 與 In4 接腳輸
                   入 LOW 電壓，輪子將順時針旋轉。

                   第 33 到 38 行：自訂函式 mback，In1 與 In3 輸入 LOW 電壓，In2 與 In4 接腳輸
                   入 HIGH 電壓，輪子將逆時針旋轉。

                   執行程式

                   編譯及上傳程式到 Arduino，將看到兩個輪子順時針旋轉 2 秒鐘、停止不動 0.5
                   秒、逆時針旋轉 2 秒鐘與停止不動 0.5 秒，會不斷重複此動作。







                                                           209]]></page><page Index="219"><![CDATA[5.5.6 HC-SR04  超音波感測器


                        HC-SR04超音波感測器:  超音波避障自走車是指自走車可以自動運行前進，
                   而且不會碰撞到任何障  礙物。  為了讓自走車可以自動避開障礙物，可以使用三
                   個超音波模組分別放置於自  走車的車頭右方、前方及左方等三個位置，偵測右
                   方、前方及左方等三個方向的障  礙物距離。
























                                                    圖 5.11 HC-SR04













































                                                           210]]></page><page Index="220"><![CDATA[圖 5.12 HC-SR04 接線


                                         表 5.7 HC-SR04  與  Arduino  腳位對應

                                              HC-SR04         Arduino

                                              VCC             VCC

                                              Trig            Pin 12

                                              Echo            Pin 11

                                              GND             GND

                   以下先不呼叫函式，直接以音波在空氣中傳遞的大約速度，算出來回測得的時間，
                   乘以空氣中傳遞聲音的速度，算出距離。程式中有一行 cm = (duration/2) / 29.1，

                   各位會不會覺得奇怪，為什麼要除以  29.1 ?  那是因為在攝氏零度之海平面音速
                   約為 331.5 公尺/秒，每升高 1 攝氏度，音速就增加 0.607 公尺/秒，可以列出一個
                   公式：
                   •   音速  c = 331.5 + 0.607 * t   (其中  t  為攝氏溫度)。

                         例：  攝氏 20 度時的音速約為：  331.5 + 0.607*20 = 343.64  公尺/秒
                                                           211]]></page><page Index="221"><![CDATA[•   音速公尺/秒  換算成  公分/微秒：343.64 * 100 / 1000000 = 0.034364  公分/微秒，

                   亦即
                         音速每公分需要 29.1  微秒：   1 / 0.034364 = 29.1  微秒/公分
                         超音波發射的距離為來回，因此單程距離  =  時間差  / 2   再除以   29.1  微秒
                   /  公分，同樣的如果要換算成英吋，只要將  29.1  再乘以  2.54  即可。來看看程式
                   的內容：

                    int trigPin = 12;                                    //Trig Pin
                    int echoPin = 11;                                    //Echo Pin
                    long duration, cm, inches;


                    void setup() {
                        Serial.begin (9600);                          // Serial Port begin
                        pinMode(trigPin, OUTPUT);                //  定義輸入及輸出

                        pinMode(echoPin, INPUT);
                    }

                    void loop()

                    {
                        digitalWrite(trigPin, LOW);
                        delayMicroseconds(5);
                        digitalWrite(trigPin, HIGH);          //  給  Trig  高電位，持續  10 微秒

                        delayMicroseconds(10);
                        digitalWrite(trigPin, LOW);

                        pinMode(echoPin, INPUT);                          //  讀取  echo  的電位

                        duration = pulseIn(echoPin, HIGH);      //  收到高電位時的時間

                        cm = (duration/2) / 29.1;                  //  將時間換算成距離  cm  或  inch
                        inches = (duration/2) / 74;


                        Serial.print("Distance : ");
                        Serial.print(inches);
                        Serial.print("in,      ");

                        Serial.print(cm);
                        Serial.print("cm");
                        Serial.println();


                        delay(250);

                                                           212]]></page><page Index="222"><![CDATA[}


                   執行上述程式時，從串列埠看到的測試值都是整數，如果要計算值要顯示小數點，
                   可以將上述程式中「long duration, cm, inches;」改成「float duration, cm, inches;」。














































































                                                           213]]></page><page Index="223"><![CDATA[5.6 軟體架構


                        本專案可分為循跡與藍芽兩架構，如圖 5.13 與圖 5.14 所示，當 Arduino 程
                   式啟動時，超音波感測器啟動偵測前方 20 公分，若無障礙物則進入循跡模式，
                   依照軌跡行進，若遇障礙物則進入手動模式以藍芽避障。圖 5.14 則為純粹以 App
                   控制自走車之軟體架構。






























                                           圖 5.13 智慧循跡自走車軟體架構
































                                           圖 5.14 智慧藍芽自走車軟體架構



                                                           214]]></page><page Index="224"><![CDATA[5.7 系統程式


                        本專案以藍芽循跡自走車為主，故在程式撰寫的思維上，首先以超音波模組
                   判斷前方是否有障礙物，其架構如圖 5.13 所示，而在紅外線循跡與 L298N 馬達
                   控制行進上則如表 5.8 所示。


                                         表 5.8  紅外線循跡與 L298N 馬達控制
                                                                           左輪              右輪
                     左紅外線  中紅外線  右紅外線                        方向
                                                                        IN1     IN2     IN3     IN4
                         1           1            1          前進       HIGH  LOW  HIGH  LOW
                         0           0            1          右轉       HIGH  LOW  LOW  HIGH

                         1           0            0          左轉        LOW  HIGH  HIGH  LOW
                         0           0            0          停止        LOW  LOW  LOW  LOW


                   5.7.1 Ardunio


                   本專案 Arduino 主程式，可分為三個區塊介紹，其分別為前置命令與宣告、主程
                   式、副程式。


                   前置命令與宣告
                   首先我們引入 SoftwareSerial 函式庫，接著設定、宣告與變數:

                    //  定義連接藍牙模組的序列埠
                    SoftwareSerial BT(2, 3); //  接收腳,  傳送腳

                   L298N 相關宣告與變數:
                    //定義 L298N 上對應的腳位

                    const int In1 = 4;
                    const int In2 = 5;
                    const int In3 = 6;

                    const int In4 = 7;
                    const int EnA = 9; //速度調節腳位
                    const int EnB = 10; //速度調節腳位
                    int Speed = 50;


                   紅外線模組相關宣告與變數:
                    const int irD1=A1;//左紅外      --兩個紅外間距最好在 1.5-2cm
                    const int irD2=A2;//中

                    const int irD3=A3;//右
                                                           215]]></page><page Index="225"><![CDATA[byte IRstatus=0;//紅外線循跡模組感應值

                    int ir_in;            //輸入類比信號值
                    char val;
                    int auto_f=0;


                   超音波相關宣告與變數:
                    int trigPin = 12;                                    //Trig Pin
                    int echoPin = 13;                                    //Echo Pin

                    long duration, cm;

                   主程式
                   主程式 setup()初始化，主要進行 L298N 馬達控制、紅外線模組、超音波與藍芽
                   初始化設定。

                    void setup(){
                        Serial.begin(9600);
                        pinMode(In1, OUTPUT);

                        pinMode(In2, OUTPUT);
                        pinMode(In3, OUTPUT);
                        pinMode(In4, OUTPUT);
                        pinMode(EnA, OUTPUT);

                        pinMode(EnB, OUTPUT);

                        pinMode(irD1,INPUT_PULLUP);
                        pinMode(irD2,INPUT_PULLUP);

                        pinMode(irD3,INPUT_PULLUP);

                        pinMode(trigPin, OUTPUT);                //Define inputs and outputs
                        pinMode(echoPin, INPUT);


                        BT.begin(9600);
                    }


                   主程式 loop()，首先以 analogWrite 控制馬達速度，接著控制超音波與紅外線模組
                   所取得偵測的值，再進行偵測藍芽是否有取得傳輸的指令。最後，透過 if 判斷上
                   述所取得的值是否符合如表 5.8 所定義的行進指令，再依照其指令進行相關的行
                   進副程式。

                    void loop(){
                            //速度控制

                                                           216]]></page><page Index="226"><![CDATA[analogWrite(EnA,Speed);

                            analogWrite(EnB,Speed);

                            digitalWrite(trigPin, HIGH);
                            delay(50);

                            digitalWrite(trigPin, LOW);          //
                            duration = pulseIn(echoPin, HIGH);      //  收到高電位時的時間
                            cm = (duration/2) / 29.1;                  //  將時間換算成距離  cm



                            IRstatus=0;      //清除紅外線循跡模組感應值
                            ir_in=analogRead(irD1);//讀取“左 L＂紅外線循跡模組感應值
                            if(ir_in>=150)//感應到黑色軌道？
                                IRstatus=(IRstatus+4);                            //設置感應值位 2 為 1



                            ir_in=analogRead(irD2);//讀取中

                            if(ir_in>=150)//感應到黑色軌道？
                                IRstatus=(IRstatus+2);                //設置感應值位 1 為 1


                            ir_in=analogRead(irD3);    //讀取右

                            if(ir_in>=150)//感應到黑色軌道？
                                IRstatus=(IRstatus+1);                  //設置感應值位 0 為 1


                        //  若收到「序列埠監控視窗」的資料，則送到藍牙模組
                        if (Serial.available()) {
                            val = Serial.read();
                            BT.print(val);

                        }

                        //  若收到藍牙模組的資料，則送到「序列埠監控視窗」
                        if (BT.available()) {

                            val = BT.read();
                            Serial.println(val);

                            if (val=='a')

                            {auto_f=1;}

                                                           217]]></page><page Index="227"><![CDATA[else if (val=='h')

                            {auto_f=0;}

                            if(val=='0')
                            {Speed=50;}


                            if(val=='1')
                            {Speed=100;}


                            if(val=='2')
                            {Speed=150;}

                            if(val=='3')

                            {Speed=200;}

                            if(val=='4')
                            {Speed=255;}

                        }
                            if(cm>20){

                                if(auto_f==1)

                                {
                                      driveMotor(IRstatus); //按 IRstatus 值設置馬達轉向
                                }
                            else if(auto_f==0)

                            {
                            if(val=='f')
                            mfront();


                            if(val=='l')
                            mleft();

                            if(val=='r')

                            mright();

                            if(val=='b')
                            mback();



                                                           218]]></page><page Index="228"><![CDATA[if(val=='s')

                            mstop();
                            }
                        }


                            else{

                            if(auto_f==0)
                            {

                            if(val=='b')
                            mback();
                            else
                            mstop();

                            }

                            else if(auto_f==1)
                            mstop();


                                Serial.println("Too close,stop");

                                Serial.print(cm);

                                Serial.print("cm");
                                Serial.println();
                            }


                    }
                    void driveMotor(byte IRstatus)
                    {
                        switch(IRstatus)

                        {
                            case 0:        //LCR=000，白白白
                              mstop();
                              break;

                            case 1://001，白白黑
                                mright();
                                break;
                            case 2:

                                mfront();

                                                           219]]></page><page Index="229"><![CDATA[break;

                            case 3:
                                mright();
                                break;
                            case 4:

                                mleft();
                                break;
                            case 5:
                                mstop();

                                break;
                            case 6:
                                mleft();
                                break;

                            case 7:
                                mfront();
                                break;


                        }
                    }

                   副程式

                   本專案副程式主要為紅外線偵測 driveMotor()與 mfront()前進、mback()後退、
                   mstop()停止、mleft()左、mright()右的自走車行進程式。


                   driveMotor()此程式，主要為將紅外線偵測到的值代入 switch-case 流程，當紅外
                   線 LCR(左中右)為白白白(000)時則自走車停止、白白黑(001)時則右轉依照表
                   5.8 所示進行行進指令。
                    void driveMotor(byte IRstatus)
                    {

                        switch(IRstatus)
                        {
                            case 0:        //LCR=000，白白白

                              mstop();
                              break;
                            case 1://001，白白黑
                                mright();
                                break;

                            case 2:

                                                           220]]></page><page Index="230"><![CDATA[mfront();

                                break;
                            case 3:
                                mright();
                                break;

                            case 4:
                                mleft();
                                break;
                            case 5:

                                mstop();
                                break;
                            case 6:
                                mleft();

                                break;
                            case 7:
                                mfront();
                                break;


                        }
                    }


                   自走車方向控制 mfront()前進、mback()後退、mstop()停止、mleft()左、mright()右
                   函式。自走車方向控制函式主要以 L298N 的 In1、In2、In3 與 In4 接腳 HIGH、
                   LOW 控制為主。詳細可參照本章 5.5.5 節。

                    //函式 mstop，In1、In2、In3 與 In4 接腳都輸入 LOW 電壓，車子將停止在原地
                    void mstop(){
                        Serial.println("mstop");
                        digitalWrite(In1, LOW);
                        digitalWrite(In2, LOW);

                        digitalWrite(In3, LOW);
                        digitalWrite(In4, LOW);
                    }


                    //函式 mfront，In1 與 In3 輸入 HIGH 電壓，In2 與 In4 接腳輸入 LOW 電壓
                    void mfront(){
                        Serial.println("mfront");
                        digitalWrite(In1, HIGH);

                        digitalWrite(In2, LOW);

                                                           221]]></page><page Index="231"><![CDATA[digitalWrite(In3, HIGH);

                        digitalWrite(In4, LOW);
                    }

                    //函式 mback，In1 與 In3 輸入 LOW 電壓，In2 與 In4 接腳輸入 HIGH 電壓

                    void mback(){
                        Serial.println("mback");
                        digitalWrite(In1, LOW);
                        digitalWrite(In2, HIGH);

                        digitalWrite(In3, LOW);
                        digitalWrite(In4, HIGH);
                    }


                    void mright(){
                        Serial.println("mright");
                        digitalWrite(In1, HIGH);
                        digitalWrite(In2, LOW);

                        digitalWrite(In3, LOW);
                        digitalWrite(In4, LOW);
                    }


                    void mleft(){
                        Serial.println("mleft");
                        digitalWrite(In1, LOW);
                        digitalWrite(In2, LOW);

                        digitalWrite(In3, HIGH);
                        digitalWrite(In4, LOW);
                    }


                   本專案完整程式
                    /*
                    *  藍芽循跡自走車  By Joker Wu

                    */

                    #include <SoftwareSerial.h>      //  引用程式庫

                    //  定義連接藍牙模組的序列埠

                    SoftwareSerial BT(2, 3); //  接收腳,  傳送腳

                                                           222]]></page><page Index="232"><![CDATA[//定義 L298N 上對應的腳位
                    const int In1 = 4;
                    const int In2 = 5;
                    const int In3 = 6;

                    const int In4 = 7;
                    const int EnA = 9; //速度調節腳位
                    const int EnB = 10; //速度調節腳位
                    int Speed = 50;


                    const int irD1=A1;//左紅外      --兩個紅外間距最好在 1.5-2cm
                    const int irD2=A2;//中
                    const int irD3=A3;//右
                    byte IRstatus=0;//紅外線循跡模組感應值


                    int trigPin = 12;                                    //Trig Pin
                    int echoPin = 13;                                    //Echo Pin

                    long duration, cm;

                    int ir_in;            //輸入類比信號值
                    char val;

                    int auto_f=0;

                    void setup(){
                        Serial.begin(9600);

                        pinMode(In1, OUTPUT);
                        pinMode(In2, OUTPUT);
                        pinMode(In3, OUTPUT);
                        pinMode(In4, OUTPUT);


                        pinMode(EnA, OUTPUT);
                        pinMode(EnB, OUTPUT);


                        pinMode(irD1,INPUT_PULLUP); //設置模擬引腳 A1 為含提升電阻的輸入引
                    腳
                        pinMode(irD2,INPUT_PULLUP);
                        pinMode(irD3,INPUT_PULLUP);



                                                           223]]></page><page Index="233"><![CDATA[pinMode(trigPin, OUTPUT);                //Define inputs and outputs

                        pinMode(echoPin, INPUT);

                        BT.begin(9600);
                    }

                    void loop(){
                            analogWrite(EnA,Speed);
                            analogWrite(EnB,Speed);


                            digitalWrite(trigPin, HIGH);
                            delay(50);
                            digitalWrite(trigPin, LOW);          //
                            duration = pulseIn(echoPin, HIGH);      //  收到高電位時的時間
                            cm = (duration/2) / 29.1;                  //  將時間換算成距離  cm



                            IRstatus=0;      //清除紅外線循跡模組感應值

                            ir_in=analogRead(irD1);//讀取“左 L＂紅外線循跡模組感應值
                            if(ir_in>=150)//感應到黑色軌道？
                                IRstatus=(IRstatus+4);                            //設置感應值位 2 為 1



                            ir_in=analogRead(irD2);//讀取中
                            if(ir_in>=150)//感應到黑色軌道？
                                IRstatus=(IRstatus+2);                //設置感應值位 1 為 1



                            ir_in=analogRead(irD3);    //讀取右
                            if(ir_in>=150)//感應到黑色軌道？
                                IRstatus=(IRstatus+1);                  //設置感應值位 0 為 1


                        //  若收到「序列埠監控視窗」的資料，則送到藍牙模組
                        if (Serial.available()) {

                            val = Serial.read();
                            BT.print(val);
                        }

                        //  若收到藍牙模組的資料，則送到「序列埠監控視窗」


                                                           224]]></page><page Index="234"><![CDATA[if (BT.available()) {

                            val = BT.read();
                            Serial.println(val);

                            if (val=='a')

                            {auto_f=1;}
                            else if (val=='h')
                            {auto_f=0;}


                            if(val=='0')
                            {Speed=50;}

                            if(val=='1')

                            {Speed=100;}

                            if(val=='2')
                            {Speed=150;}


                            if(val=='3')
                            {Speed=200;}


                            if(val=='4')
                            {Speed=255;}
                        }
                            if(cm>20){


                                if(auto_f==1)
                                {
                                      driveMotor(IRstatus); //按 IRstatus 值設置馬達轉向

                                }
                            else if(auto_f==0)
                            {
                            if(val=='f')

                            mfront();

                            if(val=='l')
                            mleft();



                                                           225]]></page><page Index="235"><![CDATA[if(val=='r')

                            mright();

                            if(val=='b')
                            mback();



                            if(val=='s')
                            mstop();

                            }
                        }

                            else{


                            if(auto_f==0)
                            {
                            if(val=='b')

                            mback();
                            else
                            mstop();
                            }


                            else if(auto_f==1)
                            mstop();


                                Serial.println("Too close,stop");

                                Serial.print(cm);
                                Serial.print("cm");

                                Serial.println();
                            }

                    }


                    void driveMotor(byte IRstatus)
                    {
                        switch(IRstatus)

                        {

                                                           226]]></page><page Index="236"><![CDATA[case 0:        //LCR=000，白白白

                              mstop();
                              break;
                            case 1://001，白白黑
                                mright();

                                break;
                            case 2:
                                mfront();
                                break;

                            case 3:
                                mright();
                                break;
                            case 4:

                                mleft();
                                break;
                            case 5:
                                mstop();

                                break;
                            case 6:
                                mleft();
                                break;

                            case 7:
                                mfront();
                                break;


                        }
                    }

                    //函式 mstop，In1、In2、In3 與 In4 接腳都輸入 LOW 電壓，車子將停止在原地

                    void mstop(){
                        Serial.println("mstop");
                        digitalWrite(In1, LOW);
                        digitalWrite(In2, LOW);

                        digitalWrite(In3, LOW);
                        digitalWrite(In4, LOW);
                    }

                    //函式 mfront，In1 與 In3 輸入 HIGH 電壓，In2 與 In4 接腳輸入 LOW 電壓


                                                           227]]></page><page Index="237"><![CDATA[void mfront(){

                        Serial.println("mfront");
                        digitalWrite(In1, HIGH);
                        digitalWrite(In2, LOW);
                        digitalWrite(In3, HIGH);

                        digitalWrite(In4, LOW);
                    }

                    //函式 mback，In1 與 In3 輸入 LOW 電壓，In2 與 In4 接腳輸入 HIGH 電壓

                    void mback(){
                        Serial.println("mback");
                        digitalWrite(In1, LOW);
                        digitalWrite(In2, HIGH);

                        digitalWrite(In3, LOW);
                        digitalWrite(In4, HIGH);
                    }


                    void mright(){
                        Serial.println("mright");
                        digitalWrite(In1, HIGH);
                        digitalWrite(In2, LOW);

                        digitalWrite(In3, LOW);
                        digitalWrite(In4, LOW);
                    }


                    void mleft(){
                        Serial.println("mleft");
                        digitalWrite(In1, LOW);
                        digitalWrite(In2, LOW);

                        digitalWrite(In3, HIGH);
                        digitalWrite(In4, LOW);
                    }



                   5.7.2 App 程式


                        本專案 App 以 MIT App Inventor (https://appinventor.mit.edu/)工具建置，如
                   圖 5.15 所示，開啟後左方為相關元件工具，本專案主要使用到的元件如圖 5.16


                                                           228]]></page><page Index="238"><![CDATA[所示。
























                                          圖 5.15 MIT App Inventor  開發環境















































                                                 圖 5.16 App  元件清單

                        於工作面板將元件排版好後，點選右上方程式設計即可進入程式畫面，如
                   圖 5.17 所示。


                                                           229]]></page><page Index="239"><![CDATA[圖 5.17 App 程式設計


                   進入程式編輯畫面後，點選左方元件，如圖所示，可顯示相關程式方塊。































                                                  圖 5.18 App 程式方塊












                                                           230]]></page><page Index="240"><![CDATA[本專案程式方塊如下所示，當 App 程式開啟時，首先進行初始化動作，開

                   啟藍芽功能，並將相關按鈕暫時凍結，只開啟藍芽裝置選擇。


























                        接著，當藍芽裝置清單選擇器被點選時，則進入準備選擇的方塊，此方塊
                   將手機所有搜尋到的藍芽裝置顯示出來。而當使用者選擇點選藍芽裝置後，則
                   進入選擇完成方塊。最後，為藍芽離線的程式方塊，當斷開藍芽前，此處我們

                   先發送訊號  s  給 Arduino，將自走車暫停行進。













































                                                           231]]></page><page Index="241"><![CDATA[App 控制前、後、左、右、停，分別有壓下與鬆開的程式方塊，當按鈕壓

                   下時，發送訊號給 Ardunio 而當鬆開時則發送停止訊號。












































                   因本專案有速度調整、自動循跡與手動藍芽控制模式，故當按下 auto 按鈕時發
                   送 a 訊號，按下 hand 按鈕時發送 h 訊號。速度的調整則以滑桿發送數字訊號。





























                   最後，完成程式後可於上方選單點擊打包 apk，如圖 5.19 所示，輸出二維條碼下

                                                           232]]></page><page Index="242"><![CDATA[載 Android 安裝檔，成果 App 執行畫面如圖 5.20 所示。


















                                           圖 5.19 智慧藍芽循跡自走車 App


















































                                           圖 5.20 智慧藍芽循跡自走車 App







                                                           233]]></page><page Index="243"><![CDATA[5.8 成果


                        本專案使用壓克力做成車體後，其成果外觀如圖 5.21 所示。透過本專案可
                   學習到藍芽傳輸、超音波、紅外線偵測與 L298N 的馬達控制，並了解現今運用
                   廣泛的自走車原理及建置方式。























































                                         圖 5.21 智慧藍芽循跡自走車成果展示














                                                           234]]></page><page Index="244"><![CDATA[CH 6  熱像儀




                   6.1 專案概述



                        本專案製作主要因應 COVID-19 疫情，為達到讓一般民眾也可利用低廉的成
                   本，讓居家多一道防線。所以我們這次藉由紅外線人體溫度感測器，來讓居家的
                   大門口多一道防線，在不接觸的狀況下測量體溫，以避免接觸的風險。


                   6.2 系統架構







































                                                 圖 6.1 熱像儀系統架構


                        本專案系統架構，如圖 6.1 所示，以 AMG8833 紅外線偵測人體溫度，透過
                   VGA 顯示於液晶銀幕或以 ESP8266 傳輸至伺服器上，使用者可透過電腦、手機
                   網頁看到熱像圖了解體溫狀況。


                   6.3 技術說明


                        本專案開發工具與環境如 6.1 表，以 C 語言在 Arduino IDE 開發主要控制程

                   式，並經 ESP8266 Wifi 以 Get 傳輸方式傳輸資料至伺服器上。伺服器以 apache、
                   mysql 及 php 搭建環境，伺服器端前端網頁則再搭配 HTML5、Java Script、jQuery
                                                           235]]></page><page Index="245"><![CDATA[等語言呈現熱像圖。此外，也可以 VGA 的方式顯示於液晶銀幕上。

                                             表 6.1 智能居家系統開發環境

                    開  發  程  式  語  言  與  本系統應用採用 C、HTML5、Java Script、jQuery、PHP 等

                    技術                  開發語言完成
                    資料交換技術              Post/Get  傳輸
                    系統開發工具              Ardunio Sketch、Notpad++
                    作業系統軟體              Win10、Android、iOS

                    Web Server          apache
                    DB Server           mysql


                   6.4 硬體接線







































                                              圖 6.2 熱像儀 VGA 硬體接線

                        如圖 6.2 所示，AMG8833 腳位 SCL 與 SDA 分別接於 Ardunio SDA (A4)與
                   SCL (A5)腳位。VGA 13(H-SYNC)腳加 68 Ω 接於 Ardunio  腳位 3，VGA 14(V-

                   SYNC)  加 68 Ω 接於 Ardunio  腳位 10。VGA 腳位  1(R)、2(G)、3(B)腳位加 220Ω
                   接於 Ardunio  腳位 7  ，VGA  腳位 5、6、7、8、9、10 與 Ardunio 共地。蜂鳴器
                   可接於腳位 6 而 LED 警示燈可接於 13 腳。電源 3V 供給 AMG8833。



                                                           236]]></page><page Index="246"><![CDATA[圖 6.3 熱像儀  ESP8266  接線

                        如圖 6.3 所示，AMG8833 腳位 SCL 與 SDA 分別接於 ESP8266 12F D1 與

                   D2 腳位。電源 3V 供給 AMG8833，ESP8266 與 AMG8833 共地。

                                                   表 6.2 熱像儀 BOM
                           名稱                      用量      說明

                           Ardunio Uno             1       主機板
                           ESP8266                 1       Wifi 模組
                           AMG8833                 1       紅外線體溫偵測模組

                           LED                     1       警示燈
                           Buzzer                  1       蜂鳴器
                           120 型VGA 視訊插座  1                Ardunio 連接 VGA 液晶銀幕

























                                                           237]]></page><page Index="247"><![CDATA[6.5 元件介紹


                   6.5.1 Adafruit AMG8833 IR Thermal 影像模組

































                                                    圖 6.4 AMG8833

                        Adafruit AMG8833 IR Thermal 影像模組是一款熱顯像攝影模組，AMG8833

                   是 8x8 紅外線熱陣列感測器，使用 I2C 傳輸資料。偵測距離最遠為 7 米，偵測溫
                   度範圍為 0°C~80°C（32°F~176°F），精度為+/-2.5°C（4.5°F）。最大偵測速度為
                   10Hz。
                   AMG8833 腳位介紹:

                   Vin -這是電源腳位。由於感測器使用 3.3V 電壓，因此包含了一個穩壓器，該穩
                   壓器將承受 3-5VDC 的電壓並安全地將其向下轉換。要為電路板供電，請給它提
                   供與微控制器邏輯電平相同的功率-例如對於像 Arduino 這樣的 5V 微型電池，請
                   使用 5V。
                   3V -這是穩壓器的 3.3V 輸出，可以從中獲得 100mA 電流。

                   GND -電源和邏輯的公共接地
                   邏輯腳位：
                                                           2
                   SCL -這是 I2C 時脉，連接到微控制器 I C 時脉。該引腳上有一個 10K 上拉電阻，
                   並且已進行電平轉換，因此您可以使用 3-5VDC。
                                                           2
                   SDA -這是 I2C 資料，連接到微控制器 I C 資料。該引腳上有一個 10K 上拉電阻，
                   並且已進行電平轉換，因此您可以使用 3-5VDC。
                   INT -這是中斷輸出。它是 3V 邏輯，您可以使用它來檢測感測器視線路徑何時發
                   生移動或改變。


                                                           238]]></page><page Index="248"><![CDATA[在使用 AMG8833 元件時，需引入其 Adafruit AMG8833 的函式庫。


                    #include <Adafruit_AMG88xx.h>

                   Adafruit AMG8833 函式庫函式說明:

                    bool    begin (uint8_t addr=AMG88xx_ADDRESS)
                   設置 I2C 接口和硬件。
                   參數

                   uint8_t addr：可以找到傳感器的可選 I2C 地址。默認值為 0x69。
                   回傳值：如果設置了設備，則為 true；如果發生故障，則為 false。

                    void    readPixels (float *buf, uint8_t size=AMG88xx_PIXEL_ARRAY_SIZE)

                   讀取紅外傳感器值。
                   參數
                   float *buf：放置像素的陣列
                   uint8_t size：可選的要讀取的字節數（最多 64 個）。預設值為 64 bytes。

                   回傳值：buf 中最多 64 bytes 的像素數據

                    float    readThermistor ()
                   讀取 AMG8833 熱敏電阻。

                   回傳值：浮點溫度，以攝氏度為單位。

                    void    setMovingAverageMode (bool mode)

                   設置移動平均模式。
                   參數
                   bool mode：如果通過 True，則輸出將是移動平均值的兩倍。


                    void    enableInterrupt ()
                   啟動設備上的中斷引腳。


                    void    disableInterrupt ()
                   禁用設備上的中斷引腳。

                    void    setInterruptMode (uint8_t mode)

                   將中斷設置為絕對值或差分模式。
                   參數
                   uint8_t  mode：傳    遞   AMG88xx_DIFFERENCE 會將設備設置為差異模式，

                   AMG88xx_ABSOLUTE_VALUE 設置為絕對值模式。
                                                           239]]></page><page Index="249"><![CDATA[void    getInterrupt (uint8_t *buf, uint8_t size=8)
                   讀取設備上已觸發中斷的狀態。完整的中斷寄存器的長度為 8 個字節。
                   參數
                   uint8_t *buf：指向將存儲返回的數據的指針

                   uint8_t size：讀取的可選字節數。默認值為 8 個字節。
                   回傳值：buf 中最多 8 個字節的數據。


                    void    clearInterrupt ()
                   清除所有觸發的中斷。

                    void    setInterruptLevels (float high, float low)

                   設置中斷級別。遲滯值默認為 0.95 *高。
                   參數
                   float high ：該值將觸發中斷。
                   float low  ：低於此值將觸發中斷。


                    void    setInterruptLevels (float high, float low, float hysteresis)
                   設置中斷層級。
                   參數

                   float high ：該值將觸發中斷
                   float low  ：低於此值將觸發中斷
                   float hysteresis：中斷檢測的遲滯值


                   基本顯示溫度程式範例
                    #include <Wire.h>
                    #include <Adafruit_AMG88xx.h>


                    Adafruit_AMG88xx amg;

                    void setup() {

                            Serial.begin(9600);
                            Serial.println(F("AMG88xx test"));
                            bool status;


                            // default settings
                            status = amg.begin();
                            if (!status) {

                                                           240]]></page><page Index="250"><![CDATA[Serial.println("Could not find a valid AMG88xx sensor, check wiring!");

                                    while (1);
                            }

                            Serial.println("-- Thermistor Test --");

                            Serial.println();
                            delay(100); // let sensor boot up
                    }


                    void loop() {
                            Serial.print("Thermistor Temperature = ");
                            Serial.print(amg.readThermistor());
                            Serial.println(" *C");

                            Serial.println();
                            //delay a second
                            delay(1000);
                    }


                   pixels 顯示像素矩陣溫度程式範例
                    #include <Wire.h>
                    #include <Adafruit_AMG88xx.h>


                    Adafruit_AMG88xx amg;


                    float pixels[AMG88xx_PIXEL_ARRAY_SIZE];

                    void setup() {
                            Serial.begin(9600);
                            Serial.println(F("AMG88xx pixels"));


                            bool status;


                            // default settings
                            status = amg.begin();
                            if (!status) {
                                    Serial.println("Could not find a valid AMG88xx sensor, check wiring!");
                                    while (1);

                            }

                                                           241]]></page><page Index="251"><![CDATA[Serial.println("-- Pixels Test --");
                            Serial.println();
                            delay(100); // let sensor boot up
                    }


                    void loop() {
                            //read all the pixels
                            amg.readPixels(pixels);


                            Serial.print("[");
                            for(int i=1; i<=AMG88xx_PIXEL_ARRAY_SIZE; i++){
                                Serial.print(pixels[i-1]);

                                Serial.print(", ");
                                if( i%8 == 0 ) Serial.println();
                            }
                            Serial.println("]");

                            Serial.println();
                            //delay a second
                            delay(1000);
                    }


                   6.6 系統程式



                        本  專  案  分  為  Arduino 程   式  與  ESP8266 程式，本         專  案  運  用  Arduino 的
                   Adafruit_GFX 程式庫為所有的 LCD 和 OLED 顯示器提供了通用語法和圖形功
                   能。這使得撰寫程式時，可以很容易在不同類型顯示器之間稍作調整即可使用，
                   而且操作簡單。


                   安裝 Adafruit_GFX 程式庫
                        Adafruit_GFX 程式庫為所有的 LCD 和 OLED 顯示器提供了通用語法和一組
                   圖形功能。讓使用者在不同的裝置間方便程式的轉換，本專案以 Adafruit-GFX-
                   Library 為主。


                   坐標系與單位
                        像素(Pixel) -  圖像的元素，用圖像上面的橫坐標（X）和縱坐標（Y）來表示。
                   座標（0，0）表示是左上角，X 正向增加是向右移動，Y 正向增加時向下移動。

                   Y 軸部分跟標準的笛卡爾坐標系剛好是顛倒的。但這已被許多的電腦圖像系統所

                                                           242]]></page><page Index="252"><![CDATA[採用的一種方式（回到真空管顯示器的 CRT 年代就是用這種坐標系）。與數學笛

                   卡爾坐標系不同，這裡的點具有尺寸  -  它們總是一個整數像素寬和高。座標是
                   以像素(Pixel)為單位表示，對於真實世界的度量（如毫米或英寸）沒有比例的概
                   念，並且顯示的圖形的大小將是該特定顯示器的點間距或圖元密度的函數。

                   顏色

                        Adafruit_GFX  程式庫內已經訂好常見的顏色，使用英文的方式表示，(註：
                   Adafruit 網站上定義的顏色有四個地方剛好相反，BLUE 跟 RED 兩個顏色需對
                   調，CYAN 跟 YELLOW 兩個顏色需對調）。對於單色的顯示，顏色用 1 或 0 來

                   表示。set/clear 的語義是定義特定的顯示，像發光的 OLED 顯示幕，SET 表示圖
                   元點亮，而對於 LCD 屏 ， SET 是特別黑。或許有例外，但一般情況下 CLEAR 一
                   般是表示背景顏色，一般情況大致會是這樣。
                    //  色彩定義

                    #define BLACK        0x0000
                    #define BLUE          0xF800
                    #define RED            0x001F
                    #define GREEN        0x07E0

                    #define CYAN          0xFFE0
                    #define MAGENTA    0xF81F
                    #define YELLOW      0x07FF
                    #define WHITE        0xFFFF


                   圖形基本元素
                   繪圖的基本原理是由點構成線、線構成面，在繪圖系統中，通常可以畫出點、線
                   及各種圖形，如圓形、方形及三角型等，以下分別介紹各繪圖函式：


                   ．畫點  Drawing pixels(points)
                   根據座標系，在顯示螢幕上的座標點 X 和 Y 處畫一個點，並使用 16 進位的顏色
                   碼顯示。

                    void drawPixel(uint16_t x, uint16_t y, uint16_t color);

                   ．畫線 Drawing lines

                   使用兩個座標點(x0,y0)及(x1,y1)畫一條線，並使用 16 進位的顏色碼顯示。
                    void drawLine(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t color)
                   如果是垂直和水平線，有快速畫線的方式，給一個座標值(x0,y0)，再給一個長度
                   值，就可畫出垂直跟水平線。

                    void drawFastVLine(uint16_t x0, uint16_t y0, uint16_t length, uint16_t color);
                    void drawFastHLine(uint8_t x0, uint8_t y0, uint8_t length, uint16_t color);

                                                           243]]></page><page Index="253"><![CDATA[．畫方形(Rectangles) /  填充顏色

                   使用特定顏色畫一個矩形方框，或使用特定顏色填滿一個矩形。在座標點(x0,y0)
                   為左上角，給予寬度 w，跟高度 h 畫出一個方形，計量的單位是都是畫素(Pixel)。
                   drawRect()畫矩形的外部，fillRect()用特定的顏色填充整個實體矩形空間。
                    void drawRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color);

                    void fillRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color);

                   ．Circles  畫圓圈

                   畫一個空的圓形，或是填充的圓形，只要給予一個圓心(x0,y0)，給予半徑 r，使
                   用特定的顏色值呈現。
                    void drawCircle(uint16_t x0, uint16_t y0, uint16_r, uint16_t color);
                    void fillCircle(uint16_t x0, uint16_t y0, uint16_t r, uint16_t color);


                   ．Rounded rectangle  圓角矩形
                   對於邊角是圓弧形的矩形也有空的和填充的功能。（x,y)為左上角的點，給一個寬
                   度 w 和高度 h，再給一個圓角圓弧半徑 r，最後是一個顏色值。

                    void  drawRoundRect(uint16_t  x0,  uint16_t  y0,  uint16_t  w,  uint16_t  h,  uint16_t
                    raduis, uint16_t color);
                    void fillRoundRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t raduis,
                    uint16_t color);


                   ．Triangles  三角形
                   要畫三角形，一樣有空的和填充功能，每個函數給予三角形的三個頂點座標點，
                   以及顏色值。

                    void drawTriangle(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t x2,
                    uint16_t y2, uint16_t color);
                    void  fillTriangle(uint16_t  x0,  uint16_t  y0,  uint16_t  x1,  uint16_t  y1,  uint16_t  x2,
                    uint16_t y2, uint16_t color);


                   ．Clearing or filling the screen  清除或者是填充螢幕
                   用 fillScreen()功能來設置整個顯示，可以讓顯示器顯示同一個顏色，並清除螢幕

                   上所有的內容。
                    void fillScreen(uint16_t color);

                   接線與電路圖

                   本專案為 VGA 顯示器與 Arduino UNO 板連接，並繪製形狀（線、圓、文字等）
                   並以 160×64 像素的分辨率顯示於畫面上，故其接線如圖所示。



                                                           244]]></page><page Index="254"><![CDATA[圖 6.5 VGA 與 Arduino UNO 連接
                          資料來源: https://simple-circuit.com/interfacing-arduino-vga-example/

                   範例程式

                    /******************************************************************
                    *******
                      *

                      * VGA output with Arduino (white and black colors).
                      * This is a free software with NO WARRANTY.
                      * https://simple-circuit.com/
                      *


                    *******************************************************************
                    *****/


                    #include <Adafruit_GFX.h>    // include Adafruit graphics library
                    #include "VGA.h"                      // include VGA library

                    // initialize the VGA library

                    VGA display = VGA();

                                                           245]]></page><page Index="255"><![CDATA[void setup(void) {
                        // initialize the VGA display
                        display.begin();


                        display.delay(5000);          // wait 5 seconds
                        display.clearDisplay();    // clear the screen buffer

                        display.setTextSize(1);

                        display.setTextColor(WHITE);
                        display.setCursor(0, 0);
                        display.println("Hello, world!");
                        display.setTextColor(BLACK, WHITE);

                        display.println(3.141592);
                        display.setTextSize(2);
                        display.setTextColor(WHITE);
                        display.print("0x");

                        display.println(0xDEADBEEF, HEX);

                        display.setCursor(0, 40);
                        display.setTextSize(1);

                        display.print("Arduino VGA Example");
                    }

                    void loop() {

                        ;
                    }

                    // end of code.



                   6.6.1 Ardunio / VGA

                   本專案 Arduino 程式分為兩個區塊介紹，其分別為前置命令與宣告、主程式。


                   前置命令與宣告
                   首先，引入核心圖形庫 Adafruit_GFX、自訂 VGA、I2C 用 Wire 與 AMG8833 官
                   方 Adafruit_AMG88xx 函式庫。

                    #include <Adafruit_GFX.h>    // include Adafruit graphics library

                                                           246]]></page><page Index="256"><![CDATA[#include "VGA.h"                      // include VGA library

                    #include <Wire.h>
                    #include <Adafruit_AMG88xx.h>

                   宣告與變數，主要將 VGA、AMG8833 宣告為物件，再將 AMG8833 讀取到的像

                   素陣列存於 pixels[]陣列變數內。
                    // initialize the VGA & AMG8833 library
                    VGA display = VGA();

                    Adafruit_AMG88xx amg;
                    float pixels[AMG88xx_PIXEL_ARRAY_SIZE];


                   主程式

                   主程式為 Ardunio 標準結構，setup()初始化內，主要將 VGA、amg 啟動，並設定
                   蜂鳴器與 LED 警示燈腳位。
                    void setup(void) {

                        // initialize the VGA display
                        display.begin();
                      // default settings
                        amg.begin();
                      //蜂鳴器

                      pinMode(6, OUTPUT);
                      //LED
                      pinMode(13, OUTPUT);

                    }

                   loop()程式內，使用 amg8833 標準讀取溫度像素矩陣方法，將取得的像素陣列最
                   大值輸出至 VGA 繪圖物件，繪出顯示於畫面上，最後再加上 if 判斷式使用 LED

                   警示燈與蜂鳴器警告聲。
                    void loop() {
                            //read all the pixels

                          amg.readPixels(pixels);
                          float max=pixels[0];
                    for(int i=0; i< AMG88xx_PIXEL_ARRAY_SIZE; i++){
                                if( pixels[i]>max )    {
                                  max=pixels[i];

                                }
                            }

                                                           247]]></page><page Index="257"><![CDATA[display.delay(1000);          // wait 5 seconds

                        display.clearDisplay();    // clear the screen buffer
                        display.setTextSize(3);
                        display.setTextColor(WHITE);
                        display.setCursor(0, 0);

                        display.println();

                        if(max<30)
                        {

                            display.println(max);
                            display.setTextSize(2);
                            display.println("Check BT.");
                        }

                        if(max>30)
                        {
                          display.println(max);
                          display.setTextSize(2);

                          display.println("Warning!!!");
                          digitalWrite(6,HIGH);
                          digitalWrite(13,HIGH);
                          //delay(6000);

                          display.delay(1000);          // wait 5 seconds
                        }
                        else
                        {

                        digitalWrite(6,LOW);
                        digitalWrite(13,LOW);
                        }
                    }




















                                                           248]]></page><page Index="258"><![CDATA[本專案完整程式

                    /******************************************************************
                    *******
                      *
                      * 2020.12.13 AMG8833 & VGA  熱像儀

                      * By Joker Wu
                      *
                    *******************************************************************
                    *****/


                    #include <Adafruit_GFX.h>    // include Adafruit graphics library
                    #include "VGA.h"                      // include VGA library
                    #include <Wire.h>

                    #include <Adafruit_AMG88xx.h>

                    // initialize the VGA & AMG8833 library
                    VGA display = VGA();

                    Adafruit_AMG88xx amg;
                    float pixels[AMG88xx_PIXEL_ARRAY_SIZE];

                    void setup(void) {


                        // initialize the VGA display
                        display.begin();
                      // default settings

                        amg.begin();
                      //蜂鳴器
                      pinMode(6, OUTPUT);
                      //LED

                      pinMode(13, OUTPUT);
                    }

                    void loop() {

                            //read all the pixels
                          amg.readPixels(pixels);
                          float max=pixels[0];
                    for(int i=0; i< AMG88xx_PIXEL_ARRAY_SIZE; i++){

                                if( pixels[i]>max )    {

                                                           249]]></page><page Index="259"><![CDATA[max=pixels[i];

                                }
                            }
                        display.delay(1000);          // wait 5 seconds
                        display.clearDisplay();    // clear the screen buffer

                        display.setTextSize(3);
                        display.setTextColor(WHITE);
                        display.setCursor(0, 0);
                        display.println();


                        if(max<30)
                        {
                            display.println(max);

                            display.setTextSize(2);
                            display.println("Check BT.");
                        }
                        if(max>30)

                        {
                          display.println(max);
                          display.setTextSize(2);
                          display.println("Warning!!!");

                          digitalWrite(6,HIGH);
                          digitalWrite(13,HIGH);
                          //delay(6000);
                          display.delay(1000);          // wait 5 seconds

                        }
                        else
                        {
                        digitalWrite(6,LOW);

                        digitalWrite(13,LOW);
                        }
                    }
                    // end of code.









                                                           250]]></page><page Index="260"><![CDATA[6.6.2 ESP8266


                        本專案不同於 Ardunio / VGA 方式，係將程式直接燒錄於 ESP8266 上，故不
                   需使用 Ardunio UNO 開發板。故在燒錄方式上需先指定開發板為 ESP8266，如
                   圖 6.6 所示。



































                                              圖 6.6 ESP8266 開發板選擇

                        更改為 ESP8266 後即可使用 ESP8266WiFi.h 與 ESP8266WiFiMulti.h 的標準
                   函式庫，其函式如表 6.3 所示。


                                        表 6.3 ESP8266 WiFi  函式庫的函式列表
                    函式                                       模式選項          模式解說
                    WiFi.mode(mode)             設定 WiFi 操 (1) WiFi_OFF     關閉 WiFi

                                               作模式          (2) WiFi_STA   STA 模式
                                                            (3) WiFi_AP   AP 模式
                                                            (4)           STA+AP 模式

                                                            WiFi_AP_STA
                    WiFi.begin(SSID,Password)    把 ESP8266
                                               連入 AP
                    WiFi.config(IP,Gateway,子網路  連入靜態 IP

                   遮罩)
                    WiFi.status()               查詢聯網狀態                     回傳 WL_CONNECTED(3)表
                                                                          已連上 WiFi AP

                                                           251]]></page><page Index="261"><![CDATA[WiFi.localIP()              查詢 IP
                    WiFi.macAddress()           查詢 MAC 實
                                               體位址
                    WiFi.RSSI()                 查詢訊號強度

                    WiFi.printDiag(序列埠)         向序列埠輸出
                                               網路資訊
                    WiFi.disconnect()           中斷連線


                        而當我們需要使用 ESP8266 開發板存儲多個 WiFi 網路連接資訊時，則可以
                   使用 ESP8266WiFiMulti 庫來實現會較為方便。而其函式庫有:
                   –  addAp – WiFi 連接資訊
                    wiFiMulti.addAP(ssid, password)

                   參數
                   ssid：需要添加的 WiFi 網路名稱
                   password：需要添加的 WiFi 網路密碼

                   回傳值：無

                   –  run –  連接 WiFi
                    wiFiMulti.run()

                   參數：無
                   回傳值
                   回傳值為整數型,以下是回傳值說明。
                   0 : WL_IDLE_STATUS –  當 WiFi 正在狀態之間切換時

                   1 : WL_NO_SSID_AVAIL –  無法訪問配置的 SSID
                   3 : WL_CONNECTED –  成功建立連接
                   4 : WL_CONNECT_FAILED –  密碼不正確
                   6 : WL_DISCONNECTED –  模組未配置為無線終端模式


                   –  cleanAPlist –  清除 WiFi 連接資訊
                   此函數可以刪除 ESP8266 開發板 WiFi 連接清單中的 WiFi 連接資訊。

                    WiFiMulti.cleanAPlist()
                   參數與回傳值：無

                   當使用  ESP8266 開發板方式，連結網際網路後，就可以將指定網頁的  HTML  原
                   始碼抓回來，顯示於  Arduino IDE 的序列埠中。


                   讀取網頁程序
                   首先要建立  ESP8266  客戶端物件，語法為：

                                                           252]]></page><page Index="262"><![CDATA[WiFiClient  物件名稱;

                   如建立名稱為「client」的物件：
                   WiFiClient client;

                   接著以客戶端物件的  connect  方法連接網頁伺服器，語法為：

                    客戶端物件.connect(主機,  埠號)
                    client.connect(host, port)
                   網頁伺服器的埠號預設是「80」。

                   例如連接「192.168.0.10」主機：
                   client.connect(“192.168.0.10”, 80);
                   通常會檢查主機是否連線成功，若未成功就顯示訊息告知使用者，例如：
                   if (!client.connect(“192.168.0.10”, 80)) {

                       Serial.println("connection failed!");
                       return;
                   }


                   網頁伺服器連線成功後，就可用「GET」方式向主機發出網頁請求，語法為：
                    客戶端物件.print(String("GET /") + " HTTP/1.1\r\n" + "Host:  主機\r\nConnection:
                    close\r\n\r\n");
                   例如：

                   client.print(String("GET /") + " HTTP/1.1\r\n" + "Host: 192.168.0.10\r\nConnection:
                   close\r\n\r\n");

                   網頁傳回值可用客戶端物件的  available  方法取得，語法為：

                    while(客戶端物件.available()){
                        資料處理程式碼
                    }
                   例如每次顯示一列資料，直到所有資料都顯示完畢：

                   while(client.available()){
                       String line = client.readStringUntil('\r');
                       Serial.print(line);

                   }

                   綜上所述，當目標是一般的 ip 或  http://  開頭的網站時
                    #include <Arduino.h>

                    #include <ESP8266WiFi.h>            //  提供 Wi-Fi 功能的程式庫
                    #include <ESP8266HTTPClient.h>
                    #include <ESP8266WiFiMulti.h>

                                                           253]]></page><page Index="263"><![CDATA[////////////////////////////

                    #define SSID      "**********"
                    #define PASSWORD    "**********"
                    #define host "192.168.0.10:80"
                    ////////////////////////////

                    ESP8266WiFiMulti WiFiMulti;
                    WiFiServer server(80);    //  宣告網站伺服器物件與埠號
                    const int httpPort = 80;
                    unsigned long t1,t2;

                    int i=0;

                    void data_to_web(String    data3, String    data4){


                    String url = "http://";
                                  url+=host;
                                  url+="/";
                                  url+=data3;

                                  url+=",";
                                  url+=data4;

                        // This will send the request to the server

                    if((WiFiMulti.run() == WL_CONNECTED)) {
                                    HTTPClient http;
                                    http.begin(url);
                                    int httpCode = http.GET();

                                    if(httpCode > 0) {
                                            if(httpCode == HTTP_CODE_OK) {
                                                    String payload = http.getString();    }
                                    } else {}

                                    http.end(); }}


                    void setup() {

                            Serial.begin(9600);
                            WiFiMulti.addAP(SSID, PASSWORD);
                    }


                    void loop(){

                                                           254]]></page><page Index="264"><![CDATA[i++;

                    data_to_web(String(123),String(i));
                    delay(1000);
                    }


                   關  於   https://  (例  如  Google Apps  Script  連  動    Google  sheet)函式庫，    需  下  載
                   HTTPSRedirect。


                   Google Apps Script Code
                    function doGet(e) {
                    var params = e.parameter;
                    var data = params.data;
                    var SpreadSheet =

                    SpreadsheetApp.openByUrl('https://docs.google.com/spreadsheets/d/1AArKJnr5Oz
                    PvQMkhGTuRhmllu7HwIhJMoZRJnQJUAFI/edit#gid=0'); //此處填入 Google 試
                    算表的網址

                    var Sheet = SpreadSheet.getSheetByName('1');    //此處填入試算表的標籤名稱

                    //var LastRow = Sheet.getLastRow();    //資料上舊下新

                    Sheet.insertRowBefore(1);                //資料上新下舊



                    //寫入資料

                    data = data.split(',');
                    data.forEach(function(e,i){
                    //Sheet.getRange(LastRow+1, i+1).setValue(e);    //(開啟資料上舊下新模式)
                    Sheet.getRange(1, i+1).setValue(e);                //(開啟資料上新下舊模式)
                    });

                    return  ContentService.createTextOutput(1);    // 接  收  成  功  以  後  回  傳  "1"( 類  似
                    Tingspeak)
                    }


                   ESP8266 Code
                    #include "ESP8266WiFi.h"
                    #include "HTTPSRedirect.h"


                    const char* ssid = "填入 Wifi SSID";

                                                           255]]></page><page Index="265"><![CDATA[const char* password = "填入 Wifi  密碼";

                    const char* host = "script.google.com";
                    const                    char                    *GScriptId                     =
                    "AKfycbx7ni19fQc1Gr6CCGjDKiSXQ9W2JKYloSodKv7yNP4df8jFWZMU";  //
                    Google script ID*(請見後方註解)

                    const int httpsPort = 443;
                    int i = 0;

                    HTTPSRedirect* client ;


                    void setup() {
                        Serial.begin(115200);
                        Serial.print("Connecting to wifi: ");

                        Serial.println(ssid);

                        WiFi.begin(ssid, password);
                        while (WiFi.status() != WL_CONNECTED) {

                            delay(500);
                            Serial.print(".");
                        }
                        Serial.println("");

                        Serial.println("WiFi connected");
                        Serial.println("IP address: ");
                        Serial.println(WiFi.localIP());


                        client = new HTTPSRedirect(httpsPort);
                        client->setPrintResponseBody(true);
                        client->setContentTypeHeader("application/json");
                        client->connect(host, httpsPort);


                        Serial.print("Connecting to ");
                        Serial.println(host);
                    }


                    void loop() {
                        i++;


                        String url3 = String("/macros/s/") + GScriptId + "/exec?data=";

                                                           256]]></page><page Index="266"><![CDATA[url3 += i;      //你要傳送的第一筆資料

                                      url3 += ",";
                                      url3 += 2*i; //你要傳送的第二筆資料

                        Serial.println("GET Data");

                        if (client->GET(url3, host)){
                            Serial.println("GET SUCCESS");
                        }


                        delay(4000);
                    }
                   GScriptId  的  來源請在  Google APPS Script 中，如圖所示。






































                                              圖 6.7 Google APPS Script ID

                   把上面那個網址複製下來後，複製紅色的位置(每個專案的 GScriptId 不同)

                   https://script.google.com/macros/s/AKfycbx7ni19fQc1Gr6CCGjDKiSXQ9W2JKYlo
                   SodKv7yNP4df8jFWZMU/exec

                   瞭解上述相關 ESP8266 函式庫與法後，本專案以標準 Ardunio 結構撰寫程式，分
                   為前置命令與宣告、主程式。



                                                           257]]></page><page Index="267"><![CDATA[前置命令與宣告

                   首先引入 ESP8266 相關之函式庫以及 AMG8833 所會用到的 I2C 函式庫 Wire.h
                   與  標  準   Adafruit_AMG88xx 函       式  庫  。  接  著  再  宣  告   ESP8266WiFiMulti 與
                   Adafruit_AMG88xx  物件，最後定義 AMG8833 讀取到的像素陣列存於 pixels[]陣
                   列變數內與 Wifi 連線使用的 ssid 與 password。

                    #include "ESP8266WiFi.h"
                    #include "ESP8266WiFiMulti.h"
                    #include <Wire.h>
                    #include <Adafruit_AMG88xx.h>


                    ESP8266WiFiMulti WiFiMulti;
                    Adafruit_AMG88xx amg;


                    float pixels[AMG88xx_PIXEL_ARRAY_SIZE];
                    const char* ssid = "**************";
                    const char* password = "**************";


                   主程式
                   主程式為 Ardunio 標準結構，setup()初始化內，首先設定與啟動 Wifi 連線，再將
                   AMG 啟動。
                    void setup() {

                    Serial.begin(115200);
                    delay(10);


                    // We start by connecting to a WiFi network
                    //ssid wifi 密碼
                    WiFiMulti.addAP(ssid, password);

                    Serial.println();

                    Serial.println();
                    Serial.print("Wait for WiFi... ");


                    while(WiFiMulti.run() != WL_CONNECTED) {
                    Serial.print(".");
                    delay(500);
                    }


                    Serial.println("");

                                                           258]]></page><page Index="268"><![CDATA[Serial.println("[成功]WiFi  已連接");

                    Serial.print("IP address: ");
                    Serial.println(WiFi.localIP());
                      delay(500);

                    Serial.println("體溫偵測.");

                    Serial.println(F("AMG88xx pixels"));

                            bool status;

                            // default settings
                            status = amg.begin();
                            if (!status) {
                                    Serial.println("Could not find a valid AMG88xx sensor, check wiring!");

                                    while (1);
                            }

                            Serial.println("-- Pixels Test --");

                            Serial.println();
                            delay(100); // let sensor boot up
                    }



                   loop()程式內，主要為將 AMG8833 讀取到的像素陣列透過 Wifi 傳輸至伺服器。
                    void loop() {

                    const uint16_t port = 80;
                    const char * host = "192.168.0.10"; // ip or dns

                    //後端記錄 server
                    Serial.print("連線至");

                    Serial.println(host);

                    // Use WiFiClient class to create TCP connections

                    WiFiClient client;

                    if (!client.connect(host, port)) {
                    Serial.println("connection failed");
                    Serial.println("wait 5 sec...");

                    delay(5000);

                                                           259]]></page><page Index="269"><![CDATA[return;

                    }

                    //read all the pixels
                            amg.readPixels(pixels);

                            String btval;
                            Serial.print("[");
                            for(int i=1; i<=AMG88xx_PIXEL_ARRAY_SIZE; i++){
                                Serial.print(pixels[i-1]);

                                btval+=pixels[i-1];
                                btval+=",";
                                Serial.print(", ");
                                if( i%8 == 0 ) Serial.println();

                            }
                            Serial.println("]");
                            Serial.println();


                            //delay a second
                            delay(1000);

                    String url = "/cbt/123.php?bt="+btval;

                    client.print(String("GET ") + url + " HTTP/1.1\r\n" +
                    "Host: " + host + "\r\n" +
                    "Connection: close\r\n\r\n");


                    Serial.println("連線關閉");
                    client.stop();

                    Serial.println("wait 1 sec...");

                    delay(1000);
                    }














                                                           260]]></page><page Index="270"><![CDATA[本專案完整程式

                    #include "ESP8266WiFi.h"
                    #include "ESP8266WiFiMulti.h"

                    #include <Wire.h>

                    #include <Adafruit_AMG88xx.h>

                    ESP8266WiFiMulti WiFiMulti;
                    Adafruit_AMG88xx amg;


                    float pixels[AMG88xx_PIXEL_ARRAY_SIZE];
                    const char* ssid = "**************";
                    const char* password = "**************";


                    void setup() {
                    Serial.begin(115200);
                    delay(10);


                    // We start by connecting to a WiFi network
                    //ssid wifi 密碼
                    WiFiMulti.addAP(ssid, password);


                    Serial.println();
                    Serial.println();
                    Serial.print("Wait for WiFi... ");


                    while(WiFiMulti.run() != WL_CONNECTED) {
                    Serial.print(".");
                    delay(500);

                    }

                    Serial.println("");
                    Serial.println("[成功]WiFi  已連接");

                    Serial.print("IP address: ");
                    Serial.println(WiFi.localIP());
                    delay(500);

                    Serial.println("體溫偵測.");


                                                           261]]></page><page Index="271"><![CDATA[Serial.println(F("AMG88xx pixels"));


                            bool status;

                            // default settings

                            status = amg.begin();
                            if (!status) {
                                    Serial.println("Could not find a valid AMG88xx sensor, check wiring!");
                                    while (1);

                            }

                            Serial.println("-- Pixels Test --");
                            Serial.println();

                            delay(100); // let sensor boot up
                    }

                    void loop() {

                    const uint16_t port = 80;
                    const char * host = "192.168.0.10"; // ip or dns

                    //後端記錄 server
                    Serial.print("連線至");

                    Serial.println(host);

                    // Use WiFiClient class to create TCP connections

                    WiFiClient client;

                    if (!client.connect(host, port)) {
                    Serial.println("connection failed");

                    Serial.println("wait 5 sec...");
                    delay(5000);
                    return;
                    }


                    //read all the pixels
                            amg.readPixels(pixels);
                            String btval;

                            Serial.print("[");

                                                           262]]></page><page Index="272"><![CDATA[for(int i=1; i<=AMG88xx_PIXEL_ARRAY_SIZE; i++){

                                Serial.print(pixels[i-1]);
                                btval+=pixels[i-1];
                                btval+=",";
                                Serial.print(", ");

                                if( i%8 == 0 ) Serial.println();
                            }
                            Serial.println("]");
                            Serial.println();

                            //delay a second
                            delay(1000);

                    String url = "/cbt/123.php?bt="+btval;

                    client.print(String("GET ") + url + " HTTP/1.1\r\n" +
                    "Host: " + host + "\r\n" +
                    "Connection: close\r\n\r\n");


                    Serial.println("連線關閉");
                    client.stop();
                    Serial.println("wait 1 sec...");
                    delay(1000);

                    }



                   6.6.3 Web 程式


                   本專案 Web 伺服器建置與介紹請參照第三章。

                   接收端程式

                    <?php
                    $str = $_GET['bt'];
                            $file = fopen("test.txt","w+"); //開啟檔案
                            fwrite($file,$str);

                            fclose($file);
                    //header( "location:index.php");    //回 index.php

                    ?>



                                                           263]]></page><page Index="273"><![CDATA[呈現

                    <!DOCTYPE html>
                    <html  lang="en"><head><meta  http-equiv="Content-Type"  content="text/html;
                    charset=UTF-8">


                        <title>GTO Joker Check BT.</title>
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <meta name="robots" content="index, follow">
                        <meta  name="description"  content="This  example  shows  how  to  use  dynamic

                    heatmap">
                        <meta name="keywords" content="tooltip, heatmap, heatmap.js legend, heatmap
                    legend">
                        <meta http-equiv="refresh" content="1">

                        <link rel="stylesheet" href="e-commons.css">
                        <style>
                                .legend-area  {  position:absolute;  bottom:0;  right:0;  padding:10px;
                    background:white; outline:3px solid black; line-height:1em; }

                                h4 { margin:0; padding:0; margin-bottom:5px;}
                                #min { float:left; }
                                #max { float:right; }
                                span { font-size:14px; margin:0; padding:0; }

                                .tooltip  {  position:absolute;  left:0;  top:0;  background:rgba(0,0,0,.8);
                    color:white; font-size:14px; padding:5px; line-height:18px; display:none;}
                                .demo-wrapper { position:relative; }
                        </style>


                    </head>
                    <body>
                    <?php

                    $file_path = "test.txt";
                    if(file_exists($file_path)){
                    $str = file_get_contents($file_path);//將整個檔案內容讀入到一個字串中
                    $str = str_replace("\r\n","<br />",$str);

                    //echo $str;
                    }
                    ?>
                    <center>

                    <h2>GoGoGo GTO Joker.</h2>

                                                           264]]></page><page Index="274"><![CDATA[<h2>Check Body Temperature.</h2>

                            <div class="demo-wrapper">
                                <div class="heatmap" style="position: relative;">

                                <canvas   class="heatmap-canvas"   width="400px"      height="400px"

                    style="position: absolute; left: 0px; top: 0px;"></canvas></div>

                              <div class="legend-area">
                                  <h4>溫度表</h4>

                                  <span id="min">0</span>
                                  <span id="max">40</span>
                                  <img                                                  id="gradient"
                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAKC

                    AYAAABCHPt+AAABaElEQVRYR82XYW+DIBRFDylE8f//zrafqqZuLKBPqG0
                    3nchm0rzc1GDyLofLU+Ac06NUqiCbNgPULcp2uKqFpiuijf6gwtEANWBRRbTp
                    gDNwVXB2cF2vFxaINZmrHsC2UHeZagvWm/r9eloP2NkMMeX4qltvxmTCBfC/
                    d3o2a3y/jCETIWMTpZnHV6OHiYzjTRgJHL+jZ0KEjPW1kCH3cTeLGUJLLj2T

                    8kjOO0KkcdLErTpt/isCAyFCxsb6YEi2zFhmUpoh9Q1sHzMkISZkTEbtM6TGJce
                    WKqKjIUmGBGMUXFxi1rMuR4gcV7Kbl3pvvrxY35zikbWk4Kddvuf/bIRkjvK4
                    XCBEyChXR0Li2V4q4IMh4Za1vZYnpGCwe0JKmZB+53T7nRlPt6zjMsSHeotqe
                    lzlCZnmkL3a9rhAnsw1j9roz02Z0UxzijR3qf0csyaTIiH/dQ4x97lpJa++f0rIxtuV3M

                    q+AJTYOmisdddoAAAAAElFTkSuQmCC" style="width:100%">
                                </div>
                            </div>


                        <script src="heatmap.min.js"></script>
                        <script>
                            window.onload = function() {


                                function generateRandomData(len) {
                                    // generate some random data
                                    var points = [];
                                    var max = 0;

                                    var min = 40;
                                    var width = 400;
                                    var height = 400;


                    var str ='<?=$str;?>';

                                                           265]]></page><page Index="275"><![CDATA[var strAry = str.split(',');

                    //document.write(strAry[1]);
                    i=0;
                    xx=0;
                    yy=0;


                                    while (len--) {
                                        //var val = Math.floor(Math.random()*40);
                                  var val = strAry[i];

                                        max = Math.max(max, val);
                                        min = Math.min(min, val);

                                  if(i>=0&&i<8)

                                  {
                                  xx=25+i*50;
                                  yy=45;
                                  }


                                  if(i>=8&&i<16)
                                  {
                                  xx=25+((i-8)*50);

                                  yy=45*2;
                                  }

                                  if(i>=16&&i<24)

                                  {
                                  xx=25+((i-16)*50);
                                  yy=45*3;
                                  }


                                  if(i>=24&&i<32)
                                  {
                                  xx=25+((i-24)*50);

                                  yy=45*4;
                                  }

                                  if(i>=32&&i<40)

                                  {

                                                           266]]></page><page Index="276"><![CDATA[xx=25+((i-32)*50);

                                  yy=45*5;
                                  }

                                  if(i>=40&&i<48)

                                  {
                                  xx=25+((i-40)*50);
                                  yy=45*6;
                                  }


                                  if(i>=48&&i<56)
                                  {
                                  xx=25+((i-48)*50);

                                  yy=45*7;
                                  }

                                  if(i>=56&&i<64)

                                  {
                                  xx=25+((i-56)*50);
                                  yy=45*8;
                                  }


                                        var point = {
                                            //x: Math.floor(Math.random()*width),
                                  x: Math.floor(xx),

                                            //y: Math.floor(Math.random()*height),
                                  y: Math.floor(yy),
                                            value: val
                                        };

                                        points.push(point);
                                  i++;
                                    }


                                    var data = { max: max, min:min, data: points };
                                    return data;
                                };


                                    /*    legend code */

                                                           267]]></page><page Index="277"><![CDATA[// we want to display the gradient, so we have to draw it

                                    var legendCanvas = document.createElement('canvas');
                                    legendCanvas.width = 100;
                                    legendCanvas.height = 10;
                                    var min = document.querySelector('#min');

                                    var max = document.querySelector('#max');
                                    var gradientImg = document.querySelector('#gradient');

                                    var legendCtx = legendCanvas.getContext('2d');

                                    var gradientCfg = {};

                                    function updateLegend(data) {
                                        //  the  onExtremaChange  callback  gives  us  min,  max,  and  the

                    gradientConfig
                                        // so we can update the legend
                                        min.innerHTML = data.min;
                                        max.innerHTML = data.max;

                                        // regenerate gradient image
                                        if (data.gradient != gradientCfg) {
                                            gradientCfg = data.gradient;
                                            var gradient = legendCtx.createLinearGradient(0, 0, 100, 1);

                                            for (var key in gradientCfg) {
                                                gradient.addColorStop(key, gradientCfg[key]);
                                            }


                                            legendCtx.fillStyle = gradient;
                                            legendCtx.fillRect(0, 0, 100, 10);
                                            gradientImg.src = legendCanvas.toDataURL();
                                        }

                                    };
                                    /* legend code end */

                                var heatmapInstance = h337.create({

                                    container: document.querySelector('.heatmap'),
                                    onExtremaChange: function(data) {
                                        updateLegend(data);
                                    }

                                });

                                                           268]]></page><page Index="278"><![CDATA[// generate 200 random datapoints
                                var data = generateRandomData(64);
                                heatmapInstance.setData(data);
                            };

                        </script>
                    <p>by Joker Wu design.</p>
                    <font size="2px">
                    <script language="javascript">

                      var Today=new Date();
                      document.write("Date " + Today.getFullYear()+ " . " + (Today.getMonth()+1) + " .
                    " + Today.getDate() + " ");


                    document.write(Today.getHours()+':'+Today.getMinutes()+':'+Today.getSeconds());
                    </script>
                    <!--<p><font size="2px">2020.12.14 </p>-->
                    </body></html>


                   6.7  成果


                        本專案分別使用 VGA 與 ESP8266 顯示，其成果如圖 6.4 所示。透過本專案

                   可學習到 VGA 訊號與像素矩陣、熱像圖原理，了解紅外線體溫偵測原理與圖像
                   建置方式，並更進一步學習使用 ESP8266 開發板的方式。


































                                                           269]]></page><page Index="279"><![CDATA[圖 6.8  熱像儀成果









































                                                           270]]></page><page Index="280"><![CDATA[著作權聲明

                                 本書著作權為作者所有，並受著作權法保護，未取得作者書面授權前，不
                                 得任意拷貝、翻印、重製或從事其他違反法令之行為。

                                 商標與聲明

                                 本書所引用之商標、產品、圖片、產品名稱，產品相關資料等皆屬
                                 原所屬公司所有，本書引用純屬介紹與推廣之用，並依學術著作慣
                                 例標明引用出處，且無任何侵權之意。
                                 原始程式聲明

                                 本書所引用之網路上之程式、函數、範例等相關原始碼，其內容皆
                                 屬原創作者所有，本書引用純屬介紹與推廣之用，並依學術著作慣
                                 例標明引用出處，且無任何侵權之意

                                 有限擔保責任聲明
                                 雖然作者與出版社已全力著作與編輯本書籍，但不擔保本書內容與

                                 所附程式無任何瑕疵，亦不為讀者使用本書所引起之衍生利益、衍
                                 生損失或意外毀損擔保責任。本書所負之責任僅限於讀者購買本書
                                 所付出給作者實際支出金額為最高求償責任，讀者取得與閱讀本書

                                 所衍生之無形與有形之費用、損失、收益、衍生之效益皆屬讀者所
                                 有，一概與作者及出版社無關。
                                                    Copyright All Reserved

                                                   ~  版權所有，翻印必究~






































                                                           271]]></page><page Index="281"><![CDATA[作者介紹


                             吳佳鑫  (Jia-Xin Wu)  ，目前為職訓講師與大學兼任講
                             師，專研於軟體開發設計、物聯網、自動化工控軟體、AI
                             人工智能與雲端資訊化商品及網路社群行銷等。

                             Email: jokerxwu@gmail.com
                             Line ID：jokerwu0301
                             部落格：

                             http://jokerwu0301.pixnet.net/blog
                             臉  書  社  群：
                             http://www.facebook.com/jakerwu0301

                             Youtube：

                             https://www.youtube.com/c/jokerwu0301






















































                                                           272]]></page></pages></Search>